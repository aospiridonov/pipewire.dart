// ignore_for_file: camel_case_types, non_constant_identifier_names, constant_identifier_names, no_leading_underscores_for_local_identifiers, library_private_types_in_public_api
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to Pipewire
class Pipewire {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Pipewire(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Pipewire.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int imaxabs(
    int __n,
  ) {
    return _imaxabs(
      __n,
    );
  }

  late final _imaxabsPtr =
      _lookup<ffi.NativeFunction<intmax_t Function(intmax_t)>>('imaxabs');
  late final _imaxabs = _imaxabsPtr.asFunction<int Function(int)>();

  imaxdiv_t imaxdiv(
    int __numer,
    int __denom,
  ) {
    return _imaxdiv(
      __numer,
      __denom,
    );
  }

  late final _imaxdivPtr =
      _lookup<ffi.NativeFunction<imaxdiv_t Function(intmax_t, intmax_t)>>(
          'imaxdiv');
  late final _imaxdiv = _imaxdivPtr.asFunction<imaxdiv_t Function(int, int)>();

  int strtoimax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoimax');
  late final _strtoimax = _strtoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoumax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoumax');
  late final _strtoumax = _strtoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int wcstoimax(
    ffi.Pointer<__gwchar_t> __nptr,
    ffi.Pointer<ffi.Pointer<__gwchar_t>> __endptr,
    int __base,
  ) {
    return _wcstoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<__gwchar_t>,
              ffi.Pointer<ffi.Pointer<__gwchar_t>>, ffi.Int)>>('wcstoimax');
  late final _wcstoimax = _wcstoimaxPtr.asFunction<
      int Function(ffi.Pointer<__gwchar_t>,
          ffi.Pointer<ffi.Pointer<__gwchar_t>>, int)>();

  int wcstoumax(
    ffi.Pointer<__gwchar_t> __nptr,
    ffi.Pointer<ffi.Pointer<__gwchar_t>> __endptr,
    int __base,
  ) {
    return _wcstoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<__gwchar_t>,
              ffi.Pointer<ffi.Pointer<__gwchar_t>>, ffi.Int)>>('wcstoumax');
  late final _wcstoumax = _wcstoumaxPtr.asFunction<
      int Function(ffi.Pointer<__gwchar_t>,
          ffi.Pointer<ffi.Pointer<__gwchar_t>>, int)>();

  __sighandler_t signal(
    int __sig,
    __sighandler_t __handler,
  ) {
    return _signal(
      __sig,
      __handler,
    );
  }

  late final _signalPtr = _lookup<
          ffi.NativeFunction<__sighandler_t Function(ffi.Int, __sighandler_t)>>(
      'signal');
  late final _signal =
      _signalPtr.asFunction<__sighandler_t Function(int, __sighandler_t)>();

  int kill(
    int __pid,
    int __sig,
  ) {
    return _kill(
      __pid,
      __sig,
    );
  }

  late final _killPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__pid_t, ffi.Int)>>('kill');
  late final _kill = _killPtr.asFunction<int Function(int, int)>();

  int killpg(
    int __pgrp,
    int __sig,
  ) {
    return _killpg(
      __pgrp,
      __sig,
    );
  }

  late final _killpgPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__pid_t, ffi.Int)>>('killpg');
  late final _killpg = _killpgPtr.asFunction<int Function(int, int)>();

  int raise(
    int __sig,
  ) {
    return _raise(
      __sig,
    );
  }

  late final _raisePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('raise');
  late final _raise = _raisePtr.asFunction<int Function(int)>();

  __sighandler_t ssignal(
    int __sig,
    __sighandler_t __handler,
  ) {
    return _ssignal(
      __sig,
      __handler,
    );
  }

  late final _ssignalPtr = _lookup<
          ffi.NativeFunction<__sighandler_t Function(ffi.Int, __sighandler_t)>>(
      'ssignal');
  late final _ssignal =
      _ssignalPtr.asFunction<__sighandler_t Function(int, __sighandler_t)>();

  int gsignal(
    int __sig,
  ) {
    return _gsignal(
      __sig,
    );
  }

  late final _gsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('gsignal');
  late final _gsignal = _gsignalPtr.asFunction<int Function(int)>();

  void psignal(
    int __sig,
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _psignal(
      __sig,
      __s,
    );
  }

  late final _psignalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('psignal');
  late final _psignal =
      _psignalPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  void psiginfo(
    ffi.Pointer<siginfo_t> __pinfo,
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _psiginfo(
      __pinfo,
      __s,
    );
  }

  late final _psiginfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Char>)>>('psiginfo');
  late final _psiginfo = _psiginfoPtr.asFunction<
      void Function(ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Char>)>();

  int sigblock(
    int __mask,
  ) {
    return _sigblock(
      __mask,
    );
  }

  late final _sigblockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('sigblock');
  late final _sigblock = _sigblockPtr.asFunction<int Function(int)>();

  int sigsetmask(
    int __mask,
  ) {
    return _sigsetmask(
      __mask,
    );
  }

  late final _sigsetmaskPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('sigsetmask');
  late final _sigsetmask = _sigsetmaskPtr.asFunction<int Function(int)>();

  int siggetmask() {
    return _siggetmask();
  }

  late final _siggetmaskPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('siggetmask');
  late final _siggetmask = _siggetmaskPtr.asFunction<int Function()>();

  int sigemptyset(
    ffi.Pointer<sigset_t> __set,
  ) {
    return _sigemptyset(
      __set,
    );
  }

  late final _sigemptysetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>)>>(
          'sigemptyset');
  late final _sigemptyset =
      _sigemptysetPtr.asFunction<int Function(ffi.Pointer<sigset_t>)>();

  int sigfillset(
    ffi.Pointer<sigset_t> __set,
  ) {
    return _sigfillset(
      __set,
    );
  }

  late final _sigfillsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>)>>(
          'sigfillset');
  late final _sigfillset =
      _sigfillsetPtr.asFunction<int Function(ffi.Pointer<sigset_t>)>();

  int sigaddset(
    ffi.Pointer<sigset_t> __set,
    int __signo,
  ) {
    return _sigaddset(
      __set,
      __signo,
    );
  }

  late final _sigaddsetPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>, ffi.Int)>>(
      'sigaddset');
  late final _sigaddset =
      _sigaddsetPtr.asFunction<int Function(ffi.Pointer<sigset_t>, int)>();

  int sigdelset(
    ffi.Pointer<sigset_t> __set,
    int __signo,
  ) {
    return _sigdelset(
      __set,
      __signo,
    );
  }

  late final _sigdelsetPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>, ffi.Int)>>(
      'sigdelset');
  late final _sigdelset =
      _sigdelsetPtr.asFunction<int Function(ffi.Pointer<sigset_t>, int)>();

  int sigismember(
    ffi.Pointer<sigset_t> __set,
    int __signo,
  ) {
    return _sigismember(
      __set,
      __signo,
    );
  }

  late final _sigismemberPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>, ffi.Int)>>(
      'sigismember');
  late final _sigismember =
      _sigismemberPtr.asFunction<int Function(ffi.Pointer<sigset_t>, int)>();

  int sigprocmask(
    int __how,
    ffi.Pointer<sigset_t> __set,
    ffi.Pointer<sigset_t> __oset,
  ) {
    return _sigprocmask(
      __how,
      __set,
      __oset,
    );
  }

  late final _sigprocmaskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<sigset_t>,
              ffi.Pointer<sigset_t>)>>('sigprocmask');
  late final _sigprocmask = _sigprocmaskPtr.asFunction<
      int Function(int, ffi.Pointer<sigset_t>, ffi.Pointer<sigset_t>)>();

  int sigsuspend(
    ffi.Pointer<sigset_t> __set,
  ) {
    return _sigsuspend(
      __set,
    );
  }

  late final _sigsuspendPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>)>>(
          'sigsuspend');
  late final _sigsuspend =
      _sigsuspendPtr.asFunction<int Function(ffi.Pointer<sigset_t>)>();

  int sigaction1(
    int __sig,
    ffi.Pointer<sigaction> __act,
    ffi.Pointer<sigaction> __oact,
  ) {
    return _sigaction1(
      __sig,
      __act,
      __oact,
    );
  }

  late final _sigaction1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<sigaction>,
              ffi.Pointer<sigaction>)>>('sigaction');
  late final _sigaction1 = _sigaction1Ptr.asFunction<
      int Function(int, ffi.Pointer<sigaction>, ffi.Pointer<sigaction>)>();

  int sigpending(
    ffi.Pointer<sigset_t> __set,
  ) {
    return _sigpending(
      __set,
    );
  }

  late final _sigpendingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>)>>(
          'sigpending');
  late final _sigpending =
      _sigpendingPtr.asFunction<int Function(ffi.Pointer<sigset_t>)>();

  int sigwait(
    ffi.Pointer<sigset_t> __set,
    ffi.Pointer<ffi.Int> __sig,
  ) {
    return _sigwait(
      __set,
      __sig,
    );
  }

  late final _sigwaitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<sigset_t>, ffi.Pointer<ffi.Int>)>>('sigwait');
  late final _sigwait = _sigwaitPtr
      .asFunction<int Function(ffi.Pointer<sigset_t>, ffi.Pointer<ffi.Int>)>();

  int sigwaitinfo(
    ffi.Pointer<sigset_t> __set,
    ffi.Pointer<siginfo_t> __info,
  ) {
    return _sigwaitinfo(
      __set,
      __info,
    );
  }

  late final _sigwaitinfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<sigset_t>, ffi.Pointer<siginfo_t>)>>('sigwaitinfo');
  late final _sigwaitinfo = _sigwaitinfoPtr.asFunction<
      int Function(ffi.Pointer<sigset_t>, ffi.Pointer<siginfo_t>)>();

  int sigtimedwait(
    ffi.Pointer<sigset_t> __set,
    ffi.Pointer<siginfo_t> __info,
    ffi.Pointer<timespec> __timeout,
  ) {
    return _sigtimedwait(
      __set,
      __info,
      __timeout,
    );
  }

  late final _sigtimedwaitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<sigset_t>, ffi.Pointer<siginfo_t>,
              ffi.Pointer<timespec>)>>('sigtimedwait');
  late final _sigtimedwait = _sigtimedwaitPtr.asFunction<
      int Function(ffi.Pointer<sigset_t>, ffi.Pointer<siginfo_t>,
          ffi.Pointer<timespec>)>();

  int sigqueue(
    int __pid,
    int __sig,
    sigval __val,
  ) {
    return _sigqueue(
      __pid,
      __sig,
      __val,
    );
  }

  late final _sigqueuePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__pid_t, ffi.Int, sigval)>>(
          'sigqueue');
  late final _sigqueue =
      _sigqueuePtr.asFunction<int Function(int, int, sigval)>();

  int sigreturn(
    ffi.Pointer<sigcontext> __scp,
  ) {
    return _sigreturn(
      __scp,
    );
  }

  late final _sigreturnPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigcontext>)>>(
          'sigreturn');
  late final _sigreturn =
      _sigreturnPtr.asFunction<int Function(ffi.Pointer<sigcontext>)>();

  int siginterrupt(
    int __sig,
    int __interrupt,
  ) {
    return _siginterrupt(
      __sig,
      __interrupt,
    );
  }

  late final _siginterruptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'siginterrupt');
  late final _siginterrupt =
      _siginterruptPtr.asFunction<int Function(int, int)>();

  int sigaltstack(
    ffi.Pointer<stack_t> __ss,
    ffi.Pointer<stack_t> __oss,
  ) {
    return _sigaltstack(
      __ss,
      __oss,
    );
  }

  late final _sigaltstackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<stack_t>, ffi.Pointer<stack_t>)>>('sigaltstack');
  late final _sigaltstack = _sigaltstackPtr
      .asFunction<int Function(ffi.Pointer<stack_t>, ffi.Pointer<stack_t>)>();

  int sigstack1(
    ffi.Pointer<sigstack> __ss,
    ffi.Pointer<sigstack> __oss,
  ) {
    return _sigstack1(
      __ss,
      __oss,
    );
  }

  late final _sigstack1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<sigstack>, ffi.Pointer<sigstack>)>>('sigstack');
  late final _sigstack1 = _sigstack1Ptr
      .asFunction<int Function(ffi.Pointer<sigstack>, ffi.Pointer<sigstack>)>();

  int pthread_sigmask(
    int __how,
    ffi.Pointer<__sigset_t> __newmask,
    ffi.Pointer<__sigset_t> __oldmask,
  ) {
    return _pthread_sigmask(
      __how,
      __newmask,
      __oldmask,
    );
  }

  late final _pthread_sigmaskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<__sigset_t>,
              ffi.Pointer<__sigset_t>)>>('pthread_sigmask');
  late final _pthread_sigmask = _pthread_sigmaskPtr.asFunction<
      int Function(int, ffi.Pointer<__sigset_t>, ffi.Pointer<__sigset_t>)>();

  int pthread_kill(
    int __threadid,
    int __signo,
  ) {
    return _pthread_kill(
      __threadid,
      __signo,
    );
  }

  late final _pthread_killPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(pthread_t, ffi.Int)>>(
          'pthread_kill');
  late final _pthread_kill =
      _pthread_killPtr.asFunction<int Function(int, int)>();

  double atof(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atof(
      __nptr,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoi(
      __nptr,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atol(
      __nptr,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoll(
      __nptr,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double strtod(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtod(
      __nptr,
      __endptr,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtof(
      __nptr,
      __endptr,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  ffi.Pointer<ffi.Char> l64a(
    int __n,
  ) {
    return _l64a(
      __n,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _a64l(
      __s,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int select(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timeval> __timeout,
  ) {
    return _select(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
    );
  }

  late final _selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>>('select');
  late final _select = _selectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>();

  int pselect(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timespec> __timeout,
    ffi.Pointer<__sigset_t> __sigmask,
  ) {
    return _pselect(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
      __sigmask,
    );
  }

  late final _pselectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<timespec>,
              ffi.Pointer<__sigset_t>)>>('pselect');
  late final _pselect = _pselectPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<timespec>,
          ffi.Pointer<__sigset_t>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  void srandom(
    int __seed,
  ) {
    return _srandom(
      __seed,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
  ) {
    return _initstate(
      __seed,
      __statebuf,
      __statelen,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> __statebuf,
  ) {
    return _setstate(
      __statebuf,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int random_r(
    ffi.Pointer<random_data> __buf,
    ffi.Pointer<ffi.Int32> __result,
  ) {
    return _random_r(
      __buf,
      __result,
    );
  }

  late final _random_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>>('random_r');
  late final _random_r = _random_rPtr.asFunction<
      int Function(ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>();

  int srandom_r(
    int __seed,
    ffi.Pointer<random_data> __buf,
  ) {
    return _srandom_r(
      __seed,
      __buf,
    );
  }

  late final _srandom_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<random_data>)>>('srandom_r');
  late final _srandom_r =
      _srandom_rPtr.asFunction<int Function(int, ffi.Pointer<random_data>)>();

  int initstate_r(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
    ffi.Pointer<random_data> __buf,
  ) {
    return _initstate_r(
      __seed,
      __statebuf,
      __statelen,
      __buf,
    );
  }

  late final _initstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<random_data>)>>('initstate_r');
  late final _initstate_r = _initstate_rPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<random_data>)>();

  int setstate_r(
    ffi.Pointer<ffi.Char> __statebuf,
    ffi.Pointer<random_data> __buf,
  ) {
    return _setstate_r(
      __statebuf,
      __buf,
    );
  }

  late final _setstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>>('setstate_r');
  late final _setstate_r = _setstate_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int __seed,
  ) {
    return _srand(
      __seed,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> __seed,
  ) {
    return _rand_r(
      __seed,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _erand48(
      __xsubi,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _nrand48(
      __xsubi,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _jrand48(
      __xsubi,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  void srand48(
    int __seedval,
  ) {
    return _srand48(
      __seedval,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
  ) {
    return _seed48(
      __seed16v,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> __param,
  ) {
    return _lcong48(
      __param,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int drand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _drand48_r(
      __buffer,
      __result,
    );
  }

  late final _drand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('drand48_r');
  late final _drand48_r = _drand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Double>)>();

  int erand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _erand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _erand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('erand48_r');
  late final _erand48_r = _erand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Double>)>();

  int lrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _lrand48_r(
      __buffer,
      __result,
    );
  }

  late final _lrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('lrand48_r');
  late final _lrand48_r = _lrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int nrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _nrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _nrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('nrand48_r');
  late final _nrand48_r = _nrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int mrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _mrand48_r(
      __buffer,
      __result,
    );
  }

  late final _mrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('mrand48_r');
  late final _mrand48_r = _mrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int jrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _jrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _jrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('jrand48_r');
  late final _jrand48_r = _jrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int srand48_r(
    int __seedval,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _srand48_r(
      __seedval,
      __buffer,
    );
  }

  late final _srand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Long, ffi.Pointer<drand48_data>)>>('srand48_r');
  late final _srand48_r =
      _srand48_rPtr.asFunction<int Function(int, ffi.Pointer<drand48_data>)>();

  int seed48_r(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _seed48_r(
      __seed16v,
      __buffer,
    );
  }

  late final _seed48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('seed48_r');
  late final _seed48_r = _seed48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  int lcong48_r(
    ffi.Pointer<ffi.UnsignedShort> __param,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _lcong48_r(
      __param,
      __buffer,
    );
  }

  late final _lcong48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('lcong48_r');
  late final _lcong48_r = _lcong48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __nmemb,
    int __size,
  ) {
    return _calloc(
      __nmemb,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void free(
    ffi.Pointer<ffi.Void> __ptr,
  ) {
    return _free(
      __ptr,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> reallocarray(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('reallocarray');
  late final _reallocarray = _reallocarrayPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _atexit(
      __func,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _at_quick_exit(
      __func,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int on_exit(
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>
        __func,
    ffi.Pointer<ffi.Void> __arg,
  ) {
    return _on_exit(
      __func,
      __arg,
    );
  }

  late final _on_exitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Void>)>>('on_exit');
  late final _on_exit = _on_exitPtr.asFunction<
      int Function(
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>,
          ffi.Pointer<ffi.Void>)>();

  void exit(
    int __status,
  ) {
    return _exit(
      __status,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  void quick_exit(
    int __status,
  ) {
    return _quick_exit(
      __status,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _getenv(
      __name,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int putenv(
    ffi.Pointer<ffi.Char> __string,
  ) {
    return _putenv(
      __string,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __replace,
  ) {
    return _setenv(
      __name,
      __value,
      __replace,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _unsetenv(
      __name,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int clearenv() {
    return _clearenv();
  }

  late final _clearenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('clearenv');
  late final _clearenv = _clearenvPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mktemp(
      __template,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkstemp(
      __template,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mkstemps(
    ffi.Pointer<ffi.Char> __template,
    int __suffixlen,
  ) {
    return _mkstemps(
      __template,
      __suffixlen,
    );
  }

  late final _mkstempsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkstemps');
  late final _mkstemps =
      _mkstempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> mkdtemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkdtemp(
      __template,
    );
  }

  late final _mkdtempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mkdtemp');
  late final _mkdtemp = _mkdtempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int system(
    ffi.Pointer<ffi.Char> __command,
  ) {
    return _system(
      __command,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __resolved,
  ) {
    return _realpath(
      __name,
      __resolved,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              __compar_fn_t)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _qsort(
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              __compar_fn_t)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  int abs(
    int __x,
  ) {
    return _abs(
      __x,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int labs(
    int __x,
  ) {
    return _labs(
      __x,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  int llabs(
    int __x,
  ) {
    return _llabs(
      __x,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  div_t div(
    int __numer,
    int __denom,
  ) {
    return _div(
      __numer,
      __denom,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  ldiv_t ldiv(
    int __numer,
    int __denom,
  ) {
    return _ldiv(
      __numer,
      __denom,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  lldiv_t lldiv(
    int __numer,
    int __denom,
  ) {
    return _lldiv(
      __numer,
      __denom,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  ffi.Pointer<ffi.Char> ecvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _ecvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _fcvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _gcvt(
      __value,
      __ndigit,
      __buf,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int ecvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _ecvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _ecvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('ecvt_r');
  late final _ecvt_r = _ecvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int fcvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _fcvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _fcvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('fcvt_r');
  late final _fcvt_r = _fcvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> __pwc,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbtowc(
      __pwc,
      __s,
      __n,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> __s,
    int __wchar,
  ) {
    return _wctomb(
      __s,
      __wchar,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> __pwcs,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbstowcs(
      __pwcs,
      __s,
      __n,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.WChar> __pwcs,
    int __n,
  ) {
    return _wcstombs(
      __s,
      __pwcs,
      __n,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> __response,
  ) {
    return _rpmatch(
      __response,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __optionp,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __tokens,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __valuep,
  ) {
    return _getsubopt(
      __optionp,
      __tokens,
      __valuep,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> __loadavg,
    int __nelem,
  ) {
    return _getloadavg(
      __loadavg,
      __nelem,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memcpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memmove(
      __dest,
      __src,
      __n,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __c,
    int __n,
  ) {
    return _memccpy(
      __dest,
      __src,
      __c,
      __n,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memset(
      __s,
      __c,
      __n,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _memcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memchr(
      __s,
      __c,
      __n,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcpy(
      __dest,
      __src,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcat(
      __dest,
      __src,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncat(
      __dest,
      __src,
      __n,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcmp(
      __s1,
      __s2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcoll(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcoll(
      __s1,
      __s2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strxfrm(
      __dest,
      __src,
      __n,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcoll_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    locale_t __l,
  ) {
    return _strcoll_l(
      __s1,
      __s2,
      __l,
    );
  }

  late final _strcoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              locale_t)>>('strcoll_l');
  late final _strcoll_l = _strcoll_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, locale_t)>();

  int strxfrm_l(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
    locale_t __l,
  ) {
    return _strxfrm_l(
      __dest,
      __src,
      __n,
      __l,
    );
  }

  late final _strxfrm_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, locale_t)>>('strxfrm_l');
  late final _strxfrm_l = _strxfrm_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, locale_t)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strdup(
      __s,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strndup(
    ffi.Pointer<ffi.Char> __string,
    int __n,
  ) {
    return _strndup(
      __string,
      __n,
    );
  }

  late final _strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strndup');
  late final _strndup = _strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strchr(
      __s,
      __c,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strrchr(
      __s,
      __c,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strcspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __reject,
  ) {
    return _strcspn(
      __s,
      __reject,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __accept,
  ) {
    return _strspn(
      __s,
      __accept,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __accept,
  ) {
    return _strpbrk(
      __s,
      __accept,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> __haystack,
    ffi.Pointer<ffi.Char> __needle,
  ) {
    return _strstr(
      __haystack,
      __needle,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strtok(
      __s,
      __delim,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok_r(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __delim,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __save_ptr,
  ) {
    return _strtok_r(
      __s,
      __delim,
      __save_ptr,
    );
  }

  late final _strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_r');
  late final _strtok_r = _strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strlen(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strlen(
      __s,
    );
  }

  late final _strlenPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>)>>(
      'strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int strnlen(
    ffi.Pointer<ffi.Char> __string,
    int __maxlen,
  ) {
    return _strnlen(
      __string,
      __maxlen,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strerror(
    int __errnum,
  ) {
    return _strerror(
      __errnum,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int strerror_r(
    int __errnum,
    ffi.Pointer<ffi.Char> __buf,
    int __buflen,
  ) {
    return _strerror_r(
      __errnum,
      __buf,
      __buflen,
    );
  }

  late final _strerror_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strerror_r');
  late final _strerror_r = _strerror_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strerror_l(
    int __errnum,
    locale_t __l,
  ) {
    return _strerror_l(
      __errnum,
      __l,
    );
  }

  late final _strerror_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Int, locale_t)>>('strerror_l');
  late final _strerror_l = _strerror_lPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, locale_t)>();

  int bcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _bcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Size)>>('bcmp');
  late final _bcmp = _bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bcopy(
    ffi.Pointer<ffi.Void> __src,
    ffi.Pointer<ffi.Void> __dest,
    int __n,
  ) {
    return _bcopy(
      __src,
      __dest,
      __n,
    );
  }

  late final _bcopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('bcopy');
  late final _bcopy = _bcopyPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bzero(
    ffi.Pointer<ffi.Void> __s,
    int __n,
  ) {
    return _bzero(
      __s,
      __n,
    );
  }

  late final _bzeroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('bzero');
  late final _bzero =
      _bzeroPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> index(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _index(
      __s,
      __c,
    );
  }

  late final _indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('index');
  late final _index = _indexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> rindex(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _rindex(
      __s,
      __c,
    );
  }

  late final _rindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('rindex');
  late final _rindex = _rindexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int ffs(
    int __i,
  ) {
    return _ffs(
      __i,
    );
  }

  late final _ffsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('ffs');
  late final _ffs = _ffsPtr.asFunction<int Function(int)>();

  int ffsl(
    int __l,
  ) {
    return _ffsl(
      __l,
    );
  }

  late final _ffslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('ffsl');
  late final _ffsl = _ffslPtr.asFunction<int Function(int)>();

  int ffsll(
    int __ll,
  ) {
    return _ffsll(
      __ll,
    );
  }

  late final _ffsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('ffsll');
  late final _ffsll = _ffsllPtr.asFunction<int Function(int)>();

  int strcasecmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcasecmp(
      __s1,
      __s2,
    );
  }

  late final _strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasecmp');
  late final _strcasecmp = _strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncasecmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncasecmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncasecmp');
  late final _strncasecmp = _strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcasecmp_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    locale_t __loc,
  ) {
    return _strcasecmp_l(
      __s1,
      __s2,
      __loc,
    );
  }

  late final _strcasecmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              locale_t)>>('strcasecmp_l');
  late final _strcasecmp_l = _strcasecmp_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, locale_t)>();

  int strncasecmp_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
    locale_t __loc,
  ) {
    return _strncasecmp_l(
      __s1,
      __s2,
      __n,
      __loc,
    );
  }

  late final _strncasecmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, locale_t)>>('strncasecmp_l');
  late final _strncasecmp_l = _strncasecmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, locale_t)>();

  void explicit_bzero(
    ffi.Pointer<ffi.Void> __s,
    int __n,
  ) {
    return _explicit_bzero(
      __s,
      __n,
    );
  }

  late final _explicit_bzeroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('explicit_bzero');
  late final _explicit_bzero = _explicit_bzeroPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> strsep(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __stringp,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strsep(
      __stringp,
      __delim,
    );
  }

  late final _strsepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('strsep');
  late final _strsep = _strsepPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strsignal(
    int __sig,
  ) {
    return _strsignal(
      __sig,
    );
  }

  late final _strsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strsignal');
  late final _strsignal =
      _strsignalPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> stpcpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _stpcpy(
      __dest,
      __src,
    );
  }

  late final _stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stpcpy');
  late final _stpcpy = _stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> stpncpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _stpncpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('stpncpy');
  late final _stpncpy = _stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  late final ffi.Pointer<ffi.Pointer<FILE>> _stdin =
      _lookup<ffi.Pointer<FILE>>('stdin');

  ffi.Pointer<FILE> get stdin => _stdin.value;

  set stdin(ffi.Pointer<FILE> value) => _stdin.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stdout =
      _lookup<ffi.Pointer<FILE>>('stdout');

  ffi.Pointer<FILE> get stdout => _stdout.value;

  set stdout(ffi.Pointer<FILE> value) => _stdout.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stderr =
      _lookup<ffi.Pointer<FILE>>('stderr');

  ffi.Pointer<FILE> get stderr => _stderr.value;

  set stderr(ffi.Pointer<FILE> value) => _stderr.value = value;

  int remove(
    ffi.Pointer<ffi.Char> __filename,
  ) {
    return _remove(
      __filename,
    );
  }

  late final _removePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'remove');
  late final _remove =
      _removePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rename(
    ffi.Pointer<ffi.Char> __old,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _rename(
      __old,
      __new,
    );
  }

  late final _renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rename');
  late final _rename = _renamePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int renameat(
    int __oldfd,
    ffi.Pointer<ffi.Char> __old,
    int __newfd,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _renameat(
      __oldfd,
      __old,
      __newfd,
      __new,
    );
  }

  late final _renameatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('renameat');
  late final _renameat = _renameatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int fclose(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fclose(
      __stream,
    );
  }

  late final _fclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fclose');
  late final _fclose = _fclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function()>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<ffi.Pointer<FILE> Function()>();

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _tmpnam(
      arg0,
    );
  }

  late final _tmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam');
  late final _tmpnam = _tmpnamPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> tmpnam_r(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _tmpnam_r(
      __s,
    );
  }

  late final _tmpnam_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam_r');
  late final _tmpnam_r = _tmpnam_rPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> __dir,
    ffi.Pointer<ffi.Char> __pfx,
  ) {
    return _tempnam(
      __dir,
      __pfx,
    );
  }

  late final _tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('tempnam');
  late final _tempnam = _tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fflush(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fflush(
      __stream,
    );
  }

  late final _fflushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush');
  late final _fflush = _fflushPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fflush_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fflush_unlocked(
      __stream,
    );
  }

  late final _fflush_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush_unlocked');
  late final _fflush_unlocked =
      _fflush_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fopen(
      __filename,
      __modes,
    );
  }

  late final _fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen');
  late final _fopen = _fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __modes,
    ffi.Pointer<FILE> __stream,
  ) {
    return _freopen(
      __filename,
      __modes,
      __stream,
    );
  }

  late final _freopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('freopen');
  late final _freopen = _freopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fdopen(
    int __fd,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fdopen(
      __fd,
      __modes,
    );
  }

  late final _fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('fdopen');
  late final _fdopen = _fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> fmemopen(
    ffi.Pointer<ffi.Void> __s,
    int __len,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fmemopen(
      __s,
      __len,
      __modes,
    );
  }

  late final _fmemopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('fmemopen');
  late final _fmemopen = _fmemopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> open_memstream(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __bufloc,
    ffi.Pointer<ffi.Size> __sizeloc,
  ) {
    return _open_memstream(
      __bufloc,
      __sizeloc,
    );
  }

  late final _open_memstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('open_memstream');
  late final _open_memstream = _open_memstreamPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>)>();

  void setbuf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _setbuf(
      __stream,
      __buf,
    );
  }

  late final _setbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('setbuf');
  late final _setbuf = _setbufPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int setvbuf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
    int __modes,
    int __n,
  ) {
    return _setvbuf(
      __stream,
      __buf,
      __modes,
      __n,
    );
  }

  late final _setvbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Size)>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int, int)>();

  void setbuffer(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
    int __size,
  ) {
    return _setbuffer(
      __stream,
      __buf,
      __size,
    );
  }

  late final _setbufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('setbuffer');
  late final _setbuffer = _setbufferPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  void setlinebuf(
    ffi.Pointer<FILE> __stream,
  ) {
    return _setlinebuf(
      __stream,
    );
  }

  late final _setlinebufPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'setlinebuf');
  late final _setlinebuf =
      _setlinebufPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fprintf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fprintf(
      __stream,
      __format,
    );
  }

  late final _fprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fprintf');
  late final _fprintf = _fprintfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int printf(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _printf(
      __format,
    );
  }

  late final _printfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'printf');
  late final _printf =
      _printfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sprintf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sprintf(
      __s,
      __format,
    );
  }

  late final _sprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sprintf');
  late final _sprintf = _sprintfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int vfprintf(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vfprintf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vfprintf');
  late final _vfprintf = _vfprintfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vprintf(
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vprintf(
      __format,
      __arg,
    );
  }

  late final _vprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vprintf');
  late final _vprintf = _vprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int vsprintf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsprintf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vsprintf');
  late final _vsprintf = _vsprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int snprintf(
    ffi.Pointer<ffi.Char> __s,
    int __maxlen,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _snprintf(
      __s,
      __maxlen,
      __format,
    );
  }

  late final _snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('snprintf');
  late final _snprintf = _snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int vsnprintf(
    ffi.Pointer<ffi.Char> __s,
    int __maxlen,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsnprintf(
      __s,
      __maxlen,
      __format,
      __arg,
    );
  }

  late final _vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vsnprintf');
  late final _vsnprintf = _vsnprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vdprintf(
    int __fd,
    ffi.Pointer<ffi.Char> __fmt,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vdprintf(
      __fd,
      __fmt,
      __arg,
    );
  }

  late final _vdprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vdprintf');
  late final _vdprintf = _vdprintfPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int dprintf(
    int __fd,
    ffi.Pointer<ffi.Char> __fmt,
  ) {
    return _dprintf(
      __fd,
      __fmt,
    );
  }

  late final _dprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'dprintf');
  late final _dprintf =
      _dprintfPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  int fscanf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fscanf(
      __stream,
      __format,
    );
  }

  late final _fscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf = _fscanfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int scanf(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _scanf(
      __format,
    );
  }

  late final _scanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf =
      _scanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sscanf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sscanf(
      __s,
      __format,
    );
  }

  late final _sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf = _sscanfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int vfscanf(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vfscanf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vfscanf');
  late final _vfscanf = _vfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vscanf(
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vscanf(
      __format,
      __arg,
    );
  }

  late final _vscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vscanf');
  late final _vscanf = _vscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int vsscanf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsscanf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vsscanf');
  late final _vsscanf = _vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int fgetc(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgetc(
      __stream,
    );
  }

  late final _fgetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getc(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getc(
      __stream,
    );
  }

  late final _getcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getc');
  late final _getc = _getcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar');
  late final _getchar = _getcharPtr.asFunction<int Function()>();

  int getc_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getc_unlocked(
      __stream,
    );
  }

  late final _getc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'getc_unlocked');
  late final _getc_unlocked =
      _getc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar_unlocked() {
    return _getchar_unlocked();
  }

  late final _getchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar_unlocked');
  late final _getchar_unlocked =
      _getchar_unlockedPtr.asFunction<int Function()>();

  int fgetc_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgetc_unlocked(
      __stream,
    );
  }

  late final _fgetc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fgetc_unlocked');
  late final _fgetc_unlocked =
      _fgetc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fputc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputc(
      __c,
      __stream,
    );
  }

  late final _fputcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc');
  late final _fputc =
      _fputcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putc(
      __c,
      __stream,
    );
  }

  late final _putcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc');
  late final _putc =
      _putcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar(
    int __c,
  ) {
    return _putchar(
      __c,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('putchar');
  late final _putchar = _putcharPtr.asFunction<int Function(int)>();

  int fputc_unlocked(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputc_unlocked(
      __c,
      __stream,
    );
  }

  late final _fputc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc_unlocked');
  late final _fputc_unlocked =
      _fputc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putc_unlocked(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putc_unlocked(
      __c,
      __stream,
    );
  }

  late final _putc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc_unlocked');
  late final _putc_unlocked =
      _putc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar_unlocked(
    int __c,
  ) {
    return _putchar_unlocked(
      __c,
    );
  }

  late final _putchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'putchar_unlocked');
  late final _putchar_unlocked =
      _putchar_unlockedPtr.asFunction<int Function(int)>();

  int getw(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getw(
      __stream,
    );
  }

  late final _getwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getw');
  late final _getw = _getwPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int putw(
    int __w,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putw(
      __w,
      __stream,
    );
  }

  late final _putwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putw');
  late final _putw =
      _putwPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> __s,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgets(
      __s,
      __n,
      __stream,
    );
  }

  late final _fgetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<FILE>)>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<FILE>)>();

  int getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Size> __n,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getdelim(
      __lineptr,
      __n,
      __delimiter,
      __stream,
    );
  }

  late final _getdelimPtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Int, ffi.Pointer<FILE>)>>('getdelim');
  late final _getdelim = _getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          int, ffi.Pointer<FILE>)>();

  int getline(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Size> __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getline(
      __lineptr,
      __n,
      __stream,
    );
  }

  late final _getlinePtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Pointer<FILE>)>>('getline');
  late final _getline = _getlinePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<FILE>)>();

  int fputs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputs(
      __s,
      __stream,
    );
  }

  late final _fputsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('fputs');
  late final _fputs = _fputsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int puts(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _puts(
      __s,
    );
  }

  late final _putsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'puts');
  late final _puts = _putsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int ungetc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _ungetc(
      __c,
      __stream,
    );
  }

  late final _ungetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'ungetc');
  late final _ungetc =
      _ungetcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int fread(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread');
  late final _fread = _freadPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fwrite(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __s,
  ) {
    return _fwrite(
      __ptr,
      __size,
      __n,
      __s,
    );
  }

  late final _fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fread_unlocked(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread_unlocked(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _fread_unlockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread_unlocked');
  late final _fread_unlocked = _fread_unlockedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fwrite_unlocked(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fwrite_unlocked(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _fwrite_unlockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite_unlocked');
  late final _fwrite_unlocked = _fwrite_unlockedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fseek(
    ffi.Pointer<FILE> __stream,
    int __off,
    int __whence,
  ) {
    return _fseek(
      __stream,
      __off,
      __whence,
    );
  }

  late final _fseekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('fseek');
  late final _fseek =
      _fseekPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftell(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftell(
      __stream,
    );
  }

  late final _ftellPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          'ftell');
  late final _ftell = _ftellPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void rewind(
    ffi.Pointer<FILE> __stream,
  ) {
    return _rewind(
      __stream,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'rewind');
  late final _rewind =
      _rewindPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fseeko(
    ffi.Pointer<FILE> __stream,
    int __off,
    int __whence,
  ) {
    return _fseeko(
      __stream,
      __off,
      __whence,
    );
  }

  late final _fseekoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, __off_t, ffi.Int)>>('fseeko');
  late final _fseeko =
      _fseekoPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftello(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftello(
      __stream,
    );
  }

  late final _ftelloPtr =
      _lookup<ffi.NativeFunction<__off_t Function(ffi.Pointer<FILE>)>>(
          'ftello');
  late final _ftello = _ftelloPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetpos(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<fpos_t> __pos,
  ) {
    return _fgetpos(
      __stream,
      __pos,
    );
  }

  late final _fgetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fgetpos');
  late final _fgetpos = _fgetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  int fsetpos(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<fpos_t> __pos,
  ) {
    return _fsetpos(
      __stream,
      __pos,
    );
  }

  late final _fsetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fsetpos');
  late final _fsetpos = _fsetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  void clearerr(
    ffi.Pointer<FILE> __stream,
  ) {
    return _clearerr(
      __stream,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr');
  late final _clearerr =
      _clearerrPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int feof(
    ffi.Pointer<FILE> __stream,
  ) {
    return _feof(
      __stream,
    );
  }

  late final _feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('feof');
  late final _feof = _feofPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ferror(
      __stream,
    );
  }

  late final _ferrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror');
  late final _ferror = _ferrorPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void clearerr_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _clearerr_unlocked(
      __stream,
    );
  }

  late final _clearerr_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr_unlocked');
  late final _clearerr_unlocked =
      _clearerr_unlockedPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int feof_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _feof_unlocked(
      __stream,
    );
  }

  late final _feof_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'feof_unlocked');
  late final _feof_unlocked =
      _feof_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ferror_unlocked(
      __stream,
    );
  }

  late final _ferror_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror_unlocked');
  late final _ferror_unlocked =
      _ferror_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void perror(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _perror(
      __s,
    );
  }

  late final _perrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'perror');
  late final _perror =
      _perrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int fileno(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fileno(
      __stream,
    );
  }

  late final _filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno');
  late final _fileno = _filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fileno_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fileno_unlocked(
      __stream,
    );
  }

  late final _fileno_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno_unlocked');
  late final _fileno_unlocked =
      _fileno_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int pclose(
    ffi.Pointer<FILE> __stream,
  ) {
    return _pclose(
      __stream,
    );
  }

  late final _pclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'pclose');
  late final _pclose = _pclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> popen(
    ffi.Pointer<ffi.Char> __command,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _popen(
      __command,
      __modes,
    );
  }

  late final _popenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('popen');
  late final _popen = _popenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctermid(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _ctermid(
      __s,
    );
  }

  late final _ctermidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid');
  late final _ctermid = _ctermidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void flockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _flockfile(
      __stream,
    );
  }

  late final _flockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'flockfile');
  late final _flockfile =
      _flockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int ftrylockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftrylockfile(
      __stream,
    );
  }

  late final _ftrylockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ftrylockfile');
  late final _ftrylockfile =
      _ftrylockfilePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void funlockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _funlockfile(
      __stream,
    );
  }

  late final _funlockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'funlockfile');
  late final _funlockfile =
      _funlockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  /// The entry point in a plugin.
  ///
  /// \param factory a location to hold the factory result
  /// \param index index to keep track of the enumeration
  /// \return 1 on success
  /// 0 when no more items are available
  /// < 0 errno type error
  int spa_handle_factory_enum(
    ffi.Pointer<ffi.Pointer<spa_handle_factory>> factory1,
    ffi.Pointer<ffi.Uint32> index,
  ) {
    return _spa_handle_factory_enum(
      factory1,
      index,
    );
  }

  late final _spa_handle_factory_enumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<spa_handle_factory>>,
              ffi.Pointer<ffi.Uint32>)>>('spa_handle_factory_enum');
  late final _spa_handle_factory_enum = _spa_handle_factory_enumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<spa_handle_factory>>,
          ffi.Pointer<ffi.Uint32>)>();

  ffi.Pointer<pw_properties> pw_properties_new(
    ffi.Pointer<ffi.Char> key,
  ) {
    return _pw_properties_new(
      key,
    );
  }

  late final _pw_properties_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<ffi.Char>)>>('pw_properties_new');
  late final _pw_properties_new = _pw_properties_newPtr
      .asFunction<ffi.Pointer<pw_properties> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<pw_properties> pw_properties_new_dict(
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_properties_new_dict(
      dict,
    );
  }

  late final _pw_properties_new_dictPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<spa_dict>)>>('pw_properties_new_dict');
  late final _pw_properties_new_dict = _pw_properties_new_dictPtr
      .asFunction<ffi.Pointer<pw_properties> Function(ffi.Pointer<spa_dict>)>();

  ffi.Pointer<pw_properties> pw_properties_new_string(
    ffi.Pointer<ffi.Char> args,
  ) {
    return _pw_properties_new_string(
      args,
    );
  }

  late final _pw_properties_new_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<ffi.Char>)>>('pw_properties_new_string');
  late final _pw_properties_new_string = _pw_properties_new_stringPtr
      .asFunction<ffi.Pointer<pw_properties> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<pw_properties> pw_properties_copy(
    ffi.Pointer<pw_properties> properties,
  ) {
    return _pw_properties_copy(
      properties,
    );
  }

  late final _pw_properties_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<pw_properties>)>>('pw_properties_copy');
  late final _pw_properties_copy = _pw_properties_copyPtr.asFunction<
      ffi.Pointer<pw_properties> Function(ffi.Pointer<pw_properties>)>();

  int pw_properties_update_keys(
    ffi.Pointer<pw_properties> props,
    ffi.Pointer<spa_dict> dict,
    ffi.Pointer<ffi.Pointer<ffi.Char>> keys,
  ) {
    return _pw_properties_update_keys(
      props,
      dict,
      keys,
    );
  }

  late final _pw_properties_update_keysPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<pw_properties>,
                  ffi.Pointer<spa_dict>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'pw_properties_update_keys');
  late final _pw_properties_update_keys =
      _pw_properties_update_keysPtr.asFunction<
          int Function(ffi.Pointer<pw_properties>, ffi.Pointer<spa_dict>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int pw_properties_update_ignore(
    ffi.Pointer<pw_properties> props,
    ffi.Pointer<spa_dict> dict,
    ffi.Pointer<ffi.Pointer<ffi.Char>> ignore,
  ) {
    return _pw_properties_update_ignore(
      props,
      dict,
      ignore,
    );
  }

  late final _pw_properties_update_ignorePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<pw_properties>,
                  ffi.Pointer<spa_dict>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'pw_properties_update_ignore');
  late final _pw_properties_update_ignore =
      _pw_properties_update_ignorePtr.asFunction<
          int Function(ffi.Pointer<pw_properties>, ffi.Pointer<spa_dict>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Update props with all key/value pairs from dict
  int pw_properties_update(
    ffi.Pointer<pw_properties> props,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_properties_update(
      props,
      dict,
    );
  }

  late final _pw_properties_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>,
              ffi.Pointer<spa_dict>)>>('pw_properties_update');
  late final _pw_properties_update = _pw_properties_updatePtr.asFunction<
      int Function(ffi.Pointer<pw_properties>, ffi.Pointer<spa_dict>)>();

  /// Update props with all key/value pairs from str
  int pw_properties_update_string(
    ffi.Pointer<pw_properties> props,
    ffi.Pointer<ffi.Char> str,
    int size,
  ) {
    return _pw_properties_update_string(
      props,
      str,
      size,
    );
  }

  late final _pw_properties_update_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('pw_properties_update_string');
  late final _pw_properties_update_string =
      _pw_properties_update_stringPtr.asFunction<
          int Function(
              ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>, int)>();

  int pw_properties_add(
    ffi.Pointer<pw_properties> oldprops,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_properties_add(
      oldprops,
      dict,
    );
  }

  late final _pw_properties_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>,
              ffi.Pointer<spa_dict>)>>('pw_properties_add');
  late final _pw_properties_add = _pw_properties_addPtr.asFunction<
      int Function(ffi.Pointer<pw_properties>, ffi.Pointer<spa_dict>)>();

  int pw_properties_add_keys(
    ffi.Pointer<pw_properties> oldprops,
    ffi.Pointer<spa_dict> dict,
    ffi.Pointer<ffi.Pointer<ffi.Char>> keys,
  ) {
    return _pw_properties_add_keys(
      oldprops,
      dict,
      keys,
    );
  }

  late final _pw_properties_add_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<spa_dict>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('pw_properties_add_keys');
  late final _pw_properties_add_keys = _pw_properties_add_keysPtr.asFunction<
      int Function(ffi.Pointer<pw_properties>, ffi.Pointer<spa_dict>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  void pw_properties_clear(
    ffi.Pointer<pw_properties> properties,
  ) {
    return _pw_properties_clear(
      properties,
    );
  }

  late final _pw_properties_clearPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_properties>)>>(
      'pw_properties_clear');
  late final _pw_properties_clear = _pw_properties_clearPtr
      .asFunction<void Function(ffi.Pointer<pw_properties>)>();

  void pw_properties_free(
    ffi.Pointer<pw_properties> properties,
  ) {
    return _pw_properties_free(
      properties,
    );
  }

  late final _pw_properties_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_properties>)>>(
      'pw_properties_free');
  late final _pw_properties_free = _pw_properties_freePtr
      .asFunction<void Function(ffi.Pointer<pw_properties>)>();

  int pw_properties_set(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pw_properties_set(
      properties,
      key,
      value,
    );
  }

  late final _pw_properties_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pw_properties_set');
  late final _pw_properties_set = _pw_properties_setPtr.asFunction<
      int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int pw_properties_setf(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _pw_properties_setf(
      properties,
      key,
      format,
    );
  }

  late final _pw_properties_setfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pw_properties_setf');
  late final _pw_properties_setf = _pw_properties_setfPtr.asFunction<
      int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int pw_properties_setva(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _pw_properties_setva(
      properties,
      key,
      format,
      args,
    );
  }

  late final _pw_properties_setvaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_properties>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('pw_properties_setva');
  late final _pw_properties_setva = _pw_properties_setvaPtr.asFunction<
      int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  ffi.Pointer<ffi.Char> pw_properties_get(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
  ) {
    return _pw_properties_get(
      properties,
      key,
    );
  }

  late final _pw_properties_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_properties>,
              ffi.Pointer<ffi.Char>)>>('pw_properties_get');
  late final _pw_properties_get = _pw_properties_getPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>)>();

  int pw_properties_fetch_uint32(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Uint32> value,
  ) {
    return _pw_properties_fetch_uint32(
      properties,
      key,
      value,
    );
  }

  late final _pw_properties_fetch_uint32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint32>)>>('pw_properties_fetch_uint32');
  late final _pw_properties_fetch_uint32 =
      _pw_properties_fetch_uint32Ptr.asFunction<
          int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint32>)>();

  int pw_properties_fetch_int32(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Int32> value,
  ) {
    return _pw_properties_fetch_int32(
      properties,
      key,
      value,
    );
  }

  late final _pw_properties_fetch_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int32>)>>('pw_properties_fetch_int32');
  late final _pw_properties_fetch_int32 =
      _pw_properties_fetch_int32Ptr.asFunction<
          int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int32>)>();

  int pw_properties_fetch_uint64(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Uint64> value,
  ) {
    return _pw_properties_fetch_uint64(
      properties,
      key,
      value,
    );
  }

  late final _pw_properties_fetch_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint64>)>>('pw_properties_fetch_uint64');
  late final _pw_properties_fetch_uint64 =
      _pw_properties_fetch_uint64Ptr.asFunction<
          int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint64>)>();

  int pw_properties_fetch_int64(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _pw_properties_fetch_int64(
      properties,
      key,
      value,
    );
  }

  late final _pw_properties_fetch_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int64>)>>('pw_properties_fetch_int64');
  late final _pw_properties_fetch_int64 =
      _pw_properties_fetch_int64Ptr.asFunction<
          int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int64>)>();

  int pw_properties_fetch_bool(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _pw_properties_fetch_bool(
      properties,
      key,
      value,
    );
  }

  late final _pw_properties_fetch_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Bool>)>>('pw_properties_fetch_bool');
  late final _pw_properties_fetch_bool =
      _pw_properties_fetch_boolPtr.asFunction<
          int Function(ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Bool>)>();

  ffi.Pointer<ffi.Char> pw_properties_iterate(
    ffi.Pointer<pw_properties> properties,
    ffi.Pointer<ffi.Pointer<ffi.Void>> state,
  ) {
    return _pw_properties_iterate(
      properties,
      state,
    );
  }

  late final _pw_properties_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_properties>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('pw_properties_iterate');
  late final _pw_properties_iterate = _pw_properties_iteratePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<pw_properties>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  int pw_properties_serialize_dict(
    ffi.Pointer<FILE> f,
    ffi.Pointer<spa_dict> dict,
    int flags,
  ) {
    return _pw_properties_serialize_dict(
      f,
      dict,
      flags,
    );
  }

  late final _pw_properties_serialize_dictPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<spa_dict>,
              ffi.Uint32)>>('pw_properties_serialize_dict');
  late final _pw_properties_serialize_dict =
      _pw_properties_serialize_dictPtr.asFunction<
          int Function(ffi.Pointer<FILE>, ffi.Pointer<spa_dict>, int)>();

  /// Update an existing \ref pw_core_info with \a update with reset
  ffi.Pointer<pw_core_info> pw_core_info_update(
    ffi.Pointer<pw_core_info> info,
    ffi.Pointer<pw_core_info> update,
  ) {
    return _pw_core_info_update(
      info,
      update,
    );
  }

  late final _pw_core_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core_info> Function(ffi.Pointer<pw_core_info>,
              ffi.Pointer<pw_core_info>)>>('pw_core_info_update');
  late final _pw_core_info_update = _pw_core_info_updatePtr.asFunction<
      ffi.Pointer<pw_core_info> Function(
          ffi.Pointer<pw_core_info>, ffi.Pointer<pw_core_info>)>();

  /// Update an existing \ref pw_core_info with \a update
  ffi.Pointer<pw_core_info> pw_core_info_merge(
    ffi.Pointer<pw_core_info> info,
    ffi.Pointer<pw_core_info> update,
    bool reset,
  ) {
    return _pw_core_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_core_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core_info> Function(ffi.Pointer<pw_core_info>,
              ffi.Pointer<pw_core_info>, ffi.Bool)>>('pw_core_info_merge');
  late final _pw_core_info_merge = _pw_core_info_mergePtr.asFunction<
      ffi.Pointer<pw_core_info> Function(
          ffi.Pointer<pw_core_info>, ffi.Pointer<pw_core_info>, bool)>();

  /// Free a \ref pw_core_info
  void pw_core_info_free(
    ffi.Pointer<pw_core_info> info,
  ) {
    return _pw_core_info_free(
      info,
    );
  }

  late final _pw_core_info_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_core_info>)>>(
          'pw_core_info_free');
  late final _pw_core_info_free = _pw_core_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_core_info>)>();

  /// Connect to a PipeWire instance
  ///
  /// \param context a \ref pw_context
  /// \param properties optional properties, ownership of the properties is
  /// taken.
  /// \param user_data_size extra user data size
  ///
  /// \return a \ref pw_core on success or NULL with errno set on error. The core
  /// will have an id of \ref PW_ID_CORE (0)
  ffi.Pointer<pw_core> pw_context_connect(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<pw_properties> properties,
    int user_data_size,
  ) {
    return _pw_context_connect(
      context,
      properties,
      user_data_size,
    );
  }

  late final _pw_context_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<pw_properties>, ffi.Size)>>('pw_context_connect');
  late final _pw_context_connect = _pw_context_connectPtr.asFunction<
      ffi.Pointer<pw_core> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<pw_properties>, int)>();

  /// Connect to a PipeWire instance on the given socket
  ///
  /// \param context a \ref pw_context
  /// \param fd the connected socket to use, the socket will be closed
  /// automatically on disconnect or error.
  /// \param properties optional properties, ownership of the properties is
  /// taken.
  /// \param user_data_size extra user data size
  ///
  /// \return a \ref pw_core on success or NULL with errno set on error
  ffi.Pointer<pw_core> pw_context_connect_fd(
    ffi.Pointer<pw_context> context,
    int fd,
    ffi.Pointer<pw_properties> properties,
    int user_data_size,
  ) {
    return _pw_context_connect_fd(
      context,
      fd,
      properties,
      user_data_size,
    );
  }

  late final _pw_context_connect_fdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(ffi.Pointer<pw_context>, ffi.Int,
              ffi.Pointer<pw_properties>, ffi.Size)>>('pw_context_connect_fd');
  late final _pw_context_connect_fd = _pw_context_connect_fdPtr.asFunction<
      ffi.Pointer<pw_core> Function(
          ffi.Pointer<pw_context>, int, ffi.Pointer<pw_properties>, int)>();

  /// Connect to a given PipeWire instance
  ///
  /// \param context a \ref pw_context to connect to
  /// \param properties optional properties, ownership of the properties is
  /// taken.
  /// \param user_data_size extra user data size
  ///
  /// \return a \ref pw_core on success or NULL with errno set on error
  ffi.Pointer<pw_core> pw_context_connect_self(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<pw_properties> properties,
    int user_data_size,
  ) {
    return _pw_context_connect_self(
      context,
      properties,
      user_data_size,
    );
  }

  late final _pw_context_connect_selfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<pw_properties>,
              ffi.Size)>>('pw_context_connect_self');
  late final _pw_context_connect_self = _pw_context_connect_selfPtr.asFunction<
      ffi.Pointer<pw_core> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<pw_properties>, int)>();

  /// Steal the fd of the core connection or < 0 on error. The core
  /// will be disconnected after this call.
  int pw_core_steal_fd(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_steal_fd(
      core,
    );
  }

  late final _pw_core_steal_fdPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_core>)>>(
          'pw_core_steal_fd');
  late final _pw_core_steal_fd =
      _pw_core_steal_fdPtr.asFunction<int Function(ffi.Pointer<pw_core>)>();

  /// Pause or resume the core. When the core is paused, no new events
  /// will be dispatched until the core is resumed again.
  int pw_core_set_paused(
    ffi.Pointer<pw_core> core,
    bool paused,
  ) {
    return _pw_core_set_paused(
      core,
      paused,
    );
  }

  late final _pw_core_set_pausedPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_core>, ffi.Bool)>>(
      'pw_core_set_paused');
  late final _pw_core_set_paused = _pw_core_set_pausedPtr
      .asFunction<int Function(ffi.Pointer<pw_core>, bool)>();

  /// disconnect and destroy a core
  int pw_core_disconnect(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_disconnect(
      core,
    );
  }

  late final _pw_core_disconnectPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_core>)>>(
          'pw_core_disconnect');
  late final _pw_core_disconnect =
      _pw_core_disconnectPtr.asFunction<int Function(ffi.Pointer<pw_core>)>();

  /// Get the user_data. It is of the size specified when this object was
  /// constructed
  ffi.Pointer<ffi.Void> pw_core_get_user_data(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_user_data(
      core,
    );
  }

  late final _pw_core_get_user_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_user_data');
  late final _pw_core_get_user_data = _pw_core_get_user_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_core>)>();

  /// Get the client proxy of the connected core. This will have the id
  /// of PW_ID_CLIENT (1)
  ffi.Pointer<pw_client> pw_core_get_client(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_client(
      core,
    );
  }

  late final _pw_core_get_clientPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_client> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_client');
  late final _pw_core_get_client = _pw_core_get_clientPtr
      .asFunction<ffi.Pointer<pw_client> Function(ffi.Pointer<pw_core>)>();

  /// Get the context object used to created this core
  ffi.Pointer<pw_context> pw_core_get_context(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_context(
      core,
    );
  }

  late final _pw_core_get_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_context> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_context');
  late final _pw_core_get_context = _pw_core_get_contextPtr
      .asFunction<ffi.Pointer<pw_context> Function(ffi.Pointer<pw_core>)>();

  /// Get properties from the core
  ffi.Pointer<pw_properties> pw_core_get_properties(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_properties(
      core,
    );
  }

  late final _pw_core_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_properties');
  late final _pw_core_get_properties = _pw_core_get_propertiesPtr
      .asFunction<ffi.Pointer<pw_properties> Function(ffi.Pointer<pw_core>)>();

  /// Update the core properties. This updates the properties
  /// of the associated client.
  /// \return the number of properties that were updated
  int pw_core_update_properties(
    ffi.Pointer<pw_core> core,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_core_update_properties(
      core,
      dict,
    );
  }

  late final _pw_core_update_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_core>,
              ffi.Pointer<spa_dict>)>>('pw_core_update_properties');
  late final _pw_core_update_properties = _pw_core_update_propertiesPtr
      .asFunction<int Function(ffi.Pointer<pw_core>, ffi.Pointer<spa_dict>)>();

  /// Get the core mempool object
  ffi.Pointer<pw_mempool> pw_core_get_mempool(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_mempool(
      core,
    );
  }

  late final _pw_core_get_mempoolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_mempool> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_mempool');
  late final _pw_core_get_mempool = _pw_core_get_mempoolPtr
      .asFunction<ffi.Pointer<pw_mempool> Function(ffi.Pointer<pw_core>)>();

  /// Get the proxy with the given id
  ffi.Pointer<pw_proxy> pw_core_find_proxy(
    ffi.Pointer<pw_core> core,
    int id,
  ) {
    return _pw_core_find_proxy(
      core,
      id,
    );
  }

  late final _pw_core_find_proxyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_proxy> Function(
              ffi.Pointer<pw_core>, ffi.Uint32)>>('pw_core_find_proxy');
  late final _pw_core_find_proxy = _pw_core_find_proxyPtr
      .asFunction<ffi.Pointer<pw_proxy> Function(ffi.Pointer<pw_core>, int)>();

  /// Export an object into the PipeWire instance associated with core
  ffi.Pointer<pw_proxy> pw_core_export(
    ffi.Pointer<pw_core> core,
    ffi.Pointer<ffi.Char> type,
    ffi.Pointer<spa_dict> props,
    ffi.Pointer<ffi.Void> object,
    int user_data_size,
  ) {
    return _pw_core_export(
      core,
      type,
      props,
      object,
      user_data_size,
    );
  }

  late final _pw_core_exportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_proxy> Function(
              ffi.Pointer<pw_core>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<ffi.Void>,
              ffi.Size)>>('pw_core_export');
  late final _pw_core_export = _pw_core_exportPtr.asFunction<
      ffi.Pointer<pw_proxy> Function(
          ffi.Pointer<pw_core>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<spa_dict>,
          ffi.Pointer<ffi.Void>,
          int)>();

  int clock() {
    return _clock();
  }

  late final _clockPtr =
      _lookup<ffi.NativeFunction<clock_t Function()>>('clock');
  late final _clock = _clockPtr.asFunction<int Function()>();

  int time(
    ffi.Pointer<time_t> __timer,
  ) {
    return _time(
      __timer,
    );
  }

  late final _timePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<time_t>)>>('time');
  late final _time = _timePtr.asFunction<int Function(ffi.Pointer<time_t>)>();

  double difftime(
    int __time1,
    int __time0,
  ) {
    return _difftime(
      __time1,
      __time0,
    );
  }

  late final _difftimePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(time_t, time_t)>>(
          'difftime');
  late final _difftime = _difftimePtr.asFunction<double Function(int, int)>();

  int mktime(
    ffi.Pointer<tm> __tp,
  ) {
    return _mktime(
      __tp,
    );
  }

  late final _mktimePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('mktime');
  late final _mktime = _mktimePtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int strftime(
    ffi.Pointer<ffi.Char> __s,
    int __maxsize,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<tm> __tp,
  ) {
    return _strftime(
      __s,
      __maxsize,
      __format,
      __tp,
    );
  }

  late final _strftimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('strftime');
  late final _strftime = _strftimePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<tm>)>();

  int strftime_l(
    ffi.Pointer<ffi.Char> __s,
    int __maxsize,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<tm> __tp,
    locale_t __loc,
  ) {
    return _strftime_l(
      __s,
      __maxsize,
      __format,
      __tp,
      __loc,
    );
  }

  late final _strftime_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>, locale_t)>>('strftime_l');
  late final _strftime_l = _strftime_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<tm>, locale_t)>();

  ffi.Pointer<tm> gmtime(
    ffi.Pointer<time_t> __timer,
  ) {
    return _gmtime(
      __timer,
    );
  }

  late final _gmtimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>(
      'gmtime');
  late final _gmtime =
      _gmtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<tm> localtime(
    ffi.Pointer<time_t> __timer,
  ) {
    return _localtime(
      __timer,
    );
  }

  late final _localtimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>(
      'localtime');
  late final _localtime =
      _localtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<tm> gmtime_r(
    ffi.Pointer<time_t> __timer,
    ffi.Pointer<tm> __tp,
  ) {
    return _gmtime_r(
      __timer,
      __tp,
    );
  }

  late final _gmtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('gmtime_r');
  late final _gmtime_r = _gmtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  ffi.Pointer<tm> localtime_r(
    ffi.Pointer<time_t> __timer,
    ffi.Pointer<tm> __tp,
  ) {
    return _localtime_r(
      __timer,
      __tp,
    );
  }

  late final _localtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('localtime_r');
  late final _localtime_r = _localtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  ffi.Pointer<ffi.Char> asctime(
    ffi.Pointer<tm> __tp,
  ) {
    return _asctime(
      __tp,
    );
  }

  late final _asctimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>>(
      'asctime');
  late final _asctime =
      _asctimePtr.asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>();

  ffi.Pointer<ffi.Char> ctime(
    ffi.Pointer<time_t> __timer,
  ) {
    return _ctime(
      __timer,
    );
  }

  late final _ctimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>>('ctime');
  late final _ctime = _ctimePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<ffi.Char> asctime_r(
    ffi.Pointer<tm> __tp,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _asctime_r(
      __tp,
      __buf,
    );
  }

  late final _asctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>>('asctime_r');
  late final _asctime_r = _asctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctime_r(
    ffi.Pointer<time_t> __timer,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _ctime_r(
      __timer,
      __buf,
    );
  }

  late final _ctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>>('ctime_r');
  late final _ctime_r = _ctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) => _tzname.value = value;

  void tzset() {
    return _tzset();
  }

  late final _tzsetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tzset');
  late final _tzset = _tzsetPtr.asFunction<void Function()>();

  late final ffi.Pointer<ffi.Int> _daylight = _lookup<ffi.Int>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  late final ffi.Pointer<ffi.Long> _timezone = _lookup<ffi.Long>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  int timegm(
    ffi.Pointer<tm> __tp,
  ) {
    return _timegm(
      __tp,
    );
  }

  late final _timegmPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('timegm');
  late final _timegm = _timegmPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int timelocal(
    ffi.Pointer<tm> __tp,
  ) {
    return _timelocal(
      __tp,
    );
  }

  late final _timelocalPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>(
          'timelocal');
  late final _timelocal =
      _timelocalPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int dysize(
    int __year,
  ) {
    return _dysize(
      __year,
    );
  }

  late final _dysizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('dysize');
  late final _dysize = _dysizePtr.asFunction<int Function(int)>();

  int nanosleep(
    ffi.Pointer<timespec> __requested_time,
    ffi.Pointer<timespec> __remaining,
  ) {
    return _nanosleep(
      __requested_time,
      __remaining,
    );
  }

  late final _nanosleepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<timespec>, ffi.Pointer<timespec>)>>('nanosleep');
  late final _nanosleep = _nanosleepPtr
      .asFunction<int Function(ffi.Pointer<timespec>, ffi.Pointer<timespec>)>();

  int clock_getres(
    int __clock_id,
    ffi.Pointer<timespec> __res,
  ) {
    return _clock_getres(
      __clock_id,
      __res,
    );
  }

  late final _clock_getresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Pointer<timespec>)>>('clock_getres');
  late final _clock_getres =
      _clock_getresPtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_gettime(
    int __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_gettime(
      __clock_id,
      __tp,
    );
  }

  late final _clock_gettimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Pointer<timespec>)>>('clock_gettime');
  late final _clock_gettime =
      _clock_gettimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_settime(
    int __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_settime(
      __clock_id,
      __tp,
    );
  }

  late final _clock_settimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Pointer<timespec>)>>('clock_settime');
  late final _clock_settime =
      _clock_settimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_nanosleep(
    int __clock_id,
    int __flags,
    ffi.Pointer<timespec> __req,
    ffi.Pointer<timespec> __rem,
  ) {
    return _clock_nanosleep(
      __clock_id,
      __flags,
      __req,
      __rem,
    );
  }

  late final _clock_nanosleepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Int, ffi.Pointer<timespec>,
              ffi.Pointer<timespec>)>>('clock_nanosleep');
  late final _clock_nanosleep = _clock_nanosleepPtr.asFunction<
      int Function(int, int, ffi.Pointer<timespec>, ffi.Pointer<timespec>)>();

  int clock_getcpuclockid(
    int __pid,
    ffi.Pointer<clockid_t> __clock_id,
  ) {
    return _clock_getcpuclockid(
      __pid,
      __clock_id,
    );
  }

  late final _clock_getcpuclockidPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(pid_t, ffi.Pointer<clockid_t>)>>(
      'clock_getcpuclockid');
  late final _clock_getcpuclockid = _clock_getcpuclockidPtr
      .asFunction<int Function(int, ffi.Pointer<clockid_t>)>();

  int timer_create(
    int __clock_id,
    ffi.Pointer<sigevent> __evp,
    ffi.Pointer<timer_t> __timerid,
  ) {
    return _timer_create(
      __clock_id,
      __evp,
      __timerid,
    );
  }

  late final _timer_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Pointer<sigevent>,
              ffi.Pointer<timer_t>)>>('timer_create');
  late final _timer_create = _timer_createPtr.asFunction<
      int Function(int, ffi.Pointer<sigevent>, ffi.Pointer<timer_t>)>();

  int timer_delete(
    timer_t __timerid,
  ) {
    return _timer_delete(
      __timerid,
    );
  }

  late final _timer_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(timer_t)>>('timer_delete');
  late final _timer_delete =
      _timer_deletePtr.asFunction<int Function(timer_t)>();

  int timer_settime(
    timer_t __timerid,
    int __flags,
    ffi.Pointer<itimerspec> __value,
    ffi.Pointer<itimerspec> __ovalue,
  ) {
    return _timer_settime(
      __timerid,
      __flags,
      __value,
      __ovalue,
    );
  }

  late final _timer_settimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(timer_t, ffi.Int, ffi.Pointer<itimerspec>,
              ffi.Pointer<itimerspec>)>>('timer_settime');
  late final _timer_settime = _timer_settimePtr.asFunction<
      int Function(
          timer_t, int, ffi.Pointer<itimerspec>, ffi.Pointer<itimerspec>)>();

  int timer_gettime(
    timer_t __timerid,
    ffi.Pointer<itimerspec> __value,
  ) {
    return _timer_gettime(
      __timerid,
      __value,
    );
  }

  late final _timer_gettimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(timer_t, ffi.Pointer<itimerspec>)>>('timer_gettime');
  late final _timer_gettime = _timer_gettimePtr
      .asFunction<int Function(timer_t, ffi.Pointer<itimerspec>)>();

  int timer_getoverrun(
    timer_t __timerid,
  ) {
    return _timer_getoverrun(
      __timerid,
    );
  }

  late final _timer_getoverrunPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(timer_t)>>(
          'timer_getoverrun');
  late final _timer_getoverrun =
      _timer_getoverrunPtr.asFunction<int Function(timer_t)>();

  int timespec_get(
    ffi.Pointer<timespec> __ts,
    int __base,
  ) {
    return _timespec_get(
      __ts,
      __base,
    );
  }

  late final _timespec_getPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<timespec>, ffi.Int)>>(
      'timespec_get');
  late final _timespec_get =
      _timespec_getPtr.asFunction<int Function(ffi.Pointer<timespec>, int)>();

  ffi.Pointer<pw_loop> pw_loop_new(
    ffi.Pointer<spa_dict> props,
  ) {
    return _pw_loop_new(
      props,
    );
  }

  late final _pw_loop_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_loop> Function(ffi.Pointer<spa_dict>)>>('pw_loop_new');
  late final _pw_loop_new = _pw_loop_newPtr
      .asFunction<ffi.Pointer<pw_loop> Function(ffi.Pointer<spa_dict>)>();

  void pw_loop_destroy(
    ffi.Pointer<pw_loop> loop,
  ) {
    return _pw_loop_destroy(
      loop,
    );
  }

  late final _pw_loop_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_loop>)>>(
          'pw_loop_destroy');
  late final _pw_loop_destroy =
      _pw_loop_destroyPtr.asFunction<void Function(ffi.Pointer<pw_loop>)>();

  /// Make a new context object for a given main_loop. Ownership of the properties is taken
  ffi.Pointer<pw_context> pw_context_new(
    ffi.Pointer<pw_loop> main_loop,
    ffi.Pointer<pw_properties> props,
    int user_data_size,
  ) {
    return _pw_context_new(
      main_loop,
      props,
      user_data_size,
    );
  }

  late final _pw_context_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_context> Function(ffi.Pointer<pw_loop>,
              ffi.Pointer<pw_properties>, ffi.Size)>>('pw_context_new');
  late final _pw_context_new = _pw_context_newPtr.asFunction<
      ffi.Pointer<pw_context> Function(
          ffi.Pointer<pw_loop>, ffi.Pointer<pw_properties>, int)>();

  /// destroy a context object, all resources except the main_loop will be destroyed
  void pw_context_destroy(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_destroy(
      context,
    );
  }

  late final _pw_context_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_context>)>>(
          'pw_context_destroy');
  late final _pw_context_destroy = _pw_context_destroyPtr
      .asFunction<void Function(ffi.Pointer<pw_context>)>();

  /// Get the context user data
  ffi.Pointer<ffi.Void> pw_context_get_user_data(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_get_user_data(
      context,
    );
  }

  late final _pw_context_get_user_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<pw_context>)>>('pw_context_get_user_data');
  late final _pw_context_get_user_data = _pw_context_get_user_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_context>)>();

  /// Add a new event listener to a context
  void pw_context_add_listener(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_context_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_context_add_listener(
      context,
      listener,
      events,
      data,
    );
  }

  late final _pw_context_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_context_events>,
              ffi.Pointer<ffi.Void>)>>('pw_context_add_listener');
  late final _pw_context_add_listener = _pw_context_add_listenerPtr.asFunction<
      void Function(ffi.Pointer<pw_context>, ffi.Pointer<spa_hook>,
          ffi.Pointer<pw_context_events>, ffi.Pointer<ffi.Void>)>();

  /// Get the context properties
  ffi.Pointer<pw_properties> pw_context_get_properties(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_get_properties(
      context,
    );
  }

  late final _pw_context_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<pw_context>)>>('pw_context_get_properties');
  late final _pw_context_get_properties =
      _pw_context_get_propertiesPtr.asFunction<
          ffi.Pointer<pw_properties> Function(ffi.Pointer<pw_context>)>();

  /// Update the context properties
  int pw_context_update_properties(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_context_update_properties(
      context,
      dict,
    );
  }

  late final _pw_context_update_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>,
              ffi.Pointer<spa_dict>)>>('pw_context_update_properties');
  late final _pw_context_update_properties =
      _pw_context_update_propertiesPtr.asFunction<
          int Function(ffi.Pointer<pw_context>, ffi.Pointer<spa_dict>)>();

  /// Get a config section for this context. Since 0.3.22, deprecated,
  /// use pw_context_conf_section_for_each().
  ffi.Pointer<ffi.Char> pw_context_get_conf_section(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> section,
  ) {
    return _pw_context_get_conf_section(
      context,
      section,
    );
  }

  late final _pw_context_get_conf_sectionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_get_conf_section');
  late final _pw_context_get_conf_section =
      _pw_context_get_conf_sectionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  /// Parse a standard config section for this context. Since 0.3.22
  int pw_context_parse_conf_section(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<pw_properties> conf,
    ffi.Pointer<ffi.Char> section,
  ) {
    return _pw_context_parse_conf_section(
      context,
      conf,
      section,
    );
  }

  late final _pw_context_parse_conf_sectionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>, ffi.Pointer<pw_properties>,
              ffi.Pointer<ffi.Char>)>>('pw_context_parse_conf_section');
  late final _pw_context_parse_conf_section =
      _pw_context_parse_conf_sectionPtr.asFunction<
          int Function(ffi.Pointer<pw_context>, ffi.Pointer<pw_properties>,
              ffi.Pointer<ffi.Char>)>();

  /// update properties from a section into props. Since 0.3.45
  int pw_context_conf_update_props(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> section,
    ffi.Pointer<pw_properties> props,
  ) {
    return _pw_context_conf_update_props(
      context,
      section,
      props,
    );
  }

  late final _pw_context_conf_update_propsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>)>>('pw_context_conf_update_props');
  late final _pw_context_conf_update_props =
      _pw_context_conf_update_propsPtr.asFunction<
          int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>)>();

  /// emit callback for all config sections. Since 0.3.45
  int pw_context_conf_section_for_each(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> section,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
                    ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Size)>>
        callback,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_context_conf_section_for_each(
      context,
      section,
      callback,
      data,
    );
  }

  late final _pw_context_conf_section_for_eachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Size)>>,
              ffi.Pointer<ffi.Void>)>>('pw_context_conf_section_for_each');
  late final _pw_context_conf_section_for_each =
      _pw_context_conf_section_for_eachPtr.asFunction<
          int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Size)>>,
              ffi.Pointer<ffi.Void>)>();

  /// emit callback for all matched properties. Since 0.3.46
  int pw_context_conf_section_match_rules(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> section,
    ffi.Pointer<spa_dict> props,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
                    ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Size)>>
        callback,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_context_conf_section_match_rules(
      context,
      section,
      props,
      callback,
      data,
    );
  }

  late final _pw_context_conf_section_match_rulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Size)>>,
              ffi.Pointer<ffi.Void>)>>('pw_context_conf_section_match_rules');
  late final _pw_context_conf_section_match_rules =
      _pw_context_conf_section_match_rulesPtr.asFunction<
          int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Pointer<ffi.Char>,
                          ffi.Size)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Get the context support objects
  ffi.Pointer<spa_support> pw_context_get_support(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Uint32> n_support,
  ) {
    return _pw_context_get_support(
      context,
      n_support,
    );
  }

  late final _pw_context_get_supportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_support> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Uint32>)>>('pw_context_get_support');
  late final _pw_context_get_support = _pw_context_get_supportPtr.asFunction<
      ffi.Pointer<spa_support> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<ffi.Uint32>)>();

  /// get the context main loop
  ffi.Pointer<pw_loop> pw_context_get_main_loop(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_get_main_loop(
      context,
    );
  }

  late final _pw_context_get_main_loopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_loop> Function(
              ffi.Pointer<pw_context>)>>('pw_context_get_main_loop');
  late final _pw_context_get_main_loop = _pw_context_get_main_loopPtr
      .asFunction<ffi.Pointer<pw_loop> Function(ffi.Pointer<pw_context>)>();

  /// Get the work queue from the context: Since 0.3.26
  ffi.Pointer<pw_work_queue> pw_context_get_work_queue(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_get_work_queue(
      context,
    );
  }

  late final _pw_context_get_work_queuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_work_queue> Function(
              ffi.Pointer<pw_context>)>>('pw_context_get_work_queue');
  late final _pw_context_get_work_queue =
      _pw_context_get_work_queuePtr.asFunction<
          ffi.Pointer<pw_work_queue> Function(ffi.Pointer<pw_context>)>();

  /// Iterate the globals of the context. The callback should return
  /// 0 to fetch the next item, any other value stops the iteration and returns
  /// the value. When all callbacks return 0, this function returns 0 when all
  /// globals are iterated.
  int pw_context_for_each_global(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<pw_global>)>>
        callback,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_context_for_each_global(
      context,
      callback,
      data,
    );
  }

  late final _pw_context_for_each_globalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>, ffi.Pointer<pw_global>)>>,
              ffi.Pointer<ffi.Void>)>>('pw_context_for_each_global');
  late final _pw_context_for_each_global =
      _pw_context_for_each_globalPtr.asFunction<
          int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>, ffi.Pointer<pw_global>)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Find a context global by id
  ffi.Pointer<pw_global> pw_context_find_global(
    ffi.Pointer<pw_context> context,
    int id,
  ) {
    return _pw_context_find_global(
      context,
      id,
    );
  }

  late final _pw_context_find_globalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_global> Function(
              ffi.Pointer<pw_context>, ffi.Uint32)>>('pw_context_find_global');
  late final _pw_context_find_global = _pw_context_find_globalPtr.asFunction<
      ffi.Pointer<pw_global> Function(ffi.Pointer<pw_context>, int)>();

  /// add a spa library for the given factory_name regex
  int pw_context_add_spa_lib(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> factory_regex,
    ffi.Pointer<ffi.Char> lib,
  ) {
    return _pw_context_add_spa_lib(
      context,
      factory_regex,
      lib,
    );
  }

  late final _pw_context_add_spa_libPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pw_context_add_spa_lib');
  late final _pw_context_add_spa_lib = _pw_context_add_spa_libPtr.asFunction<
      int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// find the library name for a spa factory
  ffi.Pointer<ffi.Char> pw_context_find_spa_lib(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> factory_name,
  ) {
    return _pw_context_find_spa_lib(
      context,
      factory_name,
    );
  }

  late final _pw_context_find_spa_libPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_find_spa_lib');
  late final _pw_context_find_spa_lib = _pw_context_find_spa_libPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<spa_handle> pw_context_load_spa_handle(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> factory_name,
    ffi.Pointer<spa_dict> info,
  ) {
    return _pw_context_load_spa_handle(
      context,
      factory_name,
      info,
    );
  }

  late final _pw_context_load_spa_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_handle> Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>)>>('pw_context_load_spa_handle');
  late final _pw_context_load_spa_handle =
      _pw_context_load_spa_handlePtr.asFunction<
          ffi.Pointer<spa_handle> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<spa_dict>)>();

  /// register a type that can be exported on a context_proxy. This is usually used by
  /// extension modules
  int pw_context_register_export_type(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<pw_export_type> type,
  ) {
    return _pw_context_register_export_type(
      context,
      type,
    );
  }

  late final _pw_context_register_export_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>,
              ffi.Pointer<pw_export_type>)>>('pw_context_register_export_type');
  late final _pw_context_register_export_type =
      _pw_context_register_export_typePtr.asFunction<
          int Function(ffi.Pointer<pw_context>, ffi.Pointer<pw_export_type>)>();

  /// find information about registered export type
  ffi.Pointer<pw_export_type> pw_context_find_export_type(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> type,
  ) {
    return _pw_context_find_export_type(
      context,
      type,
    );
  }

  late final _pw_context_find_export_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_export_type> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_find_export_type');
  late final _pw_context_find_export_type =
      _pw_context_find_export_typePtr.asFunction<
          ffi.Pointer<pw_export_type> Function(
              ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  /// add an object to the context
  int pw_context_set_object(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> type,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _pw_context_set_object(
      context,
      type,
      value,
    );
  }

  late final _pw_context_set_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('pw_context_set_object');
  late final _pw_context_set_object = _pw_context_set_objectPtr.asFunction<
      int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>)>();

  /// get an object from the context
  ffi.Pointer<ffi.Void> pw_context_get_object(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> type,
  ) {
    return _pw_context_get_object(
      context,
      type,
    );
  }

  late final _pw_context_get_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_get_object');
  late final _pw_context_get_object = _pw_context_get_objectPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> pw_split_walk(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Char> delimiter,
    ffi.Pointer<ffi.Size> len,
    ffi.Pointer<ffi.Pointer<ffi.Char>> state,
  ) {
    return _pw_split_walk(
      str,
      delimiter,
      len,
      state,
    );
  }

  late final _pw_split_walkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('pw_split_walk');
  late final _pw_split_walk = _pw_split_walkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Pointer<ffi.Char>> pw_split_strv(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Char> delimiter,
    int max_tokens,
    ffi.Pointer<ffi.Int> n_tokens,
  ) {
    return _pw_split_strv(
      str,
      delimiter,
      max_tokens,
      n_tokens,
    );
  }

  late final _pw_split_strvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Int>)>>('pw_split_strv');
  late final _pw_split_strv = _pw_split_strvPtr.asFunction<
      ffi.Pointer<ffi.Pointer<ffi.Char>> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Int>)>();

  void pw_free_strv(
    ffi.Pointer<ffi.Pointer<ffi.Char>> str,
  ) {
    return _pw_free_strv(
      str,
    );
  }

  late final _pw_free_strvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('pw_free_strv');
  late final _pw_free_strv = _pw_free_strvPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Char> pw_strip(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Char> whitespace,
  ) {
    return _pw_strip(
      str,
      whitespace,
    );
  }

  late final _pw_stripPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('pw_strip');
  late final _pw_strip = _pw_stripPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int pw_getrandom(
    ffi.Pointer<ffi.Void> buf,
    int buflen,
    int flags,
  ) {
    return _pw_getrandom(
      buf,
      buflen,
      flags,
    );
  }

  late final _pw_getrandomPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.UnsignedInt)>>('pw_getrandom');
  late final _pw_getrandom = _pw_getrandomPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<pw_protocol> pw_protocol_new(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> name,
    int user_data_size,
  ) {
    return _pw_protocol_new(
      context,
      name,
      user_data_size,
    );
  }

  late final _pw_protocol_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_protocol> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('pw_protocol_new');
  late final _pw_protocol_new = _pw_protocol_newPtr.asFunction<
      ffi.Pointer<pw_protocol> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>, int)>();

  void pw_protocol_destroy(
    ffi.Pointer<pw_protocol> protocol,
  ) {
    return _pw_protocol_destroy(
      protocol,
    );
  }

  late final _pw_protocol_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_protocol>)>>(
          'pw_protocol_destroy');
  late final _pw_protocol_destroy = _pw_protocol_destroyPtr
      .asFunction<void Function(ffi.Pointer<pw_protocol>)>();

  ffi.Pointer<pw_context> pw_protocol_get_context(
    ffi.Pointer<pw_protocol> protocol,
  ) {
    return _pw_protocol_get_context(
      protocol,
    );
  }

  late final _pw_protocol_get_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_context> Function(
              ffi.Pointer<pw_protocol>)>>('pw_protocol_get_context');
  late final _pw_protocol_get_context = _pw_protocol_get_contextPtr
      .asFunction<ffi.Pointer<pw_context> Function(ffi.Pointer<pw_protocol>)>();

  ffi.Pointer<ffi.Void> pw_protocol_get_user_data(
    ffi.Pointer<pw_protocol> protocol,
  ) {
    return _pw_protocol_get_user_data(
      protocol,
    );
  }

  late final _pw_protocol_get_user_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<pw_protocol>)>>('pw_protocol_get_user_data');
  late final _pw_protocol_get_user_data = _pw_protocol_get_user_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_protocol>)>();

  ffi.Pointer<pw_protocol_implementation> pw_protocol_get_implementation(
    ffi.Pointer<pw_protocol> protocol,
  ) {
    return _pw_protocol_get_implementation(
      protocol,
    );
  }

  late final _pw_protocol_get_implementationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_protocol_implementation> Function(
              ffi.Pointer<pw_protocol>)>>('pw_protocol_get_implementation');
  late final _pw_protocol_get_implementation =
      _pw_protocol_get_implementationPtr.asFunction<
          ffi.Pointer<pw_protocol_implementation> Function(
              ffi.Pointer<pw_protocol>)>();

  ffi.Pointer<ffi.Void> pw_protocol_get_extension(
    ffi.Pointer<pw_protocol> protocol,
  ) {
    return _pw_protocol_get_extension(
      protocol,
    );
  }

  late final _pw_protocol_get_extensionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<pw_protocol>)>>('pw_protocol_get_extension');
  late final _pw_protocol_get_extension = _pw_protocol_get_extensionPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_protocol>)>();

  void pw_protocol_add_listener(
    ffi.Pointer<pw_protocol> protocol,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_protocol_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_protocol_add_listener(
      protocol,
      listener,
      events,
      data,
    );
  }

  late final _pw_protocol_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_protocol>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_protocol_events>,
              ffi.Pointer<ffi.Void>)>>('pw_protocol_add_listener');
  late final _pw_protocol_add_listener =
      _pw_protocol_add_listenerPtr.asFunction<
          void Function(ffi.Pointer<pw_protocol>, ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_protocol_events>, ffi.Pointer<ffi.Void>)>();

  int pw_protocol_add_marshal(
    ffi.Pointer<pw_protocol> protocol,
    ffi.Pointer<pw_protocol_marshal> marshal,
  ) {
    return _pw_protocol_add_marshal(
      protocol,
      marshal,
    );
  }

  late final _pw_protocol_add_marshalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_protocol>,
              ffi.Pointer<pw_protocol_marshal>)>>('pw_protocol_add_marshal');
  late final _pw_protocol_add_marshal = _pw_protocol_add_marshalPtr.asFunction<
      int Function(
          ffi.Pointer<pw_protocol>, ffi.Pointer<pw_protocol_marshal>)>();

  ffi.Pointer<pw_protocol_marshal> pw_protocol_get_marshal(
    ffi.Pointer<pw_protocol> protocol,
    ffi.Pointer<ffi.Char> type,
    int version,
    int flags,
  ) {
    return _pw_protocol_get_marshal(
      protocol,
      type,
      version,
      flags,
    );
  }

  late final _pw_protocol_get_marshalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_protocol_marshal> Function(
              ffi.Pointer<pw_protocol>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint32,
              ffi.Uint32)>>('pw_protocol_get_marshal');
  late final _pw_protocol_get_marshal = _pw_protocol_get_marshalPtr.asFunction<
      ffi.Pointer<pw_protocol_marshal> Function(
          ffi.Pointer<pw_protocol>, ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<pw_protocol> pw_context_find_protocol(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _pw_context_find_protocol(
      context,
      name,
    );
  }

  late final _pw_context_find_protocolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_protocol> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_find_protocol');
  late final _pw_context_find_protocol =
      _pw_context_find_protocolPtr.asFunction<
          ffi.Pointer<pw_protocol> Function(
              ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  /// Make a new proxy object. The id can be used to bind to a remote object and
  /// can be retrieved with \ref pw_proxy_get_id .
  ffi.Pointer<pw_proxy> pw_proxy_new(
    ffi.Pointer<pw_proxy> factory1,
    ffi.Pointer<ffi.Char> type,
    int version,
    int user_data_size,
  ) {
    return _pw_proxy_new(
      factory1,
      type,
      version,
      user_data_size,
    );
  }

  late final _pw_proxy_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_proxy> Function(ffi.Pointer<pw_proxy>,
              ffi.Pointer<ffi.Char>, ffi.Uint32, ffi.Size)>>('pw_proxy_new');
  late final _pw_proxy_new = _pw_proxy_newPtr.asFunction<
      ffi.Pointer<pw_proxy> Function(
          ffi.Pointer<pw_proxy>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Add an event listener to proxy
  void pw_proxy_add_listener(
    ffi.Pointer<pw_proxy> proxy,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_proxy_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_proxy_add_listener(
      proxy,
      listener,
      events,
      data,
    );
  }

  late final _pw_proxy_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_proxy>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_proxy_events>,
              ffi.Pointer<ffi.Void>)>>('pw_proxy_add_listener');
  late final _pw_proxy_add_listener = _pw_proxy_add_listenerPtr.asFunction<
      void Function(ffi.Pointer<pw_proxy>, ffi.Pointer<spa_hook>,
          ffi.Pointer<pw_proxy_events>, ffi.Pointer<ffi.Void>)>();

  /// Add a listener for the events received from the remote object. The
  /// events depend on the type of the remote object type.
  void pw_proxy_add_object_listener(
    ffi.Pointer<pw_proxy> proxy,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<ffi.Void> funcs,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_proxy_add_object_listener(
      proxy,
      listener,
      funcs,
      data,
    );
  }

  late final _pw_proxy_add_object_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_proxy>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('pw_proxy_add_object_listener');
  late final _pw_proxy_add_object_listener =
      _pw_proxy_add_object_listenerPtr.asFunction<
          void Function(ffi.Pointer<pw_proxy>, ffi.Pointer<spa_hook>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// destroy a proxy
  void pw_proxy_destroy(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_destroy(
      proxy,
    );
  }

  late final _pw_proxy_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_proxy>)>>(
          'pw_proxy_destroy');
  late final _pw_proxy_destroy =
      _pw_proxy_destroyPtr.asFunction<void Function(ffi.Pointer<pw_proxy>)>();

  void pw_proxy_ref(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_ref(
      proxy,
    );
  }

  late final _pw_proxy_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_proxy>)>>(
          'pw_proxy_ref');
  late final _pw_proxy_ref =
      _pw_proxy_refPtr.asFunction<void Function(ffi.Pointer<pw_proxy>)>();

  void pw_proxy_unref(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_unref(
      proxy,
    );
  }

  late final _pw_proxy_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_proxy>)>>(
          'pw_proxy_unref');
  late final _pw_proxy_unref =
      _pw_proxy_unrefPtr.asFunction<void Function(ffi.Pointer<pw_proxy>)>();

  /// Get the user_data. The size was given in \ref pw_proxy_new
  ffi.Pointer<ffi.Void> pw_proxy_get_user_data(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_get_user_data(
      proxy,
    );
  }

  late final _pw_proxy_get_user_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<pw_proxy>)>>('pw_proxy_get_user_data');
  late final _pw_proxy_get_user_data = _pw_proxy_get_user_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_proxy>)>();

  /// Get the local id of the proxy
  int pw_proxy_get_id(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_get_id(
      proxy,
    );
  }

  late final _pw_proxy_get_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<pw_proxy>)>>(
          'pw_proxy_get_id');
  late final _pw_proxy_get_id =
      _pw_proxy_get_idPtr.asFunction<int Function(ffi.Pointer<pw_proxy>)>();

  /// Get the type and version of the proxy
  ffi.Pointer<ffi.Char> pw_proxy_get_type(
    ffi.Pointer<pw_proxy> proxy,
    ffi.Pointer<ffi.Uint32> version,
  ) {
    return _pw_proxy_get_type(
      proxy,
      version,
    );
  }

  late final _pw_proxy_get_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_proxy>,
              ffi.Pointer<ffi.Uint32>)>>('pw_proxy_get_type');
  late final _pw_proxy_get_type = _pw_proxy_get_typePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<pw_proxy>, ffi.Pointer<ffi.Uint32>)>();

  /// Get the protocol used for the proxy
  ffi.Pointer<pw_protocol> pw_proxy_get_protocol(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_get_protocol(
      proxy,
    );
  }

  late final _pw_proxy_get_protocolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_protocol> Function(
              ffi.Pointer<pw_proxy>)>>('pw_proxy_get_protocol');
  late final _pw_proxy_get_protocol = _pw_proxy_get_protocolPtr
      .asFunction<ffi.Pointer<pw_protocol> Function(ffi.Pointer<pw_proxy>)>();

  /// Generate an sync method for a proxy. This will generate a done event
  /// with the same seq number of the reply.
  int pw_proxy_sync(
    ffi.Pointer<pw_proxy> proxy,
    int seq,
  ) {
    return _pw_proxy_sync(
      proxy,
      seq,
    );
  }

  late final _pw_proxy_syncPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_proxy>, ffi.Int)>>(
      'pw_proxy_sync');
  late final _pw_proxy_sync =
      _pw_proxy_syncPtr.asFunction<int Function(ffi.Pointer<pw_proxy>, int)>();

  /// Set the global id this proxy is bound to. This is usually used internally
  /// and will also emit the bound event
  int pw_proxy_set_bound_id(
    ffi.Pointer<pw_proxy> proxy,
    int global_id,
  ) {
    return _pw_proxy_set_bound_id(
      proxy,
      global_id,
    );
  }

  late final _pw_proxy_set_bound_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_proxy>, ffi.Uint32)>>('pw_proxy_set_bound_id');
  late final _pw_proxy_set_bound_id = _pw_proxy_set_bound_idPtr
      .asFunction<int Function(ffi.Pointer<pw_proxy>, int)>();

  /// Get the global id bound to this proxy of SPA_ID_INVALID when not bound
  /// to a global
  int pw_proxy_get_bound_id(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_get_bound_id(
      proxy,
    );
  }

  late final _pw_proxy_get_bound_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<pw_proxy>)>>(
          'pw_proxy_get_bound_id');
  late final _pw_proxy_get_bound_id = _pw_proxy_get_bound_idPtr
      .asFunction<int Function(ffi.Pointer<pw_proxy>)>();

  /// Generate an error for a proxy
  int pw_proxy_error(
    ffi.Pointer<pw_proxy> proxy,
    int res,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _pw_proxy_error(
      proxy,
      res,
      error,
    );
  }

  late final _pw_proxy_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_proxy>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('pw_proxy_error');
  late final _pw_proxy_error = _pw_proxy_errorPtr.asFunction<
      int Function(ffi.Pointer<pw_proxy>, int, ffi.Pointer<ffi.Char>)>();

  int pw_proxy_errorf(
    ffi.Pointer<pw_proxy> proxy,
    int res,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _pw_proxy_errorf(
      proxy,
      res,
      error,
    );
  }

  late final _pw_proxy_errorfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_proxy>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('pw_proxy_errorf');
  late final _pw_proxy_errorf = _pw_proxy_errorfPtr.asFunction<
      int Function(ffi.Pointer<pw_proxy>, int, ffi.Pointer<ffi.Char>)>();

  /// Get the listener of proxy
  ffi.Pointer<spa_hook_list> pw_proxy_get_object_listeners(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_get_object_listeners(
      proxy,
    );
  }

  late final _pw_proxy_get_object_listenersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_hook_list> Function(
              ffi.Pointer<pw_proxy>)>>('pw_proxy_get_object_listeners');
  late final _pw_proxy_get_object_listeners = _pw_proxy_get_object_listenersPtr
      .asFunction<ffi.Pointer<spa_hook_list> Function(ffi.Pointer<pw_proxy>)>();

  /// Get the marshal functions for the proxy
  ffi.Pointer<pw_protocol_marshal> pw_proxy_get_marshal(
    ffi.Pointer<pw_proxy> proxy,
  ) {
    return _pw_proxy_get_marshal(
      proxy,
    );
  }

  late final _pw_proxy_get_marshalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_protocol_marshal> Function(
              ffi.Pointer<pw_proxy>)>>('pw_proxy_get_marshal');
  late final _pw_proxy_get_marshal = _pw_proxy_get_marshalPtr.asFunction<
      ffi.Pointer<pw_protocol_marshal> Function(ffi.Pointer<pw_proxy>)>();

  /// Install a marshal function on a proxy
  int pw_proxy_install_marshal(
    ffi.Pointer<pw_proxy> proxy,
    bool implementor,
  ) {
    return _pw_proxy_install_marshal(
      proxy,
      implementor,
    );
  }

  late final _pw_proxy_install_marshalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_proxy>, ffi.Bool)>>('pw_proxy_install_marshal');
  late final _pw_proxy_install_marshal = _pw_proxy_install_marshalPtr
      .asFunction<int Function(ffi.Pointer<pw_proxy>, bool)>();

  /// Update an existing \ref pw_client_info with \a update with reset
  ffi.Pointer<pw_client_info> pw_client_info_update(
    ffi.Pointer<pw_client_info> info,
    ffi.Pointer<pw_client_info> update,
  ) {
    return _pw_client_info_update(
      info,
      update,
    );
  }

  late final _pw_client_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_client_info> Function(ffi.Pointer<pw_client_info>,
              ffi.Pointer<pw_client_info>)>>('pw_client_info_update');
  late final _pw_client_info_update = _pw_client_info_updatePtr.asFunction<
      ffi.Pointer<pw_client_info> Function(
          ffi.Pointer<pw_client_info>, ffi.Pointer<pw_client_info>)>();

  /// Merge an existing \ref pw_client_info with \a update
  ffi.Pointer<pw_client_info> pw_client_info_merge(
    ffi.Pointer<pw_client_info> info,
    ffi.Pointer<pw_client_info> update,
    bool reset,
  ) {
    return _pw_client_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_client_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_client_info> Function(ffi.Pointer<pw_client_info>,
              ffi.Pointer<pw_client_info>, ffi.Bool)>>('pw_client_info_merge');
  late final _pw_client_info_merge = _pw_client_info_mergePtr.asFunction<
      ffi.Pointer<pw_client_info> Function(
          ffi.Pointer<pw_client_info>, ffi.Pointer<pw_client_info>, bool)>();

  /// Free a \ref pw_client_info
  void pw_client_info_free(
    ffi.Pointer<pw_client_info> info,
  ) {
    return _pw_client_info_free(
      info,
    );
  }

  late final _pw_client_info_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_client_info>)>>(
      'pw_client_info_free');
  late final _pw_client_info_free = _pw_client_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_client_info>)>();

  /// Update and existing \ref pw_device_info with \a update and reset
  ffi.Pointer<pw_device_info> pw_device_info_update(
    ffi.Pointer<pw_device_info> info,
    ffi.Pointer<pw_device_info> update,
  ) {
    return _pw_device_info_update(
      info,
      update,
    );
  }

  late final _pw_device_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_device_info> Function(ffi.Pointer<pw_device_info>,
              ffi.Pointer<pw_device_info>)>>('pw_device_info_update');
  late final _pw_device_info_update = _pw_device_info_updatePtr.asFunction<
      ffi.Pointer<pw_device_info> Function(
          ffi.Pointer<pw_device_info>, ffi.Pointer<pw_device_info>)>();

  /// Merge and existing \ref pw_device_info with \a update
  ffi.Pointer<pw_device_info> pw_device_info_merge(
    ffi.Pointer<pw_device_info> info,
    ffi.Pointer<pw_device_info> update,
    bool reset,
  ) {
    return _pw_device_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_device_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_device_info> Function(ffi.Pointer<pw_device_info>,
              ffi.Pointer<pw_device_info>, ffi.Bool)>>('pw_device_info_merge');
  late final _pw_device_info_merge = _pw_device_info_mergePtr.asFunction<
      ffi.Pointer<pw_device_info> Function(
          ffi.Pointer<pw_device_info>, ffi.Pointer<pw_device_info>, bool)>();

  /// Free a \ref pw_device_info
  void pw_device_info_free(
    ffi.Pointer<pw_device_info> info,
  ) {
    return _pw_device_info_free(
      info,
    );
  }

  late final _pw_device_info_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_device_info>)>>(
      'pw_device_info_free');
  late final _pw_device_info_free = _pw_device_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_device_info>)>();

  /// Create a new memory pool
  ffi.Pointer<pw_mempool> pw_mempool_new(
    ffi.Pointer<pw_properties> props,
  ) {
    return _pw_mempool_new(
      props,
    );
  }

  late final _pw_mempool_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_mempool> Function(
              ffi.Pointer<pw_properties>)>>('pw_mempool_new');
  late final _pw_mempool_new = _pw_mempool_newPtr.asFunction<
      ffi.Pointer<pw_mempool> Function(ffi.Pointer<pw_properties>)>();

  /// Listen for events
  void pw_mempool_add_listener(
    ffi.Pointer<pw_mempool> pool,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_mempool_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_mempool_add_listener(
      pool,
      listener,
      events,
      data,
    );
  }

  late final _pw_mempool_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_mempool>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_mempool_events>,
              ffi.Pointer<ffi.Void>)>>('pw_mempool_add_listener');
  late final _pw_mempool_add_listener = _pw_mempool_add_listenerPtr.asFunction<
      void Function(ffi.Pointer<pw_mempool>, ffi.Pointer<spa_hook>,
          ffi.Pointer<pw_mempool_events>, ffi.Pointer<ffi.Void>)>();

  /// Clear a pool
  void pw_mempool_clear(
    ffi.Pointer<pw_mempool> pool,
  ) {
    return _pw_mempool_clear(
      pool,
    );
  }

  late final _pw_mempool_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_mempool>)>>(
          'pw_mempool_clear');
  late final _pw_mempool_clear =
      _pw_mempool_clearPtr.asFunction<void Function(ffi.Pointer<pw_mempool>)>();

  /// Clear and destroy a pool
  void pw_mempool_destroy(
    ffi.Pointer<pw_mempool> pool,
  ) {
    return _pw_mempool_destroy(
      pool,
    );
  }

  late final _pw_mempool_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_mempool>)>>(
          'pw_mempool_destroy');
  late final _pw_mempool_destroy = _pw_mempool_destroyPtr
      .asFunction<void Function(ffi.Pointer<pw_mempool>)>();

  /// Allocate a memory block from the pool
  ffi.Pointer<pw_memblock> pw_mempool_alloc(
    ffi.Pointer<pw_mempool> pool,
    int flags,
    int type,
    int size,
  ) {
    return _pw_mempool_alloc(
      pool,
      flags,
      type,
      size,
    );
  }

  late final _pw_mempool_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memblock> Function(ffi.Pointer<pw_mempool>, ffi.Int32,
              ffi.Uint32, ffi.Size)>>('pw_mempool_alloc');
  late final _pw_mempool_alloc = _pw_mempool_allocPtr.asFunction<
      ffi.Pointer<pw_memblock> Function(
          ffi.Pointer<pw_mempool>, int, int, int)>();

  /// Import a block from another pool
  ffi.Pointer<pw_memblock> pw_mempool_import_block(
    ffi.Pointer<pw_mempool> pool,
    ffi.Pointer<pw_memblock> mem,
  ) {
    return _pw_mempool_import_block(
      pool,
      mem,
    );
  }

  late final _pw_mempool_import_blockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memblock> Function(ffi.Pointer<pw_mempool>,
              ffi.Pointer<pw_memblock>)>>('pw_mempool_import_block');
  late final _pw_mempool_import_block = _pw_mempool_import_blockPtr.asFunction<
      ffi.Pointer<pw_memblock> Function(
          ffi.Pointer<pw_mempool>, ffi.Pointer<pw_memblock>)>();

  /// Import an fd into the pool
  ffi.Pointer<pw_memblock> pw_mempool_import(
    ffi.Pointer<pw_mempool> pool,
    int flags,
    int type,
    int fd,
  ) {
    return _pw_mempool_import(
      pool,
      flags,
      type,
      fd,
    );
  }

  late final _pw_mempool_importPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memblock> Function(ffi.Pointer<pw_mempool>, ffi.Int32,
              ffi.Uint32, ffi.Int)>>('pw_mempool_import');
  late final _pw_mempool_import = _pw_mempool_importPtr.asFunction<
      ffi.Pointer<pw_memblock> Function(
          ffi.Pointer<pw_mempool>, int, int, int)>();

  /// Free a memblock regardless of the refcount and destroy all mappings
  void pw_memblock_free(
    ffi.Pointer<pw_memblock> mem,
  ) {
    return _pw_memblock_free(
      mem,
    );
  }

  late final _pw_memblock_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_memblock>)>>(
          'pw_memblock_free');
  late final _pw_memblock_free = _pw_memblock_freePtr
      .asFunction<void Function(ffi.Pointer<pw_memblock>)>();

  /// Remove a memblock for given \a id
  int pw_mempool_remove_id(
    ffi.Pointer<pw_mempool> pool,
    int id,
  ) {
    return _pw_mempool_remove_id(
      pool,
      id,
    );
  }

  late final _pw_mempool_remove_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_mempool>, ffi.Uint32)>>('pw_mempool_remove_id');
  late final _pw_mempool_remove_id = _pw_mempool_remove_idPtr
      .asFunction<int Function(ffi.Pointer<pw_mempool>, int)>();

  /// Find memblock for given \a ptr
  ffi.Pointer<pw_memblock> pw_mempool_find_ptr(
    ffi.Pointer<pw_mempool> pool,
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _pw_mempool_find_ptr(
      pool,
      ptr,
    );
  }

  late final _pw_mempool_find_ptrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memblock> Function(ffi.Pointer<pw_mempool>,
              ffi.Pointer<ffi.Void>)>>('pw_mempool_find_ptr');
  late final _pw_mempool_find_ptr = _pw_mempool_find_ptrPtr.asFunction<
      ffi.Pointer<pw_memblock> Function(
          ffi.Pointer<pw_mempool>, ffi.Pointer<ffi.Void>)>();

  /// Find memblock for given \a id
  ffi.Pointer<pw_memblock> pw_mempool_find_id(
    ffi.Pointer<pw_mempool> pool,
    int id,
  ) {
    return _pw_mempool_find_id(
      pool,
      id,
    );
  }

  late final _pw_mempool_find_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memblock> Function(
              ffi.Pointer<pw_mempool>, ffi.Uint32)>>('pw_mempool_find_id');
  late final _pw_mempool_find_id = _pw_mempool_find_idPtr.asFunction<
      ffi.Pointer<pw_memblock> Function(ffi.Pointer<pw_mempool>, int)>();

  /// Find memblock for given \a fd
  ffi.Pointer<pw_memblock> pw_mempool_find_fd(
    ffi.Pointer<pw_mempool> pool,
    int fd,
  ) {
    return _pw_mempool_find_fd(
      pool,
      fd,
    );
  }

  late final _pw_mempool_find_fdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memblock> Function(
              ffi.Pointer<pw_mempool>, ffi.Int)>>('pw_mempool_find_fd');
  late final _pw_mempool_find_fd = _pw_mempool_find_fdPtr.asFunction<
      ffi.Pointer<pw_memblock> Function(ffi.Pointer<pw_mempool>, int)>();

  /// Map a region of a memory block
  ffi.Pointer<pw_memmap> pw_memblock_map(
    ffi.Pointer<pw_memblock> block,
    int flags,
    int offset,
    int size,
    ffi.Pointer<ffi.Uint32> tag,
  ) {
    return _pw_memblock_map(
      block,
      flags,
      offset,
      size,
      tag,
    );
  }

  late final _pw_memblock_mapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memmap> Function(
              ffi.Pointer<pw_memblock>,
              ffi.Int32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint32>)>>('pw_memblock_map');
  late final _pw_memblock_map = _pw_memblock_mapPtr.asFunction<
      ffi.Pointer<pw_memmap> Function(
          ffi.Pointer<pw_memblock>, int, int, int, ffi.Pointer<ffi.Uint32>)>();

  /// Map a region of a memory block with \a id
  ffi.Pointer<pw_memmap> pw_mempool_map_id(
    ffi.Pointer<pw_mempool> pool,
    int id,
    int flags,
    int offset,
    int size,
    ffi.Pointer<ffi.Uint32> tag,
  ) {
    return _pw_mempool_map_id(
      pool,
      id,
      flags,
      offset,
      size,
      tag,
    );
  }

  late final _pw_mempool_map_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memmap> Function(
              ffi.Pointer<pw_mempool>,
              ffi.Uint32,
              ffi.Int32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint32>)>>('pw_mempool_map_id');
  late final _pw_mempool_map_id = _pw_mempool_map_idPtr.asFunction<
      ffi.Pointer<pw_memmap> Function(ffi.Pointer<pw_mempool>, int, int, int,
          int, ffi.Pointer<ffi.Uint32>)>();

  ffi.Pointer<pw_memmap> pw_mempool_import_map(
    ffi.Pointer<pw_mempool> pool,
    ffi.Pointer<pw_mempool> other,
    ffi.Pointer<ffi.Void> data,
    int size,
    ffi.Pointer<ffi.Uint32> tag,
  ) {
    return _pw_mempool_import_map(
      pool,
      other,
      data,
      size,
      tag,
    );
  }

  late final _pw_mempool_import_mapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memmap> Function(
              ffi.Pointer<pw_mempool>,
              ffi.Pointer<pw_mempool>,
              ffi.Pointer<ffi.Void>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint32>)>>('pw_mempool_import_map');
  late final _pw_mempool_import_map = _pw_mempool_import_mapPtr.asFunction<
      ffi.Pointer<pw_memmap> Function(
          ffi.Pointer<pw_mempool>,
          ffi.Pointer<pw_mempool>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Uint32>)>();

  /// find a map with the given tag
  ffi.Pointer<pw_memmap> pw_mempool_find_tag(
    ffi.Pointer<pw_mempool> pool,
    ffi.Pointer<ffi.Uint32> tag,
    int size,
  ) {
    return _pw_mempool_find_tag(
      pool,
      tag,
      size,
    );
  }

  late final _pw_mempool_find_tagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_memmap> Function(ffi.Pointer<pw_mempool>,
              ffi.Pointer<ffi.Uint32>, ffi.Size)>>('pw_mempool_find_tag');
  late final _pw_mempool_find_tag = _pw_mempool_find_tagPtr.asFunction<
      ffi.Pointer<pw_memmap> Function(
          ffi.Pointer<pw_mempool>, ffi.Pointer<ffi.Uint32>, int)>();

  /// Unmap a region
  int pw_memmap_free(
    ffi.Pointer<pw_memmap> map,
  ) {
    return _pw_memmap_free(
      map,
    );
  }

  late final _pw_memmap_freePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_memmap>)>>(
          'pw_memmap_free');
  late final _pw_memmap_free =
      _pw_memmap_freePtr.asFunction<int Function(ffi.Pointer<pw_memmap>)>();

  int pw_buffers_negotiate(
    ffi.Pointer<pw_context> context,
    int flags,
    ffi.Pointer<spa_node> outnode,
    int out_port_id,
    ffi.Pointer<spa_node> innode,
    int in_port_id,
    ffi.Pointer<pw_buffers> result,
  ) {
    return _pw_buffers_negotiate(
      context,
      flags,
      outnode,
      out_port_id,
      innode,
      in_port_id,
      result,
    );
  }

  late final _pw_buffers_negotiatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_context>,
              ffi.Uint32,
              ffi.Pointer<spa_node>,
              ffi.Uint32,
              ffi.Pointer<spa_node>,
              ffi.Uint32,
              ffi.Pointer<pw_buffers>)>>('pw_buffers_negotiate');
  late final _pw_buffers_negotiate = _pw_buffers_negotiatePtr.asFunction<
      int Function(ffi.Pointer<pw_context>, int, ffi.Pointer<spa_node>, int,
          ffi.Pointer<spa_node>, int, ffi.Pointer<pw_buffers>)>();

  void pw_buffers_clear(
    ffi.Pointer<pw_buffers> buffers,
  ) {
    return _pw_buffers_clear(
      buffers,
    );
  }

  late final _pw_buffers_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_buffers>)>>(
          'pw_buffers_clear');
  late final _pw_buffers_clear =
      _pw_buffers_clearPtr.asFunction<void Function(ffi.Pointer<pw_buffers>)>();

  ffi.Pointer<pw_factory_info> pw_factory_info_update(
    ffi.Pointer<pw_factory_info> info,
    ffi.Pointer<pw_factory_info> update,
  ) {
    return _pw_factory_info_update(
      info,
      update,
    );
  }

  late final _pw_factory_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_factory_info> Function(ffi.Pointer<pw_factory_info>,
              ffi.Pointer<pw_factory_info>)>>('pw_factory_info_update');
  late final _pw_factory_info_update = _pw_factory_info_updatePtr.asFunction<
      ffi.Pointer<pw_factory_info> Function(
          ffi.Pointer<pw_factory_info>, ffi.Pointer<pw_factory_info>)>();

  ffi.Pointer<pw_factory_info> pw_factory_info_merge(
    ffi.Pointer<pw_factory_info> info,
    ffi.Pointer<pw_factory_info> update,
    bool reset,
  ) {
    return _pw_factory_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_factory_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_factory_info> Function(
              ffi.Pointer<pw_factory_info>,
              ffi.Pointer<pw_factory_info>,
              ffi.Bool)>>('pw_factory_info_merge');
  late final _pw_factory_info_merge = _pw_factory_info_mergePtr.asFunction<
      ffi.Pointer<pw_factory_info> Function(
          ffi.Pointer<pw_factory_info>, ffi.Pointer<pw_factory_info>, bool)>();

  void pw_factory_info_free(
    ffi.Pointer<pw_factory_info> info,
  ) {
    return _pw_factory_info_free(
      info,
    );
  }

  late final _pw_factory_info_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_factory_info>)>>(
      'pw_factory_info_free');
  late final _pw_factory_info_free = _pw_factory_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_factory_info>)>();

  /// \addtogroup pw_log
  /// \{
  /// /
  /// /** The global log level
  late final ffi.Pointer<ffi.Int32> _pw_log_level =
      _lookup<ffi.Int32>('pw_log_level');

  int get pw_log_level => _pw_log_level.value;

  set pw_log_level(int value) => _pw_log_level.value = value;

  late final ffi.Pointer<ffi.Pointer<spa_log_topic>> _PW_LOG_TOPIC_DEFAULT =
      _lookup<ffi.Pointer<spa_log_topic>>('PW_LOG_TOPIC_DEFAULT');

  ffi.Pointer<spa_log_topic> get PW_LOG_TOPIC_DEFAULT =>
      _PW_LOG_TOPIC_DEFAULT.value;

  set PW_LOG_TOPIC_DEFAULT(ffi.Pointer<spa_log_topic> value) =>
      _PW_LOG_TOPIC_DEFAULT.value = value;

  /// Configure a logging module. This is usually done automatically
  /// in pw_init() but you can install a custom logger before calling
  /// pw_init().
  void pw_log_set(
    ffi.Pointer<spa_log> log,
  ) {
    return _pw_log_set(
      log,
    );
  }

  late final _pw_log_setPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<spa_log>)>>(
          'pw_log_set');
  late final _pw_log_set =
      _pw_log_setPtr.asFunction<void Function(ffi.Pointer<spa_log>)>();

  /// Get the log interface
  ffi.Pointer<spa_log> pw_log_get() {
    return _pw_log_get();
  }

  late final _pw_log_getPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<spa_log> Function()>>(
          'pw_log_get');
  late final _pw_log_get =
      _pw_log_getPtr.asFunction<ffi.Pointer<spa_log> Function()>();

  /// Configure the logging level
  void pw_log_set_level(
    int level,
  ) {
    return _pw_log_set_level(
      level,
    );
  }

  late final _pw_log_set_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'pw_log_set_level');
  late final _pw_log_set_level =
      _pw_log_set_levelPtr.asFunction<void Function(int)>();

  /// Log a message for a topic
  void pw_log_logt(
    int level,
    ffi.Pointer<spa_log_topic> topic,
    ffi.Pointer<ffi.Char> file,
    int line,
    ffi.Pointer<ffi.Char> func,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _pw_log_logt(
      level,
      topic,
      file,
      line,
      func,
      fmt,
    );
  }

  late final _pw_log_logtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32,
              ffi.Pointer<spa_log_topic>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pw_log_logt');
  late final _pw_log_logt = _pw_log_logtPtr.asFunction<
      void Function(int, ffi.Pointer<spa_log_topic>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Log a message for a topic
  void pw_log_logtv(
    int level,
    ffi.Pointer<spa_log_topic> topic,
    ffi.Pointer<ffi.Char> file,
    int line,
    ffi.Pointer<ffi.Char> func,
    ffi.Pointer<ffi.Char> fmt,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _pw_log_logtv(
      level,
      topic,
      file,
      line,
      func,
      fmt,
      args,
    );
  }

  late final _pw_log_logtvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32,
              ffi.Pointer<spa_log_topic>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('pw_log_logtv');
  late final _pw_log_logtv = _pw_log_logtvPtr.asFunction<
      void Function(
          int,
          ffi.Pointer<spa_log_topic>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  /// Log a message for the default topic
  void pw_log_log(
    int level,
    ffi.Pointer<ffi.Char> file,
    int line,
    ffi.Pointer<ffi.Char> func,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _pw_log_log(
      level,
      file,
      line,
      func,
      fmt,
    );
  }

  late final _pw_log_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('pw_log_log');
  late final _pw_log_log = _pw_log_logPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Log a message for the default topic
  void pw_log_logv(
    int level,
    ffi.Pointer<ffi.Char> file,
    int line,
    ffi.Pointer<ffi.Char> func,
    ffi.Pointer<ffi.Char> fmt,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _pw_log_logv(
      level,
      file,
      line,
      func,
      fmt,
      args,
    );
  }

  late final _pw_log_logvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('pw_log_logv');
  late final _pw_log_logv = _pw_log_logvPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  /// Convert a \ref pw_link_state to a readable string
  ffi.Pointer<ffi.Char> pw_link_state_as_string(
    int state,
  ) {
    return _pw_link_state_as_string(
      state,
    );
  }

  late final _pw_link_state_as_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'pw_link_state_as_string');
  late final _pw_link_state_as_string = _pw_link_state_as_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<pw_link_info> pw_link_info_update(
    ffi.Pointer<pw_link_info> info,
    ffi.Pointer<pw_link_info> update,
  ) {
    return _pw_link_info_update(
      info,
      update,
    );
  }

  late final _pw_link_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_link_info> Function(ffi.Pointer<pw_link_info>,
              ffi.Pointer<pw_link_info>)>>('pw_link_info_update');
  late final _pw_link_info_update = _pw_link_info_updatePtr.asFunction<
      ffi.Pointer<pw_link_info> Function(
          ffi.Pointer<pw_link_info>, ffi.Pointer<pw_link_info>)>();

  ffi.Pointer<pw_link_info> pw_link_info_merge(
    ffi.Pointer<pw_link_info> info,
    ffi.Pointer<pw_link_info> update,
    bool reset,
  ) {
    return _pw_link_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_link_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_link_info> Function(ffi.Pointer<pw_link_info>,
              ffi.Pointer<pw_link_info>, ffi.Bool)>>('pw_link_info_merge');
  late final _pw_link_info_merge = _pw_link_info_mergePtr.asFunction<
      ffi.Pointer<pw_link_info> Function(
          ffi.Pointer<pw_link_info>, ffi.Pointer<pw_link_info>, bool)>();

  void pw_link_info_free(
    ffi.Pointer<pw_link_info> info,
  ) {
    return _pw_link_info_free(
      info,
    );
  }

  late final _pw_link_info_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_link_info>)>>(
          'pw_link_info_free');
  late final _pw_link_info_free = _pw_link_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_link_info>)>();

  /// Create a new main loop.
  ffi.Pointer<pw_main_loop> pw_main_loop_new(
    ffi.Pointer<spa_dict> props,
  ) {
    return _pw_main_loop_new(
      props,
    );
  }

  late final _pw_main_loop_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_main_loop> Function(
              ffi.Pointer<spa_dict>)>>('pw_main_loop_new');
  late final _pw_main_loop_new = _pw_main_loop_newPtr
      .asFunction<ffi.Pointer<pw_main_loop> Function(ffi.Pointer<spa_dict>)>();

  /// Add an event listener
  void pw_main_loop_add_listener(
    ffi.Pointer<pw_main_loop> loop,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_main_loop_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_main_loop_add_listener(
      loop,
      listener,
      events,
      data,
    );
  }

  late final _pw_main_loop_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_main_loop>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_main_loop_events>,
              ffi.Pointer<ffi.Void>)>>('pw_main_loop_add_listener');
  late final _pw_main_loop_add_listener =
      _pw_main_loop_add_listenerPtr.asFunction<
          void Function(ffi.Pointer<pw_main_loop>, ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_main_loop_events>, ffi.Pointer<ffi.Void>)>();

  /// Get the loop implementation
  ffi.Pointer<pw_loop> pw_main_loop_get_loop(
    ffi.Pointer<pw_main_loop> loop,
  ) {
    return _pw_main_loop_get_loop(
      loop,
    );
  }

  late final _pw_main_loop_get_loopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_loop> Function(
              ffi.Pointer<pw_main_loop>)>>('pw_main_loop_get_loop');
  late final _pw_main_loop_get_loop = _pw_main_loop_get_loopPtr
      .asFunction<ffi.Pointer<pw_loop> Function(ffi.Pointer<pw_main_loop>)>();

  /// Destroy a loop
  void pw_main_loop_destroy(
    ffi.Pointer<pw_main_loop> loop,
  ) {
    return _pw_main_loop_destroy(
      loop,
    );
  }

  late final _pw_main_loop_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_main_loop>)>>(
          'pw_main_loop_destroy');
  late final _pw_main_loop_destroy = _pw_main_loop_destroyPtr
      .asFunction<void Function(ffi.Pointer<pw_main_loop>)>();

  /// Run a main loop. This blocks until \ref pw_main_loop_quit is called
  int pw_main_loop_run(
    ffi.Pointer<pw_main_loop> loop,
  ) {
    return _pw_main_loop_run(
      loop,
    );
  }

  late final _pw_main_loop_runPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_main_loop>)>>(
          'pw_main_loop_run');
  late final _pw_main_loop_run = _pw_main_loop_runPtr
      .asFunction<int Function(ffi.Pointer<pw_main_loop>)>();

  /// Quit a main loop
  int pw_main_loop_quit(
    ffi.Pointer<pw_main_loop> loop,
  ) {
    return _pw_main_loop_quit(
      loop,
    );
  }

  late final _pw_main_loop_quitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_main_loop>)>>(
          'pw_main_loop_quit');
  late final _pw_main_loop_quit = _pw_main_loop_quitPtr
      .asFunction<int Function(ffi.Pointer<pw_main_loop>)>();

  /// Update and existing \ref pw_module_info with \a update with reset
  ffi.Pointer<pw_module_info> pw_module_info_update(
    ffi.Pointer<pw_module_info> info,
    ffi.Pointer<pw_module_info> update,
  ) {
    return _pw_module_info_update(
      info,
      update,
    );
  }

  late final _pw_module_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_module_info> Function(ffi.Pointer<pw_module_info>,
              ffi.Pointer<pw_module_info>)>>('pw_module_info_update');
  late final _pw_module_info_update = _pw_module_info_updatePtr.asFunction<
      ffi.Pointer<pw_module_info> Function(
          ffi.Pointer<pw_module_info>, ffi.Pointer<pw_module_info>)>();

  /// Merge and existing \ref pw_module_info with \a update
  ffi.Pointer<pw_module_info> pw_module_info_merge(
    ffi.Pointer<pw_module_info> info,
    ffi.Pointer<pw_module_info> update,
    bool reset,
  ) {
    return _pw_module_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_module_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_module_info> Function(ffi.Pointer<pw_module_info>,
              ffi.Pointer<pw_module_info>, ffi.Bool)>>('pw_module_info_merge');
  late final _pw_module_info_merge = _pw_module_info_mergePtr.asFunction<
      ffi.Pointer<pw_module_info> Function(
          ffi.Pointer<pw_module_info>, ffi.Pointer<pw_module_info>, bool)>();

  /// Free a \ref pw_module_info
  void pw_module_info_free(
    ffi.Pointer<pw_module_info> info,
  ) {
    return _pw_module_info_free(
      info,
    );
  }

  late final _pw_module_info_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_module_info>)>>(
      'pw_module_info_free');
  late final _pw_module_info_free = _pw_module_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_module_info>)>();

  /// Convert a \ref pw_node_state to a readable string
  ffi.Pointer<ffi.Char> pw_node_state_as_string(
    int state,
  ) {
    return _pw_node_state_as_string(
      state,
    );
  }

  late final _pw_node_state_as_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'pw_node_state_as_string');
  late final _pw_node_state_as_string = _pw_node_state_as_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<pw_node_info> pw_node_info_update(
    ffi.Pointer<pw_node_info> info,
    ffi.Pointer<pw_node_info> update,
  ) {
    return _pw_node_info_update(
      info,
      update,
    );
  }

  late final _pw_node_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_node_info> Function(ffi.Pointer<pw_node_info>,
              ffi.Pointer<pw_node_info>)>>('pw_node_info_update');
  late final _pw_node_info_update = _pw_node_info_updatePtr.asFunction<
      ffi.Pointer<pw_node_info> Function(
          ffi.Pointer<pw_node_info>, ffi.Pointer<pw_node_info>)>();

  ffi.Pointer<pw_node_info> pw_node_info_merge(
    ffi.Pointer<pw_node_info> info,
    ffi.Pointer<pw_node_info> update,
    bool reset,
  ) {
    return _pw_node_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_node_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_node_info> Function(ffi.Pointer<pw_node_info>,
              ffi.Pointer<pw_node_info>, ffi.Bool)>>('pw_node_info_merge');
  late final _pw_node_info_merge = _pw_node_info_mergePtr.asFunction<
      ffi.Pointer<pw_node_info> Function(
          ffi.Pointer<pw_node_info>, ffi.Pointer<pw_node_info>, bool)>();

  void pw_node_info_free(
    ffi.Pointer<pw_node_info> info,
  ) {
    return _pw_node_info_free(
      info,
    );
  }

  late final _pw_node_info_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_node_info>)>>(
          'pw_node_info_free');
  late final _pw_node_info_free = _pw_node_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_node_info>)>();

  /// Convert a \ref pw_direction to a readable string
  ffi.Pointer<ffi.Char> pw_direction_as_string(
    int direction,
  ) {
    return _pw_direction_as_string(
      direction,
    );
  }

  late final _pw_direction_as_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'pw_direction_as_string');
  late final _pw_direction_as_string = _pw_direction_as_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<pw_port_info> pw_port_info_update(
    ffi.Pointer<pw_port_info> info,
    ffi.Pointer<pw_port_info> update,
  ) {
    return _pw_port_info_update(
      info,
      update,
    );
  }

  late final _pw_port_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_port_info> Function(ffi.Pointer<pw_port_info>,
              ffi.Pointer<pw_port_info>)>>('pw_port_info_update');
  late final _pw_port_info_update = _pw_port_info_updatePtr.asFunction<
      ffi.Pointer<pw_port_info> Function(
          ffi.Pointer<pw_port_info>, ffi.Pointer<pw_port_info>)>();

  ffi.Pointer<pw_port_info> pw_port_info_merge(
    ffi.Pointer<pw_port_info> info,
    ffi.Pointer<pw_port_info> update,
    bool reset,
  ) {
    return _pw_port_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_port_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_port_info> Function(ffi.Pointer<pw_port_info>,
              ffi.Pointer<pw_port_info>, ffi.Bool)>>('pw_port_info_merge');
  late final _pw_port_info_merge = _pw_port_info_mergePtr.asFunction<
      ffi.Pointer<pw_port_info> Function(
          ffi.Pointer<pw_port_info>, ffi.Pointer<pw_port_info>, bool)>();

  void pw_port_info_free(
    ffi.Pointer<pw_port_info> info,
  ) {
    return _pw_port_info_free(
      info,
    );
  }

  late final _pw_port_info_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_port_info>)>>(
          'pw_port_info_free');
  late final _pw_port_info_free = _pw_port_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_port_info>)>();

  /// Convert a stream state to a readable string
  ffi.Pointer<ffi.Char> pw_stream_state_as_string(
    int state,
  ) {
    return _pw_stream_state_as_string(
      state,
    );
  }

  late final _pw_stream_state_as_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'pw_stream_state_as_string');
  late final _pw_stream_state_as_string = _pw_stream_state_as_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Create a new unconneced \ref pw_stream
  /// \return a newly allocated \ref pw_stream
  ffi.Pointer<pw_stream> pw_stream_new(
    ffi.Pointer<pw_core> core,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<pw_properties> props,
  ) {
    return _pw_stream_new(
      core,
      name,
      props,
    );
  }

  late final _pw_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_stream> Function(
              ffi.Pointer<pw_core>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>)>>('pw_stream_new');
  late final _pw_stream_new = _pw_stream_newPtr.asFunction<
      ffi.Pointer<pw_stream> Function(ffi.Pointer<pw_core>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<pw_properties>)>();

  ffi.Pointer<pw_stream> pw_stream_new_simple(
    ffi.Pointer<pw_loop> loop,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<pw_properties> props,
    ffi.Pointer<pw_stream_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_stream_new_simple(
      loop,
      name,
      props,
      events,
      data,
    );
  }

  late final _pw_stream_new_simplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_stream> Function(
              ffi.Pointer<pw_loop>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>,
              ffi.Pointer<pw_stream_events>,
              ffi.Pointer<ffi.Void>)>>('pw_stream_new_simple');
  late final _pw_stream_new_simple = _pw_stream_new_simplePtr.asFunction<
      ffi.Pointer<pw_stream> Function(
          ffi.Pointer<pw_loop>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<pw_properties>,
          ffi.Pointer<pw_stream_events>,
          ffi.Pointer<ffi.Void>)>();

  /// Destroy a stream
  void pw_stream_destroy(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_destroy(
      stream,
    );
  }

  late final _pw_stream_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_destroy');
  late final _pw_stream_destroy =
      _pw_stream_destroyPtr.asFunction<void Function(ffi.Pointer<pw_stream>)>();

  void pw_stream_add_listener(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_stream_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_stream_add_listener(
      stream,
      listener,
      events,
      data,
    );
  }

  late final _pw_stream_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_stream>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_stream_events>,
              ffi.Pointer<ffi.Void>)>>('pw_stream_add_listener');
  late final _pw_stream_add_listener = _pw_stream_add_listenerPtr.asFunction<
      void Function(ffi.Pointer<pw_stream>, ffi.Pointer<spa_hook>,
          ffi.Pointer<pw_stream_events>, ffi.Pointer<ffi.Void>)>();

  int pw_stream_get_state(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _pw_stream_get_state(
      stream,
      error,
    );
  }

  late final _pw_stream_get_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<pw_stream>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('pw_stream_get_state');
  late final _pw_stream_get_state = _pw_stream_get_statePtr.asFunction<
      int Function(
          ffi.Pointer<pw_stream>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Char> pw_stream_get_name(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_get_name(
      stream,
    );
  }

  late final _pw_stream_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<pw_stream>)>>('pw_stream_get_name');
  late final _pw_stream_get_name = _pw_stream_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_stream>)>();

  ffi.Pointer<pw_core> pw_stream_get_core(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_get_core(
      stream,
    );
  }

  late final _pw_stream_get_corePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(
              ffi.Pointer<pw_stream>)>>('pw_stream_get_core');
  late final _pw_stream_get_core = _pw_stream_get_corePtr
      .asFunction<ffi.Pointer<pw_core> Function(ffi.Pointer<pw_stream>)>();

  ffi.Pointer<pw_properties> pw_stream_get_properties(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_get_properties(
      stream,
    );
  }

  late final _pw_stream_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<pw_stream>)>>('pw_stream_get_properties');
  late final _pw_stream_get_properties =
      _pw_stream_get_propertiesPtr.asFunction<
          ffi.Pointer<pw_properties> Function(ffi.Pointer<pw_stream>)>();

  int pw_stream_update_properties(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_stream_update_properties(
      stream,
      dict,
    );
  }

  late final _pw_stream_update_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>,
              ffi.Pointer<spa_dict>)>>('pw_stream_update_properties');
  late final _pw_stream_update_properties =
      _pw_stream_update_propertiesPtr.asFunction<
          int Function(ffi.Pointer<pw_stream>, ffi.Pointer<spa_dict>)>();

  /// Connect a stream for input or output on \a port_path.
  /// \return 0 on success < 0 on error.
  ///
  /// You should connect to the process event and use pw_stream_dequeue_buffer()
  /// to get the latest metadata and data.
  int pw_stream_connect(
    ffi.Pointer<pw_stream> stream,
    int direction,
    int target_id,
    int flags,
    ffi.Pointer<ffi.Pointer<spa_pod>> params,
    int n_params,
  ) {
    return _pw_stream_connect(
      stream,
      direction,
      target_id,
      flags,
      params,
      n_params,
    );
  }

  late final _pw_stream_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_stream>,
              ffi.Int32,
              ffi.Uint32,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<spa_pod>>,
              ffi.Uint32)>>('pw_stream_connect');
  late final _pw_stream_connect = _pw_stream_connectPtr.asFunction<
      int Function(ffi.Pointer<pw_stream>, int, int, int,
          ffi.Pointer<ffi.Pointer<spa_pod>>, int)>();

  /// Get the node ID of the stream.
  /// \return node ID.
  int pw_stream_get_node_id(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_get_node_id(
      stream,
    );
  }

  late final _pw_stream_get_node_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_get_node_id');
  late final _pw_stream_get_node_id = _pw_stream_get_node_idPtr
      .asFunction<int Function(ffi.Pointer<pw_stream>)>();

  /// Disconnect \a stream
  int pw_stream_disconnect(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_disconnect(
      stream,
    );
  }

  late final _pw_stream_disconnectPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_disconnect');
  late final _pw_stream_disconnect = _pw_stream_disconnectPtr
      .asFunction<int Function(ffi.Pointer<pw_stream>)>();

  /// Set the stream in error state
  int pw_stream_set_error(
    ffi.Pointer<pw_stream> stream,
    int res,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _pw_stream_set_error(
      stream,
      res,
      error,
    );
  }

  late final _pw_stream_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('pw_stream_set_error');
  late final _pw_stream_set_error = _pw_stream_set_errorPtr.asFunction<
      int Function(ffi.Pointer<pw_stream>, int, ffi.Pointer<ffi.Char>)>();

  /// Complete the negotiation process with result code \a res
  ///
  /// This function should be called after notification of the format.
  ///
  /// When \a res indicates success, \a params contain the parameters for the
  /// allocation state.
  int pw_stream_update_params(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<ffi.Pointer<spa_pod>> params,
    int n_params,
  ) {
    return _pw_stream_update_params(
      stream,
      params,
      n_params,
    );
  }

  late final _pw_stream_update_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_stream>,
              ffi.Pointer<ffi.Pointer<spa_pod>>,
              ffi.Uint32)>>('pw_stream_update_params');
  late final _pw_stream_update_params = _pw_stream_update_paramsPtr.asFunction<
      int Function(
          ffi.Pointer<pw_stream>, ffi.Pointer<ffi.Pointer<spa_pod>>, int)>();

  /// Get control values
  ffi.Pointer<pw_stream_control> pw_stream_get_control(
    ffi.Pointer<pw_stream> stream,
    int id,
  ) {
    return _pw_stream_get_control(
      stream,
      id,
    );
  }

  late final _pw_stream_get_controlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_stream_control> Function(
              ffi.Pointer<pw_stream>, ffi.Uint32)>>('pw_stream_get_control');
  late final _pw_stream_get_control = _pw_stream_get_controlPtr.asFunction<
      ffi.Pointer<pw_stream_control> Function(ffi.Pointer<pw_stream>, int)>();

  /// Set control values
  int pw_stream_set_control(
    ffi.Pointer<pw_stream> stream,
    int id,
    int n_values,
    ffi.Pointer<ffi.Float> values,
  ) {
    return _pw_stream_set_control(
      stream,
      id,
      n_values,
      values,
    );
  }

  late final _pw_stream_set_controlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<ffi.Float>)>>('pw_stream_set_control');
  late final _pw_stream_set_control = _pw_stream_set_controlPtr.asFunction<
      int Function(ffi.Pointer<pw_stream>, int, int, ffi.Pointer<ffi.Float>)>();

  /// Query the time on the stream
  int pw_stream_get_time(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<pw_time> time,
  ) {
    return _pw_stream_get_time(
      stream,
      time,
    );
  }

  late final _pw_stream_get_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>,
              ffi.Pointer<pw_time>)>>('pw_stream_get_time');
  late final _pw_stream_get_time = _pw_stream_get_timePtr
      .asFunction<int Function(ffi.Pointer<pw_stream>, ffi.Pointer<pw_time>)>();

  /// Get a buffer that can be filled for playback streams or consumed
  /// for capture streams.
  ffi.Pointer<pw_buffer> pw_stream_dequeue_buffer(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_dequeue_buffer(
      stream,
    );
  }

  late final _pw_stream_dequeue_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_buffer> Function(
              ffi.Pointer<pw_stream>)>>('pw_stream_dequeue_buffer');
  late final _pw_stream_dequeue_buffer = _pw_stream_dequeue_bufferPtr
      .asFunction<ffi.Pointer<pw_buffer> Function(ffi.Pointer<pw_stream>)>();

  /// Submit a buffer for playback or recycle a buffer for capture.
  int pw_stream_queue_buffer(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<pw_buffer> buffer,
  ) {
    return _pw_stream_queue_buffer(
      stream,
      buffer,
    );
  }

  late final _pw_stream_queue_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>,
              ffi.Pointer<pw_buffer>)>>('pw_stream_queue_buffer');
  late final _pw_stream_queue_buffer = _pw_stream_queue_bufferPtr.asFunction<
      int Function(ffi.Pointer<pw_stream>, ffi.Pointer<pw_buffer>)>();

  /// Activate or deactivate the stream
  int pw_stream_set_active(
    ffi.Pointer<pw_stream> stream,
    bool active,
  ) {
    return _pw_stream_set_active(
      stream,
      active,
    );
  }

  late final _pw_stream_set_activePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_stream>, ffi.Bool)>>('pw_stream_set_active');
  late final _pw_stream_set_active = _pw_stream_set_activePtr
      .asFunction<int Function(ffi.Pointer<pw_stream>, bool)>();

  /// Flush a stream. When \a drain is true, the drained callback will
  /// be called when all data is played or recorded
  int pw_stream_flush(
    ffi.Pointer<pw_stream> stream,
    bool drain,
  ) {
    return _pw_stream_flush(
      stream,
      drain,
    );
  }

  late final _pw_stream_flushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_stream>, ffi.Bool)>>('pw_stream_flush');
  late final _pw_stream_flush = _pw_stream_flushPtr
      .asFunction<int Function(ffi.Pointer<pw_stream>, bool)>();

  /// Check if the stream is driving. The stream needs to have the
  /// PW_STREAM_FLAG_DRIVER set. When the stream is driving,
  /// pw_stream_trigger_process() needs to be called when data is
  /// available (output) or needed (input). Since 0.3.34
  bool pw_stream_is_driving(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_is_driving(
      stream,
    );
  }

  late final _pw_stream_is_drivingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_is_driving');
  late final _pw_stream_is_driving = _pw_stream_is_drivingPtr
      .asFunction<bool Function(ffi.Pointer<pw_stream>)>();

  /// Trigger a push/pull on the stream. One iteration of the graph will
  /// scheduled and process() will be called. Since 0.3.34
  int pw_stream_trigger_process(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_trigger_process(
      stream,
    );
  }

  late final _pw_stream_trigger_processPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_trigger_process');
  late final _pw_stream_trigger_process = _pw_stream_trigger_processPtr
      .asFunction<int Function(ffi.Pointer<pw_stream>)>();

  /// Convert a filter state to a readable string
  ffi.Pointer<ffi.Char> pw_filter_state_as_string(
    int state,
  ) {
    return _pw_filter_state_as_string(
      state,
    );
  }

  late final _pw_filter_state_as_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'pw_filter_state_as_string');
  late final _pw_filter_state_as_string = _pw_filter_state_as_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Create a new unconneced \ref pw_filter
  /// \return a newly allocated \ref pw_filter
  ffi.Pointer<pw_filter> pw_filter_new(
    ffi.Pointer<pw_core> core,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<pw_properties> props,
  ) {
    return _pw_filter_new(
      core,
      name,
      props,
    );
  }

  late final _pw_filter_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_filter> Function(
              ffi.Pointer<pw_core>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>)>>('pw_filter_new');
  late final _pw_filter_new = _pw_filter_newPtr.asFunction<
      ffi.Pointer<pw_filter> Function(ffi.Pointer<pw_core>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<pw_properties>)>();

  ffi.Pointer<pw_filter> pw_filter_new_simple(
    ffi.Pointer<pw_loop> loop,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<pw_properties> props,
    ffi.Pointer<pw_filter_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_filter_new_simple(
      loop,
      name,
      props,
      events,
      data,
    );
  }

  late final _pw_filter_new_simplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_filter> Function(
              ffi.Pointer<pw_loop>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>,
              ffi.Pointer<pw_filter_events>,
              ffi.Pointer<ffi.Void>)>>('pw_filter_new_simple');
  late final _pw_filter_new_simple = _pw_filter_new_simplePtr.asFunction<
      ffi.Pointer<pw_filter> Function(
          ffi.Pointer<pw_loop>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<pw_properties>,
          ffi.Pointer<pw_filter_events>,
          ffi.Pointer<ffi.Void>)>();

  /// Destroy a filter
  void pw_filter_destroy(
    ffi.Pointer<pw_filter> filter,
  ) {
    return _pw_filter_destroy(
      filter,
    );
  }

  late final _pw_filter_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_filter>)>>(
          'pw_filter_destroy');
  late final _pw_filter_destroy =
      _pw_filter_destroyPtr.asFunction<void Function(ffi.Pointer<pw_filter>)>();

  void pw_filter_add_listener(
    ffi.Pointer<pw_filter> filter,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_filter_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_filter_add_listener(
      filter,
      listener,
      events,
      data,
    );
  }

  late final _pw_filter_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_filter>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_filter_events>,
              ffi.Pointer<ffi.Void>)>>('pw_filter_add_listener');
  late final _pw_filter_add_listener = _pw_filter_add_listenerPtr.asFunction<
      void Function(ffi.Pointer<pw_filter>, ffi.Pointer<spa_hook>,
          ffi.Pointer<pw_filter_events>, ffi.Pointer<ffi.Void>)>();

  int pw_filter_get_state(
    ffi.Pointer<pw_filter> filter,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _pw_filter_get_state(
      filter,
      error,
    );
  }

  late final _pw_filter_get_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<pw_filter>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('pw_filter_get_state');
  late final _pw_filter_get_state = _pw_filter_get_statePtr.asFunction<
      int Function(
          ffi.Pointer<pw_filter>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Char> pw_filter_get_name(
    ffi.Pointer<pw_filter> filter,
  ) {
    return _pw_filter_get_name(
      filter,
    );
  }

  late final _pw_filter_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<pw_filter>)>>('pw_filter_get_name');
  late final _pw_filter_get_name = _pw_filter_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_filter>)>();

  ffi.Pointer<pw_core> pw_filter_get_core(
    ffi.Pointer<pw_filter> filter,
  ) {
    return _pw_filter_get_core(
      filter,
    );
  }

  late final _pw_filter_get_corePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(
              ffi.Pointer<pw_filter>)>>('pw_filter_get_core');
  late final _pw_filter_get_core = _pw_filter_get_corePtr
      .asFunction<ffi.Pointer<pw_core> Function(ffi.Pointer<pw_filter>)>();

  /// Connect a filter for processing.
  /// \return 0 on success < 0 on error.
  ///
  /// You should connect to the process event and use pw_filter_dequeue_buffer()
  /// to get the latest metadata and data.
  int pw_filter_connect(
    ffi.Pointer<pw_filter> filter,
    int flags,
    ffi.Pointer<ffi.Pointer<spa_pod>> params,
    int n_params,
  ) {
    return _pw_filter_connect(
      filter,
      flags,
      params,
      n_params,
    );
  }

  late final _pw_filter_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_filter>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<spa_pod>>,
              ffi.Uint32)>>('pw_filter_connect');
  late final _pw_filter_connect = _pw_filter_connectPtr.asFunction<
      int Function(ffi.Pointer<pw_filter>, int,
          ffi.Pointer<ffi.Pointer<spa_pod>>, int)>();

  /// Get the node ID of the filter.
  /// \return node ID.
  int pw_filter_get_node_id(
    ffi.Pointer<pw_filter> filter,
  ) {
    return _pw_filter_get_node_id(
      filter,
    );
  }

  late final _pw_filter_get_node_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<pw_filter>)>>(
          'pw_filter_get_node_id');
  late final _pw_filter_get_node_id = _pw_filter_get_node_idPtr
      .asFunction<int Function(ffi.Pointer<pw_filter>)>();

  /// Disconnect \a filter
  int pw_filter_disconnect(
    ffi.Pointer<pw_filter> filter,
  ) {
    return _pw_filter_disconnect(
      filter,
    );
  }

  late final _pw_filter_disconnectPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_filter>)>>(
          'pw_filter_disconnect');
  late final _pw_filter_disconnect = _pw_filter_disconnectPtr
      .asFunction<int Function(ffi.Pointer<pw_filter>)>();

  /// add a port to the filter, returns user data of port_data_size.
  ffi.Pointer<ffi.Void> pw_filter_add_port(
    ffi.Pointer<pw_filter> filter,
    int direction,
    int flags,
    int port_data_size,
    ffi.Pointer<pw_properties> props,
    ffi.Pointer<ffi.Pointer<spa_pod>> params,
    int n_params,
  ) {
    return _pw_filter_add_port(
      filter,
      direction,
      flags,
      port_data_size,
      props,
      params,
      n_params,
    );
  }

  late final _pw_filter_add_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<pw_filter>,
              ffi.Int32,
              ffi.Int32,
              ffi.Size,
              ffi.Pointer<pw_properties>,
              ffi.Pointer<ffi.Pointer<spa_pod>>,
              ffi.Uint32)>>('pw_filter_add_port');
  late final _pw_filter_add_port = _pw_filter_add_portPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<pw_filter>,
          int,
          int,
          int,
          ffi.Pointer<pw_properties>,
          ffi.Pointer<ffi.Pointer<spa_pod>>,
          int)>();

  /// remove a port from the filter
  int pw_filter_remove_port(
    ffi.Pointer<ffi.Void> port_data,
  ) {
    return _pw_filter_remove_port(
      port_data,
    );
  }

  late final _pw_filter_remove_portPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'pw_filter_remove_port');
  late final _pw_filter_remove_port = _pw_filter_remove_portPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// get properties, port_data of NULL will give global properties
  ffi.Pointer<pw_properties> pw_filter_get_properties(
    ffi.Pointer<pw_filter> filter,
    ffi.Pointer<ffi.Void> port_data,
  ) {
    return _pw_filter_get_properties(
      filter,
      port_data,
    );
  }

  late final _pw_filter_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(ffi.Pointer<pw_filter>,
              ffi.Pointer<ffi.Void>)>>('pw_filter_get_properties');
  late final _pw_filter_get_properties =
      _pw_filter_get_propertiesPtr.asFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<pw_filter>, ffi.Pointer<ffi.Void>)>();

  /// Update properties, use NULL port_data for global filter properties
  int pw_filter_update_properties(
    ffi.Pointer<pw_filter> filter,
    ffi.Pointer<ffi.Void> port_data,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_filter_update_properties(
      filter,
      port_data,
      dict,
    );
  }

  late final _pw_filter_update_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_filter>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_dict>)>>('pw_filter_update_properties');
  late final _pw_filter_update_properties =
      _pw_filter_update_propertiesPtr.asFunction<
          int Function(ffi.Pointer<pw_filter>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_dict>)>();

  /// Set the filter in error state
  int pw_filter_set_error(
    ffi.Pointer<pw_filter> filter,
    int res,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _pw_filter_set_error(
      filter,
      res,
      error,
    );
  }

  late final _pw_filter_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_filter>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('pw_filter_set_error');
  late final _pw_filter_set_error = _pw_filter_set_errorPtr.asFunction<
      int Function(ffi.Pointer<pw_filter>, int, ffi.Pointer<ffi.Char>)>();

  /// Update params, use NULL port_data for global filter params
  int pw_filter_update_params(
    ffi.Pointer<pw_filter> filter,
    ffi.Pointer<ffi.Void> port_data,
    ffi.Pointer<ffi.Pointer<spa_pod>> params,
    int n_params,
  ) {
    return _pw_filter_update_params(
      filter,
      port_data,
      params,
      n_params,
    );
  }

  late final _pw_filter_update_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_filter>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<spa_pod>>,
              ffi.Uint32)>>('pw_filter_update_params');
  late final _pw_filter_update_params = _pw_filter_update_paramsPtr.asFunction<
      int Function(ffi.Pointer<pw_filter>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<spa_pod>>, int)>();

  /// Query the time on the filter
  int pw_filter_get_time(
    ffi.Pointer<pw_filter> filter,
    ffi.Pointer<pw_time> time,
  ) {
    return _pw_filter_get_time(
      filter,
      time,
    );
  }

  late final _pw_filter_get_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_filter>,
              ffi.Pointer<pw_time>)>>('pw_filter_get_time');
  late final _pw_filter_get_time = _pw_filter_get_timePtr
      .asFunction<int Function(ffi.Pointer<pw_filter>, ffi.Pointer<pw_time>)>();

  /// Get a buffer that can be filled for output ports or consumed
  /// for input ports.
  ffi.Pointer<pw_buffer> pw_filter_dequeue_buffer(
    ffi.Pointer<ffi.Void> port_data,
  ) {
    return _pw_filter_dequeue_buffer(
      port_data,
    );
  }

  late final _pw_filter_dequeue_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_buffer> Function(
              ffi.Pointer<ffi.Void>)>>('pw_filter_dequeue_buffer');
  late final _pw_filter_dequeue_buffer = _pw_filter_dequeue_bufferPtr
      .asFunction<ffi.Pointer<pw_buffer> Function(ffi.Pointer<ffi.Void>)>();

  /// Submit a buffer for playback or recycle a buffer for capture.
  int pw_filter_queue_buffer(
    ffi.Pointer<ffi.Void> port_data,
    ffi.Pointer<pw_buffer> buffer,
  ) {
    return _pw_filter_queue_buffer(
      port_data,
      buffer,
    );
  }

  late final _pw_filter_queue_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<pw_buffer>)>>('pw_filter_queue_buffer');
  late final _pw_filter_queue_buffer = _pw_filter_queue_bufferPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<pw_buffer>)>();

  /// Get a data pointer to the buffer data
  ffi.Pointer<ffi.Void> pw_filter_get_dsp_buffer(
    ffi.Pointer<ffi.Void> port_data,
    int n_samples,
  ) {
    return _pw_filter_get_dsp_buffer(
      port_data,
      n_samples,
    );
  }

  late final _pw_filter_get_dsp_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Uint32)>>('pw_filter_get_dsp_buffer');
  late final _pw_filter_get_dsp_buffer = _pw_filter_get_dsp_bufferPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Activate or deactivate the filter
  int pw_filter_set_active(
    ffi.Pointer<pw_filter> filter,
    bool active,
  ) {
    return _pw_filter_set_active(
      filter,
      active,
    );
  }

  late final _pw_filter_set_activePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_filter>, ffi.Bool)>>('pw_filter_set_active');
  late final _pw_filter_set_active = _pw_filter_set_activePtr
      .asFunction<int Function(ffi.Pointer<pw_filter>, bool)>();

  /// Flush a filter. When \a drain is true, the drained callback will
  /// be called when all data is played or recorded
  int pw_filter_flush(
    ffi.Pointer<pw_filter> filter,
    bool drain,
  ) {
    return _pw_filter_flush(
      filter,
      drain,
    );
  }

  late final _pw_filter_flushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_filter>, ffi.Bool)>>('pw_filter_flush');
  late final _pw_filter_flush = _pw_filter_flushPtr
      .asFunction<int Function(ffi.Pointer<pw_filter>, bool)>();

  /// Make a new thread loop with the given name and optional properties.
  ffi.Pointer<pw_thread_loop> pw_thread_loop_new(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<spa_dict> props,
  ) {
    return _pw_thread_loop_new(
      name,
      props,
    );
  }

  late final _pw_thread_loop_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_thread_loop> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>)>>('pw_thread_loop_new');
  late final _pw_thread_loop_new = _pw_thread_loop_newPtr.asFunction<
      ffi.Pointer<pw_thread_loop> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<spa_dict>)>();

  /// Make a new thread loop with the given loop, name and optional properties.
  /// When \a loop is NULL, a new loop will be created.
  ffi.Pointer<pw_thread_loop> pw_thread_loop_new_full(
    ffi.Pointer<pw_loop> loop,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<spa_dict> props,
  ) {
    return _pw_thread_loop_new_full(
      loop,
      name,
      props,
    );
  }

  late final _pw_thread_loop_new_fullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_thread_loop> Function(
              ffi.Pointer<pw_loop>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>)>>('pw_thread_loop_new_full');
  late final _pw_thread_loop_new_full = _pw_thread_loop_new_fullPtr.asFunction<
      ffi.Pointer<pw_thread_loop> Function(ffi.Pointer<pw_loop>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<spa_dict>)>();

  /// Destroy a thread loop
  void pw_thread_loop_destroy(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_destroy(
      loop,
    );
  }

  late final _pw_thread_loop_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_thread_loop>)>>(
      'pw_thread_loop_destroy');
  late final _pw_thread_loop_destroy = _pw_thread_loop_destroyPtr
      .asFunction<void Function(ffi.Pointer<pw_thread_loop>)>();

  /// Add an event listener
  void pw_thread_loop_add_listener(
    ffi.Pointer<pw_thread_loop> loop,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_thread_loop_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_thread_loop_add_listener(
      loop,
      listener,
      events,
      data,
    );
  }

  late final _pw_thread_loop_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_thread_loop>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_thread_loop_events>,
              ffi.Pointer<ffi.Void>)>>('pw_thread_loop_add_listener');
  late final _pw_thread_loop_add_listener =
      _pw_thread_loop_add_listenerPtr.asFunction<
          void Function(ffi.Pointer<pw_thread_loop>, ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_thread_loop_events>, ffi.Pointer<ffi.Void>)>();

  /// Get the loop implementation of the thread loop
  ffi.Pointer<pw_loop> pw_thread_loop_get_loop(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_get_loop(
      loop,
    );
  }

  late final _pw_thread_loop_get_loopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_loop> Function(
              ffi.Pointer<pw_thread_loop>)>>('pw_thread_loop_get_loop');
  late final _pw_thread_loop_get_loop = _pw_thread_loop_get_loopPtr
      .asFunction<ffi.Pointer<pw_loop> Function(ffi.Pointer<pw_thread_loop>)>();

  /// Start the thread loop
  int pw_thread_loop_start(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_start(
      loop,
    );
  }

  late final _pw_thread_loop_startPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_thread_loop>)>>(
      'pw_thread_loop_start');
  late final _pw_thread_loop_start = _pw_thread_loop_startPtr
      .asFunction<int Function(ffi.Pointer<pw_thread_loop>)>();

  /// Stop the thread loop
  void pw_thread_loop_stop(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_stop(
      loop,
    );
  }

  late final _pw_thread_loop_stopPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_thread_loop>)>>(
      'pw_thread_loop_stop');
  late final _pw_thread_loop_stop = _pw_thread_loop_stopPtr
      .asFunction<void Function(ffi.Pointer<pw_thread_loop>)>();

  /// Lock the loop. This ensures exclusive ownership of the loop
  void pw_thread_loop_lock(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_lock(
      loop,
    );
  }

  late final _pw_thread_loop_lockPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_thread_loop>)>>(
      'pw_thread_loop_lock');
  late final _pw_thread_loop_lock = _pw_thread_loop_lockPtr
      .asFunction<void Function(ffi.Pointer<pw_thread_loop>)>();

  /// Unlock the loop
  void pw_thread_loop_unlock(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_unlock(
      loop,
    );
  }

  late final _pw_thread_loop_unlockPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_thread_loop>)>>(
      'pw_thread_loop_unlock');
  late final _pw_thread_loop_unlock = _pw_thread_loop_unlockPtr
      .asFunction<void Function(ffi.Pointer<pw_thread_loop>)>();

  /// Release the lock and wait until some thread calls \ref pw_thread_loop_signal
  void pw_thread_loop_wait(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_wait(
      loop,
    );
  }

  late final _pw_thread_loop_waitPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_thread_loop>)>>(
      'pw_thread_loop_wait');
  late final _pw_thread_loop_wait = _pw_thread_loop_waitPtr
      .asFunction<void Function(ffi.Pointer<pw_thread_loop>)>();

  /// Release the lock and wait a maximum of 'wait_max_sec' seconds
  /// until some thread calls \ref pw_thread_loop_signal or time out
  int pw_thread_loop_timed_wait(
    ffi.Pointer<pw_thread_loop> loop,
    int wait_max_sec,
  ) {
    return _pw_thread_loop_timed_wait(
      loop,
      wait_max_sec,
    );
  }

  late final _pw_thread_loop_timed_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_thread_loop>,
              ffi.Int)>>('pw_thread_loop_timed_wait');
  late final _pw_thread_loop_timed_wait = _pw_thread_loop_timed_waitPtr
      .asFunction<int Function(ffi.Pointer<pw_thread_loop>, int)>();

  /// Get a struct timespec suitable for \ref pw_thread_loop_timed_wait_full.
  /// Since: 0.3.7
  int pw_thread_loop_get_time(
    ffi.Pointer<pw_thread_loop> loop,
    ffi.Pointer<timespec> abstime,
    int timeout,
  ) {
    return _pw_thread_loop_get_time(
      loop,
      abstime,
      timeout,
    );
  }

  late final _pw_thread_loop_get_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_thread_loop>, ffi.Pointer<timespec>,
              ffi.Int64)>>('pw_thread_loop_get_time');
  late final _pw_thread_loop_get_time = _pw_thread_loop_get_timePtr.asFunction<
      int Function(ffi.Pointer<pw_thread_loop>, ffi.Pointer<timespec>, int)>();

  /// Release the lock and wait up to \a abstime until some thread calls
  /// \ref pw_thread_loop_signal. Use \ref pw_thread_loop_get_time to make a timeout.
  /// Since: 0.3.7
  int pw_thread_loop_timed_wait_full(
    ffi.Pointer<pw_thread_loop> loop,
    ffi.Pointer<timespec> abstime,
  ) {
    return _pw_thread_loop_timed_wait_full(
      loop,
      abstime,
    );
  }

  late final _pw_thread_loop_timed_wait_fullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_thread_loop>,
              ffi.Pointer<timespec>)>>('pw_thread_loop_timed_wait_full');
  late final _pw_thread_loop_timed_wait_full =
      _pw_thread_loop_timed_wait_fullPtr.asFunction<
          int Function(ffi.Pointer<pw_thread_loop>, ffi.Pointer<timespec>)>();

  /// Signal all threads waiting with \ref pw_thread_loop_wait
  void pw_thread_loop_signal(
    ffi.Pointer<pw_thread_loop> loop,
    bool wait_for_accept,
  ) {
    return _pw_thread_loop_signal(
      loop,
      wait_for_accept,
    );
  }

  late final _pw_thread_loop_signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_thread_loop>, ffi.Bool)>>('pw_thread_loop_signal');
  late final _pw_thread_loop_signal = _pw_thread_loop_signalPtr
      .asFunction<void Function(ffi.Pointer<pw_thread_loop>, bool)>();

  /// Signal all threads executing \ref pw_thread_loop_signal with wait_for_accept
  void pw_thread_loop_accept(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_accept(
      loop,
    );
  }

  late final _pw_thread_loop_acceptPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_thread_loop>)>>(
      'pw_thread_loop_accept');
  late final _pw_thread_loop_accept = _pw_thread_loop_acceptPtr
      .asFunction<void Function(ffi.Pointer<pw_thread_loop>)>();

  /// Check if inside the thread
  bool pw_thread_loop_in_thread(
    ffi.Pointer<pw_thread_loop> loop,
  ) {
    return _pw_thread_loop_in_thread(
      loop,
    );
  }

  late final _pw_thread_loop_in_threadPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<pw_thread_loop>)>>(
      'pw_thread_loop_in_thread');
  late final _pw_thread_loop_in_thread = _pw_thread_loop_in_threadPtr
      .asFunction<bool Function(ffi.Pointer<pw_thread_loop>)>();

  /// Make a new loop.
  ffi.Pointer<pw_data_loop> pw_data_loop_new(
    ffi.Pointer<spa_dict> props,
  ) {
    return _pw_data_loop_new(
      props,
    );
  }

  late final _pw_data_loop_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_data_loop> Function(
              ffi.Pointer<spa_dict>)>>('pw_data_loop_new');
  late final _pw_data_loop_new = _pw_data_loop_newPtr
      .asFunction<ffi.Pointer<pw_data_loop> Function(ffi.Pointer<spa_dict>)>();

  /// Add an event listener to loop
  void pw_data_loop_add_listener(
    ffi.Pointer<pw_data_loop> loop,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_data_loop_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_data_loop_add_listener(
      loop,
      listener,
      events,
      data,
    );
  }

  late final _pw_data_loop_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_data_loop>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_data_loop_events>,
              ffi.Pointer<ffi.Void>)>>('pw_data_loop_add_listener');
  late final _pw_data_loop_add_listener =
      _pw_data_loop_add_listenerPtr.asFunction<
          void Function(ffi.Pointer<pw_data_loop>, ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_data_loop_events>, ffi.Pointer<ffi.Void>)>();

  /// wait for activity on the loop up to \a timeout milliseconds.
  /// Should be called from the loop function
  int pw_data_loop_wait(
    ffi.Pointer<pw_data_loop> loop,
    int timeout,
  ) {
    return _pw_data_loop_wait(
      loop,
      timeout,
    );
  }

  late final _pw_data_loop_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_data_loop>, ffi.Int)>>('pw_data_loop_wait');
  late final _pw_data_loop_wait = _pw_data_loop_waitPtr
      .asFunction<int Function(ffi.Pointer<pw_data_loop>, int)>();

  /// make sure the thread will exit. Can be called from a loop callback
  void pw_data_loop_exit(
    ffi.Pointer<pw_data_loop> loop,
  ) {
    return _pw_data_loop_exit(
      loop,
    );
  }

  late final _pw_data_loop_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_data_loop>)>>(
          'pw_data_loop_exit');
  late final _pw_data_loop_exit = _pw_data_loop_exitPtr
      .asFunction<void Function(ffi.Pointer<pw_data_loop>)>();

  /// Get the loop implementation of this data loop
  ffi.Pointer<pw_loop> pw_data_loop_get_loop(
    ffi.Pointer<pw_data_loop> loop,
  ) {
    return _pw_data_loop_get_loop(
      loop,
    );
  }

  late final _pw_data_loop_get_loopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_loop> Function(
              ffi.Pointer<pw_data_loop>)>>('pw_data_loop_get_loop');
  late final _pw_data_loop_get_loop = _pw_data_loop_get_loopPtr
      .asFunction<ffi.Pointer<pw_loop> Function(ffi.Pointer<pw_data_loop>)>();

  /// Destroy the loop
  void pw_data_loop_destroy(
    ffi.Pointer<pw_data_loop> loop,
  ) {
    return _pw_data_loop_destroy(
      loop,
    );
  }

  late final _pw_data_loop_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_data_loop>)>>(
          'pw_data_loop_destroy');
  late final _pw_data_loop_destroy = _pw_data_loop_destroyPtr
      .asFunction<void Function(ffi.Pointer<pw_data_loop>)>();

  /// Start the processing thread
  int pw_data_loop_start(
    ffi.Pointer<pw_data_loop> loop,
  ) {
    return _pw_data_loop_start(
      loop,
    );
  }

  late final _pw_data_loop_startPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_data_loop>)>>(
          'pw_data_loop_start');
  late final _pw_data_loop_start = _pw_data_loop_startPtr
      .asFunction<int Function(ffi.Pointer<pw_data_loop>)>();

  /// Stop the processing thread
  int pw_data_loop_stop(
    ffi.Pointer<pw_data_loop> loop,
  ) {
    return _pw_data_loop_stop(
      loop,
    );
  }

  late final _pw_data_loop_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_data_loop>)>>(
          'pw_data_loop_stop');
  late final _pw_data_loop_stop = _pw_data_loop_stopPtr
      .asFunction<int Function(ffi.Pointer<pw_data_loop>)>();

  /// Check if the current thread is the processing thread
  bool pw_data_loop_in_thread(
    ffi.Pointer<pw_data_loop> loop,
  ) {
    return _pw_data_loop_in_thread(
      loop,
    );
  }

  late final _pw_data_loop_in_threadPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<pw_data_loop>)>>(
          'pw_data_loop_in_thread');
  late final _pw_data_loop_in_thread = _pw_data_loop_in_threadPtr
      .asFunction<bool Function(ffi.Pointer<pw_data_loop>)>();

  /// Get the thread object
  ffi.Pointer<spa_thread> pw_data_loop_get_thread(
    ffi.Pointer<pw_data_loop> loop,
  ) {
    return _pw_data_loop_get_thread(
      loop,
    );
  }

  late final _pw_data_loop_get_threadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_thread> Function(
              ffi.Pointer<pw_data_loop>)>>('pw_data_loop_get_thread');
  late final _pw_data_loop_get_thread = _pw_data_loop_get_threadPtr.asFunction<
      ffi.Pointer<spa_thread> Function(ffi.Pointer<pw_data_loop>)>();

  /// invoke func in the context of the thread or in the caller thread when
  /// the loop is not running. Since 0.3.3
  int pw_data_loop_invoke(
    ffi.Pointer<pw_data_loop> loop,
    spa_invoke_func_t func,
    int seq,
    ffi.Pointer<ffi.Void> data,
    int size,
    bool block,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _pw_data_loop_invoke(
      loop,
      func,
      seq,
      data,
      size,
      block,
      user_data,
    );
  }

  late final _pw_data_loop_invokePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_data_loop>,
              spa_invoke_func_t,
              ffi.Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('pw_data_loop_invoke');
  late final _pw_data_loop_invoke = _pw_data_loop_invokePtr.asFunction<
      int Function(ffi.Pointer<pw_data_loop>, spa_invoke_func_t, int,
          ffi.Pointer<ffi.Void>, int, bool, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<spa_type_info> pw_type_info() {
    return _pw_type_info();
  }

  late final _pw_type_infoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<spa_type_info> Function()>>(
          'pw_type_info');
  late final _pw_type_info =
      _pw_type_infoPtr.asFunction<ffi.Pointer<spa_type_info> Function()>();

  /// Return the version of the library the current application is
  /// linked to.
  ffi.Pointer<ffi.Char> pw_get_library_version() {
    return _pw_get_library_version();
  }

  late final _pw_get_library_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_library_version');
  late final _pw_get_library_version =
      _pw_get_library_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// \addtogroup pw_pipewire
  /// \{
  void pw_init(
    ffi.Pointer<ffi.Int> argc,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> argv,
  ) {
    return _pw_init(
      argc,
      argv,
    );
  }

  late final _pw_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>>('pw_init');
  late final _pw_init = _pw_initPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>();

  void pw_deinit() {
    return _pw_deinit();
  }

  late final _pw_deinitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('pw_deinit');
  late final _pw_deinit = _pw_deinitPtr.asFunction<void Function()>();

  bool pw_debug_is_category_enabled(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _pw_debug_is_category_enabled(
      name,
    );
  }

  late final _pw_debug_is_category_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'pw_debug_is_category_enabled');
  late final _pw_debug_is_category_enabled = _pw_debug_is_category_enabledPtr
      .asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> pw_get_application_name() {
    return _pw_get_application_name();
  }

  late final _pw_get_application_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_application_name');
  late final _pw_get_application_name = _pw_get_application_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_prgname() {
    return _pw_get_prgname();
  }

  late final _pw_get_prgnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_prgname');
  late final _pw_get_prgname =
      _pw_get_prgnamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_user_name() {
    return _pw_get_user_name();
  }

  late final _pw_get_user_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_user_name');
  late final _pw_get_user_name =
      _pw_get_user_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_host_name() {
    return _pw_get_host_name();
  }

  late final _pw_get_host_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_host_name');
  late final _pw_get_host_name =
      _pw_get_host_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_client_name() {
    return _pw_get_client_name();
  }

  late final _pw_get_client_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_client_name');
  late final _pw_get_client_name =
      _pw_get_client_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  bool pw_in_valgrind() {
    return _pw_in_valgrind();
  }

  late final _pw_in_valgrindPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('pw_in_valgrind');
  late final _pw_in_valgrind = _pw_in_valgrindPtr.asFunction<bool Function()>();

  bool pw_check_option(
    ffi.Pointer<ffi.Char> option,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pw_check_option(
      option,
      value,
    );
  }

  late final _pw_check_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pw_check_option');
  late final _pw_check_option = _pw_check_optionPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int pw_direction_reverse(
    int direction,
  ) {
    return _pw_direction_reverse(
      direction,
    );
  }

  late final _pw_direction_reversePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'pw_direction_reverse');
  late final _pw_direction_reverse =
      _pw_direction_reversePtr.asFunction<int Function(int)>();

  int pw_set_domain(
    ffi.Pointer<ffi.Char> domain,
  ) {
    return _pw_set_domain(
      domain,
    );
  }

  late final _pw_set_domainPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'pw_set_domain');
  late final _pw_set_domain =
      _pw_set_domainPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> pw_get_domain() {
    return _pw_get_domain();
  }

  late final _pw_get_domainPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_domain');
  late final _pw_get_domain =
      _pw_get_domainPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int pw_get_support(
    ffi.Pointer<spa_support> support,
    int max_support,
  ) {
    return _pw_get_support(
      support,
      max_support,
    );
  }

  late final _pw_get_supportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<spa_support>, ffi.Uint32)>>('pw_get_support');
  late final _pw_get_support = _pw_get_supportPtr
      .asFunction<int Function(ffi.Pointer<spa_support>, int)>();

  ffi.Pointer<spa_handle> pw_load_spa_handle(
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> factory_name,
    ffi.Pointer<spa_dict> info,
    int n_support,
    ffi.Pointer<spa_support> support,
  ) {
    return _pw_load_spa_handle(
      lib,
      factory_name,
      info,
      n_support,
      support,
    );
  }

  late final _pw_load_spa_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_handle> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Uint32,
              ffi.Pointer<spa_support>)>>('pw_load_spa_handle');
  late final _pw_load_spa_handle = _pw_load_spa_handlePtr.asFunction<
      ffi.Pointer<spa_handle> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<spa_dict>,
          int,
          ffi.Pointer<spa_support>)>();

  int pw_unload_spa_handle(
    ffi.Pointer<spa_handle> handle,
  ) {
    return _pw_unload_spa_handle(
      handle,
    );
  }

  late final _pw_unload_spa_handlePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<spa_handle>)>>(
          'pw_unload_spa_handle');
  late final _pw_unload_spa_handle = _pw_unload_spa_handlePtr
      .asFunction<int Function(ffi.Pointer<spa_handle>)>();
}

class imaxdiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

typedef intmax_t = __intmax_t;
typedef __intmax_t = ffi.Long;
typedef uintmax_t = __uintmax_t;
typedef __uintmax_t = ffi.UnsignedLong;
typedef __gwchar_t = ffi.Int;

class timespec extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__syscall_slong_t()
  external int tv_nsec;
}

typedef __time_t = ffi.Long;
typedef __syscall_slong_t = ffi.Long;

class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

class siginfo_t extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @ffi.Int()
  external int __pad0;

  external UnnamedUnion1 _sifields;
}

class UnnamedUnion1 extends ffi.Union {
  @ffi.Array.multi([28])
  external ffi.Array<ffi.Int> _pad;

  external UnnamedStruct1 _kill;

  external UnnamedStruct2 _timer;

  external UnnamedStruct3 _rt;

  external UnnamedStruct4 _sigchld;

  external UnnamedStruct5 _sigfault;

  external UnnamedStruct7 _sigpoll;

  external UnnamedStruct8 _sigsys;
}

class UnnamedStruct1 extends ffi.Struct {
  @__pid_t()
  external int si_pid;

  @__uid_t()
  external int si_uid;
}

typedef __pid_t = ffi.Int;
typedef __uid_t = ffi.UnsignedInt;

class UnnamedStruct2 extends ffi.Struct {
  @ffi.Int()
  external int si_tid;

  @ffi.Int()
  external int si_overrun;

  external __sigval_t si_sigval;
}

typedef __sigval_t = sigval;

class UnnamedStruct3 extends ffi.Struct {
  @__pid_t()
  external int si_pid;

  @__uid_t()
  external int si_uid;

  external __sigval_t si_sigval;
}

class UnnamedStruct4 extends ffi.Struct {
  @__pid_t()
  external int si_pid;

  @__uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  @__clock_t()
  external int si_utime;

  @__clock_t()
  external int si_stime;
}

typedef __clock_t = ffi.Long;

class UnnamedStruct5 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> si_addr;

  @ffi.Short()
  external int si_addr_lsb;

  external UnnamedUnion2 _bounds;
}

class UnnamedUnion2 extends ffi.Union {
  external UnnamedStruct6 _addr_bnd;

  @__uint32_t()
  external int _pkey;
}

class UnnamedStruct6 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _lower;

  external ffi.Pointer<ffi.Void> _upper;
}

typedef __uint32_t = ffi.UnsignedInt;

class UnnamedStruct7 extends ffi.Struct {
  @ffi.Long()
  external int si_band;

  @ffi.Int()
  external int si_fd;
}

class UnnamedStruct8 extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _call_addr;

  @ffi.Int()
  external int _syscall;

  @ffi.UnsignedInt()
  external int _arch;
}

class pthread_attr_t extends ffi.Union {
  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class sigevent extends ffi.Struct {
  external __sigval_t sigev_value;

  @ffi.Int()
  external int sigev_signo;

  @ffi.Int()
  external int sigev_notify;

  external UnnamedUnion3 _sigev_un;
}

class UnnamedUnion3 extends ffi.Union {
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Int> _pad;

  @__pid_t()
  external int _tid;

  external UnnamedStruct9 _sigev_thread;
}

class UnnamedStruct9 extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(__sigval_t)>>
      _function;

  external ffi.Pointer<pthread_attr_t> _attribute;
}

typedef __sighandler_t
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>;
typedef sigset_t = __sigset_t;

class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedLong> __val;
}

class sigaction extends ffi.Struct {
  external UnnamedUnion4 __sigaction_handler;

  external __sigset_t sa_mask;

  @ffi.Int()
  external int sa_flags;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> sa_restorer;
}

class UnnamedUnion4 extends ffi.Union {
  external __sighandler_t sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>>
      sa_sigaction;
}

class sigcontext extends ffi.Struct {
  @__uint64_t()
  external int r8;

  @__uint64_t()
  external int r9;

  @__uint64_t()
  external int r10;

  @__uint64_t()
  external int r11;

  @__uint64_t()
  external int r12;

  @__uint64_t()
  external int r13;

  @__uint64_t()
  external int r14;

  @__uint64_t()
  external int r15;

  @__uint64_t()
  external int rdi;

  @__uint64_t()
  external int rsi;

  @__uint64_t()
  external int rbp;

  @__uint64_t()
  external int rbx;

  @__uint64_t()
  external int rdx;

  @__uint64_t()
  external int rax;

  @__uint64_t()
  external int rcx;

  @__uint64_t()
  external int rsp;

  @__uint64_t()
  external int rip;

  @__uint64_t()
  external int eflags;

  @ffi.UnsignedShort()
  external int cs;

  @ffi.UnsignedShort()
  external int gs;

  @ffi.UnsignedShort()
  external int fs;

  @ffi.UnsignedShort()
  external int __pad0;

  @__uint64_t()
  external int err;

  @__uint64_t()
  external int trapno;

  @__uint64_t()
  external int oldmask;

  @__uint64_t()
  external int cr2;

  @ffi.Array.multi([8])
  external ffi.Array<__uint64_t> __reserved1;
}

typedef __uint64_t = ffi.UnsignedLong;

class stack_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @ffi.Int()
  external int ss_flags;

  @ffi.Size()
  external int ss_size;
}

class mcontext_t extends ffi.Struct {
  @ffi.Array.multi([23])
  external ffi.Array<greg_t> gregs;

  external fpregset_t fpregs;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedLongLong> __reserved1;
}

typedef greg_t = ffi.LongLong;
typedef fpregset_t = ffi.Pointer<_libc_fpstate>;

class _libc_fpstate extends ffi.Struct {
  @__uint16_t()
  external int cwd;

  @__uint16_t()
  external int swd;

  @__uint16_t()
  external int ftw;

  @__uint16_t()
  external int fop;

  @__uint64_t()
  external int rip;

  @__uint64_t()
  external int rdp;

  @__uint32_t()
  external int mxcsr;

  @__uint32_t()
  external int mxcr_mask;

  @ffi.Array.multi([8])
  external ffi.Array<_libc_fpxreg> _st;

  @ffi.Array.multi([16])
  external ffi.Array<_libc_xmmreg> _xmm;

  @ffi.Array.multi([24])
  external ffi.Array<__uint32_t> __glibc_reserved1;
}

typedef __uint16_t = ffi.UnsignedShort;

class _libc_fpxreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> significand;

  @ffi.UnsignedShort()
  external int exponent;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __glibc_reserved1;
}

class _libc_xmmreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__uint32_t> element;
}

class ucontext_t extends ffi.Struct {
  @ffi.UnsignedLong()
  external int uc_flags;

  external ffi.Pointer<ucontext_t> uc_link;

  external stack_t uc_stack;

  external mcontext_t uc_mcontext;

  external sigset_t uc_sigmask;

  external _libc_fpstate __fpregs_mem;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedLongLong> __ssp;
}

class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

class pthread_mutexattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

class pthread_condattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

class pthread_mutex_t extends ffi.Union {
  external __pthread_mutex_s __data;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int()
  external int __lock;

  @ffi.UnsignedInt()
  external int __count;

  @ffi.Int()
  external int __owner;

  @ffi.UnsignedInt()
  external int __nusers;

  @ffi.Int()
  external int __kind;

  @ffi.Short()
  external int __spins;

  @ffi.Short()
  external int __elision;

  external __pthread_list_t __list;
}

typedef __pthread_list_t = __pthread_internal_list;

class __pthread_internal_list extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_list> __prev;

  external ffi.Pointer<__pthread_internal_list> __next;
}

class pthread_cond_t extends ffi.Union {
  external __pthread_cond_s __data;

  @ffi.Array.multi([48])
  external ffi.Array<ffi.Char> __size;

  @ffi.LongLong()
  external int __align;
}

class __pthread_cond_s extends ffi.Struct {
  external __atomic_wide_counter __wseq;

  external __atomic_wide_counter __g1_start;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_size;

  @ffi.UnsignedInt()
  external int __g1_orig_size;

  @ffi.UnsignedInt()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_signals;
}

class __atomic_wide_counter extends ffi.Union {
  @ffi.UnsignedLongLong()
  external int __value64;

  external UnnamedStruct10 __value32;
}

class UnnamedStruct10 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __low;

  @ffi.UnsignedInt()
  external int __high;
}

class pthread_rwlock_t extends ffi.Union {
  external __pthread_rwlock_arch_t __data;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __readers;

  @ffi.UnsignedInt()
  external int __writers;

  @ffi.UnsignedInt()
  external int __wrphase_futex;

  @ffi.UnsignedInt()
  external int __writers_futex;

  @ffi.UnsignedInt()
  external int __pad3;

  @ffi.UnsignedInt()
  external int __pad4;

  @ffi.Int()
  external int __cur_writer;

  @ffi.Int()
  external int __shared;

  @ffi.SignedChar()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedChar> __pad1;

  @ffi.UnsignedLong()
  external int __pad2;

  @ffi.UnsignedInt()
  external int __flags;
}

class pthread_rwlockattr_t extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_barrier_t extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_barrierattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

typedef pthread_t = ffi.UnsignedLong;

class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

class timeval extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__suseconds_t()
  external int tv_usec;
}

typedef __suseconds_t = ffi.Long;

class fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__fd_mask> __fds_bits;
}

typedef __fd_mask = ffi.Long;

class random_data extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> fptr;

  external ffi.Pointer<ffi.Int32> rptr;

  external ffi.Pointer<ffi.Int32> state;

  @ffi.Int()
  external int rand_type;

  @ffi.Int()
  external int rand_deg;

  @ffi.Int()
  external int rand_sep;

  external ffi.Pointer<ffi.Int32> end_ptr;
}

class drand48_data extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __x;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __old_x;

  @ffi.UnsignedShort()
  external int __c;

  @ffi.UnsignedShort()
  external int __init;

  @ffi.UnsignedLongLong()
  external int __a;
}

typedef __compar_fn_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;
typedef locale_t = __locale_t;
typedef __locale_t = ffi.Pointer<__locale_struct>;

class __locale_struct extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<__locale_data>> __locales;

  external ffi.Pointer<ffi.UnsignedShort> __ctype_b;

  external ffi.Pointer<ffi.Int> __ctype_tolower;

  external ffi.Pointer<ffi.Int> __ctype_toupper;

  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<ffi.Char>> __names;
}

class __locale_data extends ffi.Opaque {}

class max_align_t extends ffi.Opaque {}

typedef FILE = _IO_FILE;

class _IO_FILE extends ffi.Struct {
  @ffi.Int()
  external int _flags;

  external ffi.Pointer<ffi.Char> _IO_read_ptr;

  external ffi.Pointer<ffi.Char> _IO_read_end;

  external ffi.Pointer<ffi.Char> _IO_read_base;

  external ffi.Pointer<ffi.Char> _IO_write_base;

  external ffi.Pointer<ffi.Char> _IO_write_ptr;

  external ffi.Pointer<ffi.Char> _IO_write_end;

  external ffi.Pointer<ffi.Char> _IO_buf_base;

  external ffi.Pointer<ffi.Char> _IO_buf_end;

  external ffi.Pointer<ffi.Char> _IO_save_base;

  external ffi.Pointer<ffi.Char> _IO_backup_base;

  external ffi.Pointer<ffi.Char> _IO_save_end;

  external ffi.Pointer<_IO_marker> _markers;

  external ffi.Pointer<_IO_FILE> _chain;

  @ffi.Int()
  external int _fileno;

  @ffi.Int()
  external int _flags2;

  @__off_t()
  external int _old_offset;

  @ffi.UnsignedShort()
  external int _cur_column;

  @ffi.SignedChar()
  external int _vtable_offset;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> _shortbuf;

  external ffi.Pointer<_IO_lock_t> _lock;

  @__off64_t()
  external int _offset;

  external ffi.Pointer<_IO_codecvt> _codecvt;

  external ffi.Pointer<_IO_wide_data> _wide_data;

  external ffi.Pointer<_IO_FILE> _freeres_list;

  external ffi.Pointer<ffi.Void> _freeres_buf;

  @ffi.Size()
  external int __pad5;

  @ffi.Int()
  external int _mode;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> _unused2;
}

class _IO_marker extends ffi.Opaque {}

typedef __off_t = ffi.Long;
typedef _IO_lock_t = ffi.Void;
typedef __off64_t = ffi.Long;

class _IO_codecvt extends ffi.Opaque {}

class _IO_wide_data extends ffi.Opaque {}

class __va_list_tag extends ffi.Struct {
  @ffi.UnsignedInt()
  external int gp_offset;

  @ffi.UnsignedInt()
  external int fp_offset;

  external ffi.Pointer<ffi.Void> overflow_arg_area;

  external ffi.Pointer<ffi.Void> reg_save_area;
}

typedef __ssize_t = ffi.Long;
typedef fpos_t = __fpos_t;
typedef __fpos_t = _G_fpos_t;

class _G_fpos_t extends ffi.Struct {
  @__off_t()
  external int __pos;

  external __mbstate_t __state;
}

class __mbstate_t extends ffi.Struct {
  @ffi.Int()
  external int __count;

  external UnnamedUnion5 __value;
}

class UnnamedUnion5 extends ffi.Union {
  @ffi.UnsignedInt()
  external int __wch;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __wchb;
}

abstract class spa_direction {
  static const int SPA_DIRECTION_INPUT = 0;
  static const int SPA_DIRECTION_OUTPUT = 1;
}

class spa_rectangle extends ffi.Struct {
  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;
}

class spa_point extends ffi.Struct {
  @ffi.Int32()
  external int x;

  @ffi.Int32()
  external int y;
}

class spa_region extends ffi.Struct {
  external spa_point position;

  external spa_rectangle size;
}

class spa_fraction extends ffi.Struct {
  @ffi.Uint32()
  external int num;

  @ffi.Uint32()
  external int denom;
}

/// \addtogroup spa_dict
/// \{
class spa_dict_item extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;
}

class spa_dict extends ffi.Struct {
  @ffi.Uint32()
  external int flags;

  @ffi.Uint32()
  external int n_items;

  external ffi.Pointer<spa_dict_item> items;
}

/// \addtogroup spa_handle
/// \{
class spa_handle extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Get the interface provided by \a handle with \a type.
  ///
  /// \a interface is always a struct spa_interface but depending on
  /// \a type, the struct might contain other information.
  ///
  /// \param handle a spa_handle
  /// \param type the interface type
  /// \param interface result to hold the interface.
  /// \return 0 on success
  /// -ENOTSUP when there are no interfaces
  /// -EINVAL when handle or info is NULL
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<spa_handle>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>> get_interface;

  /// Clean up the memory of \a handle. After this, \a handle should not be used
  /// anymore.
  ///
  /// \param handle a pointer to memory
  /// \return 0 on success
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int Function(ffi.Pointer<spa_handle>)>> clear;
}

/// This structure lists the information about available interfaces on
/// handles.
class spa_interface_info extends ffi.Struct {
  /// < the type of the interface, can be
  /// used to get the interface
  external ffi.Pointer<ffi.Char> type;
}

/// Extra supporting infrastructure passed to the init() function of
/// a factory. It can be extra information or interfaces such as logging.
class spa_support extends ffi.Struct {
  /// < the type of the support item
  external ffi.Pointer<ffi.Char> type;

  /// < specific data for the item
  external ffi.Pointer<ffi.Void> data;
}

class spa_handle_factory extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The name of the factory contains a logical name that describes
  /// the function of the handle. Other plugins might contain an alternative
  /// implementation with the same name.
  ///
  /// See utils/names.h for the list of standard names.
  ///
  /// Examples include:
  ///
  /// api.alsa.pcm.sink: an object to write PCM samples to an alsa PLAYBACK
  /// device
  /// api.v4l2.source: an object to read from a v4l2 source.
  external ffi.Pointer<ffi.Char> name;

  /// Extra information about the handles of this factory.
  external ffi.Pointer<spa_dict> info;

  /// Get the size of handles from this factory.
  ///
  /// \param factory a spa_handle_factory
  /// \param params extra parameters that determine the size of the
  /// handle.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Size Function(
                  ffi.Pointer<spa_handle_factory>, ffi.Pointer<spa_dict>)>>
      get_size;

  /// Initialize an instance of this factory. The caller should allocate
  /// memory at least size bytes and pass this as \a handle.
  ///
  /// \a support can optionally contain extra interfaces or data items that the
  /// plugin can use such as a logger.
  ///
  /// \param factory a spa_handle_factory
  /// \param handle a pointer to memory
  /// \param info extra handle specific information, usually obtained
  /// from a spa_device. This can be used to configure the handle.
  /// \param support support items
  /// \param n_support number of elements in \a support
  /// \return 0 on success
  /// < 0 errno type error
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<spa_handle_factory>,
              ffi.Pointer<spa_handle>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<spa_support>,
              ffi.Uint32)>> init;

  /// spa_handle_factory::enum_interface_info:
  /// \param factory: a #spa_handle_factory
  /// \param info: result to hold spa_interface_info.
  /// \param index: index to keep track of the enumeration, 0 for first item
  ///
  /// Enumerate the interface information for \a factory.
  ///
  /// \return 1 when an item is available
  /// 0 when no more items are available
  /// < 0 errno type error
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<spa_handle_factory>,
              ffi.Pointer<ffi.Pointer<spa_interface_info>>,
              ffi.Pointer<ffi.Uint32>)>> enum_interface_info;
}

/// \addtogroup pw_array
/// \{
class pw_array extends ffi.Struct {
  /// < pointer to array data
  external ffi.Pointer<ffi.Void> data;

  /// < length of array in bytes
  @ffi.Size()
  external int size;

  /// < number of allocated memory in \a data
  @ffi.Size()
  external int alloc;

  /// < number of bytes to extend with
  @ffi.Size()
  external int extend;
}

/// different parameter types that can be queried
abstract class spa_param_type {
  /// < invalid
  static const int SPA_PARAM_Invalid = 0;

  /// < property information as SPA_TYPE_OBJECT_PropInfo
  static const int SPA_PARAM_PropInfo = 1;

  /// < properties as SPA_TYPE_OBJECT_Props
  static const int SPA_PARAM_Props = 2;

  /// < available formats as SPA_TYPE_OBJECT_Format
  static const int SPA_PARAM_EnumFormat = 3;

  /// < configured format as SPA_TYPE_OBJECT_Format
  static const int SPA_PARAM_Format = 4;

  /// < buffer configurations as SPA_TYPE_OBJECT_ParamBuffers
  static const int SPA_PARAM_Buffers = 5;

  /// < allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta
  static const int SPA_PARAM_Meta = 6;

  /// < configurable IO areas as SPA_TYPE_OBJECT_ParamIO
  static const int SPA_PARAM_IO = 7;

  /// < profile enumeration as SPA_TYPE_OBJECT_ParamProfile
  static const int SPA_PARAM_EnumProfile = 8;

  /// < profile configuration as SPA_TYPE_OBJECT_ParamProfile
  static const int SPA_PARAM_Profile = 9;

  /// < port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig
  static const int SPA_PARAM_EnumPortConfig = 10;

  /// < port configuration as SPA_TYPE_OBJECT_ParamPortConfig
  static const int SPA_PARAM_PortConfig = 11;

  /// < routing enumeration as SPA_TYPE_OBJECT_ParamRoute
  static const int SPA_PARAM_EnumRoute = 12;

  /// < routing configuration as SPA_TYPE_OBJECT_ParamRoute
  static const int SPA_PARAM_Route = 13;

  /// < Control parameter, a SPA_TYPE_Sequence
  static const int SPA_PARAM_Control = 14;

  /// < latency reporting, a SPA_TYPE_OBJECT_ParamLatency
  static const int SPA_PARAM_Latency = 15;

  /// < processing latency, a SPA_TYPE_OBJECT_ParamProcessLatency
  static const int SPA_PARAM_ProcessLatency = 16;
}

/// information about a parameter
class spa_param_info extends ffi.Struct {
  /// < enum spa_param_type
  @ffi.Uint32()
  external int id;

  @ffi.Uint32()
  external int flags;

  /// < private user field. You can use this to keep
  /// state.
  @ffi.Uint32()
  external int user;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> padding;
}

/// properties for SPA_TYPE_OBJECT_ParamBuffers
abstract class spa_param_buffers {
  static const int SPA_PARAM_BUFFERS_START = 0;

  /// < number of buffers (Int)
  static const int SPA_PARAM_BUFFERS_buffers = 1;

  /// < number of data blocks per buffer (Int)
  static const int SPA_PARAM_BUFFERS_blocks = 2;

  /// < size of a data block memory (Int)
  static const int SPA_PARAM_BUFFERS_size = 3;

  /// < stride of data block memory (Int)
  static const int SPA_PARAM_BUFFERS_stride = 4;

  /// < alignment of data block memory (Int)
  static const int SPA_PARAM_BUFFERS_align = 5;

  /// < possible memory types (Int, mask of enum spa_data_type)
  static const int SPA_PARAM_BUFFERS_dataType = 6;
}

/// properties for SPA_TYPE_OBJECT_ParamMeta
abstract class spa_param_meta {
  static const int SPA_PARAM_META_START = 0;

  /// < the metadata, one of enum spa_meta_type (Id enum spa_meta_type)
  static const int SPA_PARAM_META_type = 1;

  /// < the expected maximum size the meta (Int)
  static const int SPA_PARAM_META_size = 2;
}

/// properties for SPA_TYPE_OBJECT_ParamIO
abstract class spa_param_io {
  static const int SPA_PARAM_IO_START = 0;

  /// < type ID, uniquely identifies the io area (Id enum spa_io_type)
  static const int SPA_PARAM_IO_id = 1;

  /// < size of the io area (Int)
  static const int SPA_PARAM_IO_size = 2;
}

abstract class spa_param_availability {
  /// < unknown availability
  static const int SPA_PARAM_AVAILABILITY_unknown = 0;

  /// < not available
  static const int SPA_PARAM_AVAILABILITY_no = 1;

  /// < available
  static const int SPA_PARAM_AVAILABILITY_yes = 2;
}

/// properties for SPA_TYPE_OBJECT_ParamProfile
abstract class spa_param_profile {
  static const int SPA_PARAM_PROFILE_START = 0;

  /// < profile index (Int)
  static const int SPA_PARAM_PROFILE_index = 1;

  /// < profile name (String)
  static const int SPA_PARAM_PROFILE_name = 2;

  /// < profile description (String)
  static const int SPA_PARAM_PROFILE_description = 3;

  /// < profile priority (Int)
  static const int SPA_PARAM_PROFILE_priority = 4;

  /// < availability of the profile
  /// (Id enum spa_param_availability)
  static const int SPA_PARAM_PROFILE_available = 5;

  /// < info (Struct(
  /// Int : n_items,
  /// (String : key,
  /// String : value)*))
  static const int SPA_PARAM_PROFILE_info = 6;

  /// < node classes provided by this profile
  /// (Struct(
  /// Int : number of items following
  /// Struct(
  /// String : class name (eg. "Audio/Source"),
  /// Int : number of nodes
  /// String : property (eg. "card.profile.devices"),
  /// Array of Int: device indexes
  /// )*))
  static const int SPA_PARAM_PROFILE_classes = 7;

  /// < If profile should be saved (Bool)
  static const int SPA_PARAM_PROFILE_save = 8;
}

abstract class spa_param_port_config_mode {
  /// < no configuration
  static const int SPA_PARAM_PORT_CONFIG_MODE_none = 0;

  /// < passthrough configuration
  static const int SPA_PARAM_PORT_CONFIG_MODE_passthrough = 1;

  /// < convert configuration
  static const int SPA_PARAM_PORT_CONFIG_MODE_convert = 2;

  /// < dsp configuration, depending on the external
  /// format. For audio, ports will be configured for
  /// the given number of channels with F32 format.
  static const int SPA_PARAM_PORT_CONFIG_MODE_dsp = 3;
}

/// properties for SPA_TYPE_OBJECT_ParamPortConfig
abstract class spa_param_port_config {
  static const int SPA_PARAM_PORT_CONFIG_START = 0;

  /// < direction, input/output (Id enum spa_direction)
  static const int SPA_PARAM_PORT_CONFIG_direction = 1;

  /// < (Id enum spa_param_port_config_mode) mode
  static const int SPA_PARAM_PORT_CONFIG_mode = 2;

  /// < (Bool) enable monitor output ports on input ports
  static const int SPA_PARAM_PORT_CONFIG_monitor = 3;

  /// < (Bool) enable control ports
  static const int SPA_PARAM_PORT_CONFIG_control = 4;

  /// < (Object) format filter
  static const int SPA_PARAM_PORT_CONFIG_format = 5;
}

/// properties for SPA_TYPE_OBJECT_ParamRoute
abstract class spa_param_route {
  static const int SPA_PARAM_ROUTE_START = 0;

  /// < index of the routing destination (Int)
  static const int SPA_PARAM_ROUTE_index = 1;

  /// < direction, input/output (Id enum spa_direction)
  static const int SPA_PARAM_ROUTE_direction = 2;

  /// < device id (Int)
  static const int SPA_PARAM_ROUTE_device = 3;

  /// < name of the routing destination (String)
  static const int SPA_PARAM_ROUTE_name = 4;

  /// < description of the destination (String)
  static const int SPA_PARAM_ROUTE_description = 5;

  /// < priority of the destination (Int)
  static const int SPA_PARAM_ROUTE_priority = 6;

  /// < availability of the destination
  /// (Id enum spa_param_availability)
  static const int SPA_PARAM_ROUTE_available = 7;

  /// < info (Struct(
  /// Int : n_items,
  /// (String : key,
  /// String : value)*))
  static const int SPA_PARAM_ROUTE_info = 8;

  /// < associated profile indexes (Array of Int)
  static const int SPA_PARAM_ROUTE_profiles = 9;

  /// < properties SPA_TYPE_OBJECT_Props
  static const int SPA_PARAM_ROUTE_props = 10;

  /// < associated device indexes (Array of Int)
  static const int SPA_PARAM_ROUTE_devices = 11;

  /// < profile id (Int)
  static const int SPA_PARAM_ROUTE_profile = 12;

  /// < If route should be saved (Bool)
  static const int SPA_PARAM_ROUTE_save = 13;
}

/// properties for SPA_TYPE_OBJECT_ParamLatency
abstract class spa_param_latency {
  static const int SPA_PARAM_LATENCY_START = 0;

  /// < direction, input/output (Id enum spa_direction)
  static const int SPA_PARAM_LATENCY_direction = 1;

  /// < min latency relative to quantum (Float)
  static const int SPA_PARAM_LATENCY_minQuantum = 2;

  /// < max latency relative to quantum (Float)
  static const int SPA_PARAM_LATENCY_maxQuantum = 3;

  /// < min latency (Int) relative to rate
  static const int SPA_PARAM_LATENCY_minRate = 4;

  /// < max latency (Int) relative to rate
  static const int SPA_PARAM_LATENCY_maxRate = 5;

  /// < min latency (Long) in nanoseconds
  static const int SPA_PARAM_LATENCY_minNs = 6;

  /// < max latency (Long) in nanoseconds
  static const int SPA_PARAM_LATENCY_maxNs = 7;
}

/// properties for SPA_TYPE_OBJECT_ParamProcessLatency
abstract class spa_param_process_latency {
  static const int SPA_PARAM_PROCESS_LATENCY_START = 0;

  /// < latency relative to quantum (Float)
  static const int SPA_PARAM_PROCESS_LATENCY_quantum = 1;

  /// < latency (Int) relative to rate
  static const int SPA_PARAM_PROCESS_LATENCY_rate = 2;

  /// < latency (Long) in nanoseconds
  static const int SPA_PARAM_PROCESS_LATENCY_ns = 3;
}

abstract class spa_param_bitorder {
  /// < unknown bitorder
  static const int SPA_PARAM_BITORDER_unknown = 0;

  /// < most significant bit
  static const int SPA_PARAM_BITORDER_msb = 1;

  /// < least significant bit
  static const int SPA_PARAM_BITORDER_lsb = 2;
}

/// \addtogroup spa_list List
/// \{
class spa_list extends ffi.Struct {
  external ffi.Pointer<spa_list> next;

  external ffi.Pointer<spa_list> prev;
}

/// \struct spa_callbacks
/// Callbacks, contains the structure with functions and the data passed
/// to the functions.  The structure should also contain a version field that
/// is checked.
class spa_callbacks extends ffi.Struct {
  external ffi.Pointer<ffi.Void> funcs;

  external ffi.Pointer<ffi.Void> data;
}

/// \struct spa_interface
class spa_interface extends ffi.Struct {
  external ffi.Pointer<ffi.Char> type;

  @ffi.Uint32()
  external int version;

  external spa_callbacks cb;
}

/// \struct spa_hook_list
/// A list of hooks. This struct is primarily used by
/// implementation that use multiple caller-provided \ref spa_hook.
class spa_hook_list extends ffi.Struct {
  external spa_list list;
}

/// \struct spa_hook
/// A hook, contains the structure with functions and the data passed
/// to the functions.
///
/// A hook should be treated as opaque by the caller.
class spa_hook extends ffi.Struct {
  external spa_list link;

  external spa_callbacks cb;

  /// callback and data for the hook list, private to the
  /// hook_list implementor
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<spa_hook>)>>
      removed;

  external ffi.Pointer<ffi.Void> priv;
}

/// \addtogroup pw_proxy
/// \{
class pw_proxy extends ffi.Opaque {}

/// \addtogroup pw_protocol
/// \{
class pw_protocol extends ffi.Opaque {}

/// \addtogroup pw_context
/// @{
class pw_context extends ffi.Opaque {}

class pw_global extends ffi.Opaque {}

class pw_impl_client extends ffi.Opaque {}

class pw_core extends ffi.Opaque {}

class pw_registry extends ffi.Opaque {}

/// The core information. Extra information may be added in later versions,
/// clients must not assume a constant struct size
class pw_core_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < a random cookie for identifying this instance of PipeWire
  @ffi.Uint32()
  external int cookie;

  /// < name of the user that started the core
  external ffi.Pointer<ffi.Char> user_name;

  /// < name of the machine the core is running on
  external ffi.Pointer<ffi.Char> host_name;

  /// < version of the core
  external ffi.Pointer<ffi.Char> version;

  /// < name of the core
  external ffi.Pointer<ffi.Char> name;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < extra properties
  external ffi.Pointer<spa_dict> props;
}

/// \addtogroup pw_properties
/// \{
class pw_properties extends ffi.Struct {
  /// < dictionary of key/values
  external spa_dict dict;

  /// < extra flags
  @ffi.Uint32()
  external int flags;
}

/// \struct pw_core_events
/// \brief Core events
class pw_core_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify new core info
  ///
  /// This event is emitted when first bound to the core or when the
  /// hello method is called.
  ///
  /// \param info new core info
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_core_info>)>> info;

  /// Emit a done event
  ///
  /// The done event is emitted as a result of a sync method with the
  /// same seq number.
  ///
  /// \param seq the seq number passed to the sync method call
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Int)>> done;

  /// Emit a ping event
  ///
  /// The client should reply with a pong reply with the same seq
  /// number.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Int)>> ping;

  /// Fatal error event
  ///
  /// The error event is sent out when a fatal (non-recoverable)
  /// error has occurred. The id argument is the proxy object where
  /// the error occurred, most often in response to a request to that
  /// object. The message is a brief description of the error,
  /// for (debugging) convenience.
  ///
  /// This event is usually also emitted on the proxy object with
  /// \a id.
  ///
  /// \param id object where the error occurred
  /// \param seq the sequence number that generated the error
  /// \param res error code
  /// \param message error description
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Char>)>> error;

  /// Remove an object ID
  ///
  /// This event is used internally by the object ID management
  /// logic. When a client deletes an object, the server will send
  /// this event to acknowledge that it has seen the delete request.
  /// When the client receives this event, it will know that it can
  /// safely reuse the object ID.
  ///
  /// \param id deleted object ID
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32)>> remove_id;

  /// Notify an object binding
  ///
  /// This event is emitted when a local object ID is bound to a
  /// global ID. It is emitted before the global becomes visible in the
  /// registry.
  ///
  /// \param id bound object ID
  /// \param global_id the global id bound to
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32)>>
      bound_id;

  /// Add memory for a client
  ///
  /// Memory is given to a client as \a fd of a certain
  /// memory \a type.
  ///
  /// Further references to this fd will be made with the per memory
  /// unique identifier \a id.
  ///
  /// \param id the unique id of the memory
  /// \param type the memory type, one of enum spa_data_type
  /// \param fd the file descriptor
  /// \param flags extra flags
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32,
              ffi.Int, ffi.Uint32)>> add_mem;

  /// Remove memory for a client
  ///
  /// \param id the memory id to remove
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32)>> remove_mem;
}

/// \struct pw_core_methods
/// \brief Core methods
///
/// The core global object. This is a singleton object used for
/// creating new objects in the remote PipeWire instance. It is
/// also used for internal features.
class pw_core_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_core_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;

  /// Start a conversation with the server. This will send
  /// the core info and will destroy all resources for the client
  /// (except the core and client resource).
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32)>> hello;

  /// Do server roundtrip
  ///
  /// Ask the server to emit the 'done' event with \a seq.
  ///
  /// Since methods are handled in-order and events are delivered
  /// in-order, this can be used as a barrier to ensure all previous
  /// methods and the resulting events have been handled.
  ///
  /// \param seq the seq number passed to the done event
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Int)>> sync1;

  /// Reply to a server ping event.
  ///
  /// Reply to the server ping event with the same seq.
  ///
  /// \param seq the seq number received in the ping event
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Int)>> pong;

  /// Fatal error event
  ///
  /// The error method is sent out when a fatal (non-recoverable)
  /// error has occurred. The id argument is the proxy object where
  /// the error occurred, most often in response to an event on that
  /// object. The message is a brief description of the error,
  /// for (debugging) convenience.
  ///
  /// This method is usually also emitted on the resource object with
  /// \a id.
  ///
  /// \param id object where the error occurred
  /// \param res error code
  /// \param message error description
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Char>)>> error;

  /// Get the registry object
  ///
  /// Create a registry object that allows the client to list and bind
  /// the global objects available from the PipeWire server
  /// \param version the client version
  /// \param user_data_size extra size
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<pw_registry> Function(
              ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Size)>> get_registry;

  /// Create a new object on the PipeWire server from a factory.
  ///
  /// \param factory_name the factory name to use
  /// \param type the interface to bind to
  /// \param version the version of the interface
  /// \param props extra properties
  /// \param user_data_size extra size
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint32,
              ffi.Pointer<spa_dict>,
              ffi.Size)>> create_object;

  /// Destroy an resource
  ///
  /// Destroy the server resource for the given proxy.
  ///
  /// \param obj the proxy to destroy
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
      destroy;
}

/// Registry events
class pw_registry_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify of a new global object
  ///
  /// The registry emits this event when a new global object is
  /// available.
  ///
  /// \param id the global object id
  /// \param permissions the permissions of the object
  /// \param type the type of the interface
  /// \param version the version of the interface
  /// \param props extra properties of the global
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Uint32,
              ffi.Pointer<spa_dict>)>> global;

  /// Notify of a global object removal
  ///
  /// Emitted when a global object was removed from the registry.
  /// If the client has any bindings to the global, it should destroy
  /// those.
  ///
  /// \param id the id of the global that was removed
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32)>> global_remove;
}

/// Registry methods
class pw_registry_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_registry_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;

  /// Bind to a global object
  ///
  /// Bind to the global object with \a id and use the client proxy
  /// with new_id as the proxy. After this call, methods can be
  /// send to the remote global object and events can be received
  ///
  /// \param id the global id to bind to
  /// \param type the interface type to bind to
  /// \param version the interface version to use
  /// \returns the new object
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
              ffi.Pointer<ffi.Char>, ffi.Uint32, ffi.Size)>> bind;

  /// Attempt to destroy a global object
  ///
  /// Try to destroy the global object.
  ///
  /// \param id the global id to destroy
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32)>> destroy;
}

class pw_client extends ffi.Opaque {}

/// A memory pool is a collection of pw_memblocks
class pw_mempool extends ffi.Struct {
  external ffi.Pointer<pw_properties> props;
}

class itimerspec extends ffi.Struct {
  external timespec it_interval;

  external timespec it_value;
}

class tm extends ffi.Struct {
  @ffi.Int()
  external int tm_sec;

  @ffi.Int()
  external int tm_min;

  @ffi.Int()
  external int tm_hour;

  @ffi.Int()
  external int tm_mday;

  @ffi.Int()
  external int tm_mon;

  @ffi.Int()
  external int tm_year;

  @ffi.Int()
  external int tm_wday;

  @ffi.Int()
  external int tm_yday;

  @ffi.Int()
  external int tm_isdst;

  @ffi.Long()
  external int tm_gmtoff;

  external ffi.Pointer<ffi.Char> tm_zone;
}

typedef clock_t = __clock_t;
typedef time_t = __time_t;
typedef clockid_t = __clockid_t;
typedef __clockid_t = ffi.Int;
typedef pid_t = __pid_t;
typedef timer_t = __timer_t;
typedef __timer_t = ffi.Pointer<ffi.Void>;

class spa_system extends ffi.Struct {
  external spa_interface iface;
}

class spa_poll_event extends ffi.Struct {
  @ffi.Uint32()
  external int events;

  external ffi.Pointer<ffi.Void> data;
}

class spa_system_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// read/write/ioctl
  external ffi.Pointer<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<ffi.Void>, ffi.Size)>> read;

  external ffi.Pointer<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<ffi.Void>, ffi.Size)>> write;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.UnsignedLong)>> ioctl;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int)>>
      close;

  /// clock
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Int, ffi.Pointer<timespec>)>>
      clock_gettime;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Int, ffi.Pointer<timespec>)>>
      clock_getres;

  /// poll
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int)>>
      pollfd_create;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int, ffi.Uint32,
              ffi.Pointer<ffi.Void>)>> pollfd_add;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int, ffi.Uint32,
              ffi.Pointer<ffi.Void>)>> pollfd_mod;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)>>
      pollfd_del;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<spa_poll_event>, ffi.Int, ffi.Int)>> pollfd_wait;

  /// timers
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)>>
      timerfd_create;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<itimerspec>,
              ffi.Pointer<itimerspec>)>> timerfd_settime;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Int, ffi.Pointer<itimerspec>)>>
      timerfd_gettime;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Int, ffi.Pointer<ffi.Uint64>)>>
      timerfd_read;

  /// events
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int)>>
      eventfd_create;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint64)>>
      eventfd_write;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Int, ffi.Pointer<ffi.Uint64>)>>
      eventfd_read;

  /// signals
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)>>
      signalfd_create;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Int, ffi.Pointer<ffi.Int>)>>
      signalfd_read;
}

typedef ssize_t = __ssize_t;

class spa_loop extends ffi.Struct {
  external spa_interface iface;
}

class spa_loop_control extends ffi.Struct {
  external spa_interface iface;
}

class spa_loop_utils extends ffi.Struct {
  external spa_interface iface;
}

class spa_source extends ffi.Struct {
  external ffi.Pointer<spa_loop> loop;

  external spa_source_func_t func;

  external ffi.Pointer<ffi.Void> data;

  @ffi.Int()
  external int fd;

  @ffi.Uint32()
  external int mask;

  @ffi.Uint32()
  external int rmask;

  /// private data for the loop implementer
  external ffi.Pointer<ffi.Void> priv;
}

typedef spa_source_func_t = ffi
    .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<spa_source>)>>;

/// Register sources and work items to an event loop
class spa_loop_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// add a source to the loop
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<spa_source>)>>
      add_source;

  /// update the source io mask
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<spa_source>)>>
      update_source;

  /// remove a source from the loop
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<spa_source>)>>
      remove_source;

  /// invoke a function in the context of this loop
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              spa_invoke_func_t,
              ffi.Uint32,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>> invoke;
}

typedef spa_invoke_func_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<spa_loop>, ffi.Bool, ffi.Uint32,
            ffi.Pointer<ffi.Void>, ffi.Size, ffi.Pointer<ffi.Void>)>>;

/// Control hooks. These hooks can't be removed from their
/// callbacks and must be removed from a safe place (when the loop
/// is not running or when it is locked).
class spa_loop_control_hooks extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Executed right before waiting for events. It is typically used to
  /// release locks.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      before;

  /// Executed right after waiting for events. It is typically used to
  /// reacquire locks.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      after;
}

/// Control an event loop
class spa_loop_control_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi
          .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      get_fd;

  /// Add a hook
  /// \param ctrl the control to change
  /// \param hooks the hooks to add
  ///
  /// Adds hooks to the loop controlled by \a ctrl.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<spa_loop_control_hooks>,
              ffi.Pointer<ffi.Void>)>> add_hook;

  /// Enter a loop
  /// \param ctrl the control
  ///
  /// Start an iteration of the loop. This function should be called
  /// before calling iterate and is typically used to capture the thread
  /// that this loop will run in.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      enter;

  /// Leave a loop
  /// \param ctrl the control
  ///
  /// Ends the iteration of a loop. This should be called after calling
  /// iterate.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      leave;

  /// Perform one iteration of the loop.
  /// \param ctrl the control
  /// \param timeout an optional timeout in milliseconds.
  /// 0 for no timeout, -1 for infinite timeout.
  ///
  /// This function will block
  /// up to \a timeout milliseconds and then dispatch the fds with activity.
  /// The number of dispatched fds is returned.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int)>>
      iterate;
}

/// Create sources for an event loop
class spa_loop_utils_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<spa_source> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Uint32,
              ffi.Bool,
              spa_source_io_func_t,
              ffi.Pointer<ffi.Void>)>> add_io;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<spa_source>, ffi.Uint32)>>
      update_io;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<spa_source> Function(ffi.Pointer<ffi.Void>, ffi.Bool,
              spa_source_idle_func_t, ffi.Pointer<ffi.Void>)>> add_idle;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<spa_source>, ffi.Bool)>>
      enable_idle;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<spa_source> Function(ffi.Pointer<ffi.Void>,
              spa_source_event_func_t, ffi.Pointer<ffi.Void>)>> add_event;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<spa_source>)>>
      signal_event;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<spa_source> Function(ffi.Pointer<ffi.Void>,
              spa_source_timer_func_t, ffi.Pointer<ffi.Void>)>> add_timer;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_source>,
              ffi.Pointer<timespec>,
              ffi.Pointer<timespec>,
              ffi.Bool)>> update_timer;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<spa_source> Function(ffi.Pointer<ffi.Void>, ffi.Int,
              spa_source_signal_func_t, ffi.Pointer<ffi.Void>)>> add_signal;

  /// destroy a source allocated with this interface. This function
  /// should only be called when the loop is not running or from the
  /// context of the running loop
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<spa_source>)>> destroy_source;
}

typedef spa_source_io_func_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint32)>>;
typedef spa_source_idle_func_t
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef spa_source_event_func_t = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint64)>>;
typedef spa_source_timer_func_t = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint64)>>;
typedef spa_source_signal_func_t = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int)>>;

/// \addtogroup pw_loop
/// \{
class pw_loop extends ffi.Struct {
  /// < system utils
  external ffi.Pointer<spa_system> system;

  /// < wrapped loop
  external ffi.Pointer<spa_loop> loop;

  /// < loop control
  external ffi.Pointer<spa_loop_control> control;

  /// < loop utils
  external ffi.Pointer<spa_loop_utils> utils;
}

/// context events emitted by the context object added with \ref pw_context_add_listener
class pw_context_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The context is being destroyed
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;

  /// The context is being freed
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      free;

  /// a new client object is added
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<pw_impl_client>)>>
      check_access;

  /// a new global object was added
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<pw_global>)>>
      global_added;

  /// a global object was removed
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<pw_global>)>>
      global_removed;
}

class pw_work_queue extends ffi.Opaque {}

/// data for registering export functions
class pw_export_type extends ffi.Struct {
  external spa_list link;

  external ffi.Pointer<ffi.Char> type;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<pw_proxy> Function(
              ffi.Pointer<pw_core>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<ffi.Void>,
              ffi.Size)>> func;
}

class sockaddr_un extends ffi.Struct {
  @sa_family_t()
  external int sun_family;

  @ffi.Array.multi([108])
  external ffi.Array<ffi.Char> sun_path;
}

typedef sa_family_t = ffi.UnsignedShort;

class spa_type_info extends ffi.Struct {
  @ffi.Uint32()
  external int type;

  @ffi.Uint32()
  external int parent;

  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<spa_type_info> values;
}

class spa_pod extends ffi.Struct {
  /// size of the body
  @ffi.Uint32()
  external int size;

  /// a basic id of enum spa_type
  @ffi.Uint32()
  external int type;
}

class spa_pod_bool extends ffi.Struct {
  external spa_pod pod;

  @ffi.Int32()
  external int value;

  @ffi.Int32()
  external int _padding;
}

class spa_pod_id extends ffi.Struct {
  external spa_pod pod;

  @ffi.Uint32()
  external int value;

  @ffi.Int32()
  external int _padding;
}

class spa_pod_int extends ffi.Struct {
  external spa_pod pod;

  @ffi.Int32()
  external int value;

  @ffi.Int32()
  external int _padding;
}

class spa_pod_long extends ffi.Struct {
  external spa_pod pod;

  @ffi.Int64()
  external int value;
}

class spa_pod_float extends ffi.Struct {
  external spa_pod pod;

  @ffi.Float()
  external double value;

  @ffi.Int32()
  external int _padding;
}

class spa_pod_double extends ffi.Struct {
  external spa_pod pod;

  @ffi.Double()
  external double value;
}

class spa_pod_string extends ffi.Struct {
  external spa_pod pod;
}

class spa_pod_bytes extends ffi.Struct {
  external spa_pod pod;
}

class spa_pod_rectangle extends ffi.Struct {
  external spa_pod pod;

  external spa_rectangle value;
}

class spa_pod_fraction extends ffi.Struct {
  external spa_pod pod;

  external spa_fraction value;
}

class spa_pod_bitmap extends ffi.Struct {
  external spa_pod pod;
}

class spa_pod_array_body extends ffi.Struct {
  external spa_pod child;
}

class spa_pod_array extends ffi.Struct {
  external spa_pod pod;

  external spa_pod_array_body body;
}

abstract class spa_choice_type {
  /// < no choice, first value is current
  static const int SPA_CHOICE_None = 0;

  /// < range: default, min, max
  static const int SPA_CHOICE_Range = 1;

  /// < range with step: default, min, max, step
  static const int SPA_CHOICE_Step = 2;

  /// < list: default, alternative,...
  static const int SPA_CHOICE_Enum = 3;

  /// < flags: default, possible flags,...
  static const int SPA_CHOICE_Flags = 4;
}

class spa_pod_choice_body extends ffi.Struct {
  /// < type of choice, one of enum spa_choice_type
  @ffi.Uint32()
  external int type;

  /// < extra flags
  @ffi.Uint32()
  external int flags;

  external spa_pod child;
}

class spa_pod_choice extends ffi.Struct {
  external spa_pod pod;

  external spa_pod_choice_body body;
}

class spa_pod_struct extends ffi.Struct {
  external spa_pod pod;
}

class spa_pod_object_body extends ffi.Struct {
  /// < one of enum spa_type
  @ffi.Uint32()
  external int type;

  /// < id of the object, depends on the object type
  @ffi.Uint32()
  external int id;
}

class spa_pod_object extends ffi.Struct {
  external spa_pod pod;

  external spa_pod_object_body body;
}

class spa_pod_pointer_body extends ffi.Struct {
  /// < pointer id, one of enum spa_type
  @ffi.Uint32()
  external int type;

  @ffi.Uint32()
  external int _padding;

  external ffi.Pointer<ffi.Void> value;
}

class spa_pod_pointer extends ffi.Struct {
  external spa_pod pod;

  external spa_pod_pointer_body body;
}

class spa_pod_fd extends ffi.Struct {
  external spa_pod pod;

  @ffi.Int64()
  external int value;
}

/// props can be inside an object
class spa_pod_prop extends ffi.Struct {
  /// < key of property, list of valid keys depends on the
  /// object type
  @ffi.Uint32()
  external int key;

  /// < flags for property
  @ffi.Uint32()
  external int flags;

  external spa_pod value;
}

/// controls can be inside a sequence and mark timed values
class spa_pod_control extends ffi.Struct {
  /// < media offset
  @ffi.Uint32()
  external int offset;

  /// < type of control, enum spa_control_type
  @ffi.Uint32()
  external int type;

  /// < control value, depends on type
  external spa_pod value;
}

class spa_pod_sequence_body extends ffi.Struct {
  @ffi.Uint32()
  external int unit;

  @ffi.Uint32()
  external int pad;
}

/// a sequence of timed controls
class spa_pod_sequence extends ffi.Struct {
  external spa_pod pod;

  external spa_pod_sequence_body body;
}

class pw_protocol_client extends ffi.Struct {
  /// < link in protocol client_list
  external spa_list link;

  /// < the owner protocol
  external ffi.Pointer<pw_protocol> protocol;

  external ffi.Pointer<pw_core> core;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_protocol_client>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int)>>,
              ffi.Pointer<ffi.Void>)>> connect;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_protocol_client>, ffi.Int, ffi.Bool)>> connect_fd;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_protocol_client>)>>
      steal_fd;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<pw_protocol_client>)>> disconnect;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<pw_protocol_client>)>> destroy;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<pw_protocol_client>, ffi.Bool)>>
      set_paused;
}

class pw_protocol_server extends ffi.Struct {
  /// < link in protocol server_list
  external spa_list link;

  /// < the owner protocol
  external ffi.Pointer<pw_protocol> protocol;

  external ffi.Pointer<pw_impl_core> core;

  /// < list of clients of this protocol
  external spa_list client_list;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<pw_protocol_server>)>> destroy;
}

class pw_impl_core extends ffi.Opaque {}

class pw_protocol_marshal extends ffi.Struct {
  /// < interface type
  external ffi.Pointer<ffi.Char> type;

  /// < version
  @ffi.Uint32()
  external int version;

  /// < version
  @ffi.Uint32()
  external int flags;

  /// < number of client methods
  @ffi.Uint32()
  external int n_client_methods;

  /// < number of server methods
  @ffi.Uint32()
  external int n_server_methods;

  external ffi.Pointer<ffi.Void> client_marshal;

  external ffi.Pointer<ffi.Void> server_demarshal;

  external ffi.Pointer<ffi.Void> server_marshal;

  external ffi.Pointer<ffi.Void> client_demarshal;
}

class pw_protocol_implementation extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<pw_protocol_client> Function(ffi.Pointer<pw_protocol>,
              ffi.Pointer<pw_core>, ffi.Pointer<spa_dict>)>> new_client;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<pw_protocol_server> Function(ffi.Pointer<pw_protocol>,
              ffi.Pointer<pw_impl_core>, ffi.Pointer<spa_dict>)>> add_server;
}

class pw_protocol_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;
}

/// Proxy events, use \ref pw_proxy_add_listener
class pw_proxy_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The proxy is destroyed
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;

  /// a proxy is bound to a global id
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32)>> bound;

  /// a proxy is removed from the server. Use pw_proxy_destroy to
  /// free the proxy.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      removed;

  /// a reply to a sync method completed
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int)>>
      done;

  /// an error occurred on the proxy
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Char>)>> error;
}

class pw_permission extends ffi.Struct {
  /// < id of object, PW_ID_ANY for default permission
  @ffi.Uint32()
  external int id;

  /// < bitmask of above permissions
  @ffi.Uint32()
  external int permissions;
}

/// The client information. Extra information can be added in later versions
class pw_client_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < extra properties
  external ffi.Pointer<spa_dict> props;
}

/// Client events
class pw_client_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify client info
  ///
  /// \param info info about the client
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_client_info>)>> info;

  /// Notify a client permission
  ///
  /// Event emitted as a result of the get_permissions method.
  ///
  /// \param default_permissions the default permissions
  /// \param index the index of the first permission entry
  /// \param n_permissions the number of permissions
  /// \param permissions the permissions
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<pw_permission>)>> permissions;
}

/// Client methods
class pw_client_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_client_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;

  /// Send an error to a client
  ///
  /// \param id the global id to report the error on
  /// \param res an errno style error code
  /// \param message an error string
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Int,
              ffi.Pointer<ffi.Char>)>> error;

  /// Update client properties
  ///
  /// \param props new properties
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<spa_dict>)>>
      update_properties;

  /// Get client permissions
  ///
  /// A permissions event will be emitted with the permissions.
  ///
  /// \param index the first index to query, 0 for first
  /// \param num the maximum number of items to get
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32)>>
      get_permissions;

  /// Manage the permissions of the global objects for this
  /// client
  ///
  /// Update the permissions of the global objects using the
  /// provided array with permissions
  ///
  /// Globals can use the default permissions or can have specific
  /// permissions assigned to them.
  ///
  /// \param n_permissions number of permissions
  /// \param permissions array of permissions
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
              ffi.Pointer<pw_permission>)>> update_permissions;
}

class pw_device extends ffi.Opaque {}

/// The device information. Extra information can be added in later versions
class pw_device_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < extra properties
  external ffi.Pointer<spa_dict> props;

  /// < parameters
  external ffi.Pointer<spa_param_info> params;

  /// < number of items in \a params
  @ffi.Uint32()
  external int n_params;
}

/// Device events
class pw_device_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify device info
  ///
  /// \param info info about the device
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_device_info>)>> info;

  /// Notify a device param
  ///
  /// Event emitted as a result of the enum_params method.
  ///
  /// \param seq the sequence number of the request
  /// \param id the param id
  /// \param index the param index
  /// \param next the param index of the next param
  /// \param param the parameter
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Pointer<spa_pod>)>> param;
}

/// Device methods
class pw_device_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_device_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;

  /// Subscribe to parameter changes
  ///
  /// Automatically emit param events for the given ids when
  /// they are changed.
  ///
  /// \param ids an array of param ids
  /// \param n_ids the number of ids in \a ids
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Uint32>, ffi.Uint32)>>
      subscribe_params;

  /// Enumerate device parameters
  ///
  /// Start enumeration of device parameters. For each param, a
  /// param event will be emitted.
  ///
  /// \param seq a sequence number to place in the reply
  /// \param id the parameter id to enum or PW_ID_ANY for all
  /// \param start the start index or 0 for the first param
  /// \param num the maximum number of params to retrieve
  /// \param filter a param filter or NULL
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Pointer<spa_pod>)>> enum_params;

  /// Set a parameter on the device
  ///
  /// \param id the parameter id to set
  /// \param flags extra parameter flags
  /// \param param the parameter to set
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<spa_pod>)>> set_param;
}

/// \addtogroup spa_buffer
/// \{
abstract class spa_meta_type {
  static const int SPA_META_Invalid = 0;

  /// < struct spa_meta_header
  static const int SPA_META_Header = 1;

  /// < struct spa_meta_region with cropping data
  static const int SPA_META_VideoCrop = 2;

  /// < array of struct spa_meta_region with damage, where an invalid entry or end-of-array marks the end.
  static const int SPA_META_VideoDamage = 3;

  /// < struct spa_meta_bitmap
  static const int SPA_META_Bitmap = 4;

  /// < struct spa_meta_cursor
  static const int SPA_META_Cursor = 5;

  /// < metadata contains a spa_meta_control
  /// associated with the data
  static const int SPA_META_Control = 6;

  /// < don't write to buffer when count > 0
  static const int SPA_META_Busy = 7;

  /// < not part of ABI/API
  static const int _SPA_META_LAST = 8;
}

/// A metadata element.
///
/// This structure is available on the buffer structure and contains
/// the type of the metadata and a pointer/size to the actual metadata
/// itself.
class spa_meta extends ffi.Struct {
  /// < metadata type, one of enum spa_meta_type
  @ffi.Uint32()
  external int type;

  /// < size of metadata
  @ffi.Uint32()
  external int size;

  /// < pointer to metadata
  external ffi.Pointer<ffi.Void> data;
}

/// Describes essential buffer header metadata such as flags and
/// timestamps.
class spa_meta_header extends ffi.Struct {
  /// < flags
  @ffi.Uint32()
  external int flags;

  /// < offset in current cycle
  @ffi.Uint32()
  external int offset;

  /// < presentation timestamp in nanoseconds
  @ffi.Int64()
  external int pts;

  /// < decoding timestamp as a difference with pts
  @ffi.Int64()
  external int dts_offset;

  /// < sequence number, increments with a
  /// media specific frequency
  @ffi.Uint64()
  external int seq;
}

/// metadata structure for Region or an array of these for RegionArray
class spa_meta_region extends ffi.Struct {
  external spa_region region;
}

/// Bitmap information
///
/// This metadata contains a bitmap image in the given format and size.
/// It is typically used for cursor images or other small images that are
/// better transferred inline.
class spa_meta_bitmap extends ffi.Struct {
  /// < bitmap video format, one of enum spa_video_format. 0 is
  /// and invalid format and should be handled as if there is
  /// no new bitmap information.
  @ffi.Uint32()
  external int format;

  /// < width and height of bitmap
  external spa_rectangle size;

  /// < stride of bitmap data
  @ffi.Int32()
  external int stride;

  /// < offset of bitmap data in this structure. An offset of
  /// 0 means no image data (invisible), an offset >=
  /// sizeof(struct spa_meta_bitmap) contains valid bitmap
  /// info.
  @ffi.Uint32()
  external int offset;
}

/// Cursor information
///
/// Metadata to describe the position and appearance of a pointing device.
class spa_meta_cursor extends ffi.Struct {
  /// < cursor id. an id of 0 is an invalid id and means that
  /// there is no new cursor data
  @ffi.Uint32()
  external int id;

  /// < extra flags
  @ffi.Uint32()
  external int flags;

  /// < position on screen
  external spa_point position;

  /// < offsets for hotspot in bitmap, this field has no meaning
  /// when there is no valid bitmap (see below)
  external spa_point hotspot;

  /// < offset of bitmap meta in this structure. When the offset
  /// is 0, there is no new bitmap information. When the offset is
  /// >= sizeof(struct spa_meta_cursor) there is a
  /// struct spa_meta_bitmap at the offset.
  @ffi.Uint32()
  external int bitmap_offset;
}

/// a timed set of events associated with the buffer
class spa_meta_control extends ffi.Struct {
  external spa_pod_sequence sequence;
}

/// a busy counter for the buffer
class spa_meta_busy extends ffi.Struct {
  @ffi.Uint32()
  external int flags;

  /// < number of users busy with the buffer
  @ffi.Uint32()
  external int count;
}

/// \addtogroup spa_buffer
/// \{
abstract class spa_data_type {
  static const int SPA_DATA_Invalid = 0;

  /// < pointer to memory, the data field in
  /// struct spa_data is set.
  static const int SPA_DATA_MemPtr = 1;

  /// < generic fd, mmap to get to memory
  static const int SPA_DATA_MemFd = 2;

  /// < fd to dmabuf memory
  static const int SPA_DATA_DmaBuf = 3;

  /// < memory is identified with an id
  static const int SPA_DATA_MemId = 4;

  /// < not part of ABI
  static const int _SPA_DATA_LAST = 5;
}

/// Chunk of memory, can change for each buffer
class spa_chunk extends ffi.Struct {
  /// < offset of valid data. Should be taken
  /// modulo the data maxsize to get the offset
  /// in the data memory.
  @ffi.Uint32()
  external int offset;

  /// < size of valid data. Should be clamped to
  /// maxsize.
  @ffi.Uint32()
  external int size;

  /// < stride of valid data
  @ffi.Int32()
  external int stride;

  /// < chunk flags
  @ffi.Int32()
  external int flags;
}

/// Data for a buffer this stays constant for a buffer
class spa_data extends ffi.Struct {
  /// < memory type, one of enum spa_data_type, when
  /// allocating memory, the type contains a bitmask
  /// of allowed types. SPA_ID_INVALID is a special
  /// value for the allocator to indicate that the
  /// other side did not explicitly specify any
  /// supported data types. It should probably use
  /// a memory type that does not require special
  /// handling in addition to simple mmap/munmap.
  @ffi.Uint32()
  external int type;

  /// < data flags
  @ffi.Uint32()
  external int flags;

  /// < optional fd for data
  @ffi.Int64()
  external int fd;

  /// < offset to map fd at
  @ffi.Uint32()
  external int mapoffset;

  /// < max size of data
  @ffi.Uint32()
  external int maxsize;

  /// < optional data pointer
  external ffi.Pointer<ffi.Void> data;

  /// < valid chunk of memory
  external ffi.Pointer<spa_chunk> chunk;
}

/// A Buffer
class spa_buffer extends ffi.Struct {
  /// < number of metadata
  @ffi.Uint32()
  external int n_metas;

  /// < number of data members
  @ffi.Uint32()
  external int n_datas;

  /// < array of metadata
  external ffi.Pointer<spa_meta> metas;

  /// < array of data members
  external ffi.Pointer<spa_data> datas;
}

/// \addtogroup spa_pod
/// \{
class spa_event_body extends ffi.Struct {
  external spa_pod_object_body body;
}

class spa_event extends ffi.Struct {
  external spa_pod pod;

  external spa_event_body body;
}

/// object id of SPA_TYPE_EVENT_Node
abstract class spa_node_event {
  static const int SPA_NODE_EVENT_Error = 0;
  static const int SPA_NODE_EVENT_Buffering = 1;
  static const int SPA_NODE_EVENT_RequestRefresh = 2;

  /// < Ask the driver to start processing
  /// the graph
  static const int SPA_NODE_EVENT_RequestProcess = 3;
}

/// properties for SPA_TYPE_EVENT_Node
abstract class spa_event_node {
  static const int SPA_EVENT_NODE_START = 0;
}

/// \addtogroup spa_pod
/// \{
class spa_command_body extends ffi.Struct {
  external spa_pod_object_body body;
}

class spa_command extends ffi.Struct {
  external spa_pod pod;

  external spa_command_body body;
}

/// object id of SPA_TYPE_COMMAND_Node
abstract class spa_node_command {
  /// < suspend a node, this removes all configured
  /// formats and closes any devices
  static const int SPA_NODE_COMMAND_Suspend = 0;

  /// < pause a node. this makes it stop emitting
  /// scheduling events
  static const int SPA_NODE_COMMAND_Pause = 1;

  /// < start a node, this makes it start emitting
  /// scheduling events
  static const int SPA_NODE_COMMAND_Start = 2;
  static const int SPA_NODE_COMMAND_Enable = 3;
  static const int SPA_NODE_COMMAND_Disable = 4;
  static const int SPA_NODE_COMMAND_Flush = 5;
  static const int SPA_NODE_COMMAND_Drain = 6;
  static const int SPA_NODE_COMMAND_Marker = 7;

  /// < begin a set of parameter enumerations or
  /// configuration that require the device to
  /// remain opened, like query formats and then
  /// set a format
  static const int SPA_NODE_COMMAND_ParamBegin = 8;

  /// < end a transaction
  static const int SPA_NODE_COMMAND_ParamEnd = 9;

  /// < Sent to a driver when some other node emitted
  /// the RequestProcess event.
  static const int SPA_NODE_COMMAND_RequestProcess = 10;
}

class spa_node extends ffi.Struct {
  external spa_interface iface;
}

/// Node information structure
///
/// Contains the basic node information.
class spa_node_info extends ffi.Struct {
  @ffi.Uint32()
  external int max_input_ports;

  @ffi.Uint32()
  external int max_output_ports;

  @ffi.Uint64()
  external int change_mask;

  @ffi.Uint64()
  external int flags;

  /// < extra node properties
  external ffi.Pointer<spa_dict> props;

  /// < parameter information
  external ffi.Pointer<spa_param_info> params;

  /// < number of items in \a params
  @ffi.Uint32()
  external int n_params;
}

/// Port information structure
///
/// Contains the basic port information.
class spa_port_info extends ffi.Struct {
  @ffi.Uint64()
  external int change_mask;

  /// < port flags
  @ffi.Uint64()
  external int flags;

  /// < rate of sequence numbers on port
  external spa_fraction rate;

  /// < extra port properties
  external ffi.Pointer<spa_dict> props;

  /// < parameter information
  external ffi.Pointer<spa_param_info> params;

  /// < number of items in \a params
  @ffi.Uint32()
  external int n_params;
}

/// an error result
class spa_result_node_error extends ffi.Struct {
  external ffi.Pointer<ffi.Char> message;
}

/// the result of enum_params or port_enum_params.
class spa_result_node_params extends ffi.Struct {
  /// < id of parameter
  @ffi.Uint32()
  external int id;

  /// < index of parameter
  @ffi.Uint32()
  external int index;

  /// < next index of iteration
  @ffi.Uint32()
  external int next;

  /// < the result param
  external ffi.Pointer<spa_pod> param;
}

/// events from the spa_node.
///
/// All event are called from the main thread and multiple
/// listeners can be registered for the events with
/// spa_node_add_listener().
class spa_node_events extends ffi.Struct {
  /// < version of this structure
  @ffi.Uint32()
  external int version;

  /// Emitted when info changes
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<spa_node_info>)>> info;

  /// Emitted when port info changes, NULL when port is removed
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint32,
              ffi.Pointer<spa_port_info>)>> port_info;

  /// notify a result.
  ///
  /// Some methods will trigger a result event with an optional
  /// result of the given type. Look at the documentation of the
  /// method to know when to expect a result event.
  ///
  /// The result event can be called synchronously, as an event
  /// called from inside the method itself, in which case the seq
  /// number passed to the method will be passed unchanged.
  ///
  /// The result event will be called asynchronously when the
  /// method returned an async return value. In this case, the seq
  /// number in the result will match the async return value of
  /// the method call. Users should match the seq number from
  /// request to the reply.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int, ffi.Uint32,
              ffi.Pointer<ffi.Void>)>> result;

  /// \param node a spa_node
  /// \param event the event that was emitted
  ///
  /// This will be called when an out-of-bound event is notified
  /// on \a node.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<spa_event>)>>
      event;
}

/// Node callbacks
///
/// Callbacks are called from the real-time data thread. Only
/// one callback structure can be set on an spa_node.
class spa_node_callbacks extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// \param node a spa_node
  ///
  /// The node is ready for processing.
  ///
  /// When this function is NULL, synchronous operation is requested
  /// on the ports.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int)>>
      ready;

  /// \param node a spa_node
  /// \param port_id an input port_id
  /// \param buffer_id the buffer id to be reused
  ///
  /// The node has a buffer that can be reused.
  ///
  /// When this function is NULL, the buffers to reuse will be set in
  /// the io area of the input ports.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32)>>
      reuse_buffer;

  /// \param data user data
  /// \param trigger the timestamp in microseconds when the xrun happened
  /// \param delay the amount of microseconds of xrun.
  /// \param info an object with extra info (NULL for now)
  ///
  /// The node has encountered an over or underrun
  ///
  /// The info contains an object with more information
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint64, ffi.Uint64,
              ffi.Pointer<spa_pod>)>> xrun;
}

/// Node methods
class spa_node_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Adds an event listener on \a node.
  ///
  /// Setting the events will trigger the info event and a
  /// port_info event for each managed port on the new
  /// listener.
  ///
  /// \param node a #spa_node
  /// \param listener a listener
  /// \param events a struct \ref spa_node_events
  /// \param data data passed as first argument in functions of \a events
  /// \return 0 on success
  /// < 0 errno on error
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<spa_node_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;

  /// Set callbacks to on \a node.
  /// if \a callbacks is NULL, the current callbacks are removed.
  ///
  /// This function must be called from the main thread.
  ///
  /// All callbacks are called from the data thread.
  ///
  /// \param node a spa_node
  /// \param callbacks callbacks to set
  /// \return 0 on success
  /// -EINVAL when node is NULL
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_node_callbacks>,
              ffi.Pointer<ffi.Void>)>> set_callbacks;

  /// Perform a sync operation.
  ///
  /// This method will emit the result event with the given sequence
  /// number synchronously or with the returned async return value
  /// asynchronously.
  ///
  /// Because all methods are serialized in the node, this can be used
  /// to wait for completion of all previous method calls.
  ///
  /// \param seq a sequence number
  /// \return 0 on success
  /// -EINVAL when node is NULL
  /// an async result
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int)>>
      sync1;

  /// Enumerate the parameters of a node.
  ///
  /// Parameters are identified with an \a id. Some parameters can have
  /// multiple values, see the documentation of the parameter id.
  ///
  /// Parameters can be filtered by passing a non-NULL \a filter.
  ///
  /// The function will emit the result event up to \a max times with
  /// the result value. The seq in the result will either be the \a seq
  /// number when executed synchronously or the async return value of
  /// this function when executed asynchronously.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param node a \ref spa_node
  /// \param seq a sequence number to pass to the result event when
  /// this method is executed synchronously.
  /// \param id the param id to enumerate
  /// \param start the index of enumeration, pass 0 for the first item
  /// \param max the maximum number of parameters to enumerate
  /// \param filter and optional filter to use
  ///
  /// \return 0 when no more items can be iterated.
  /// -EINVAL when invalid arguments are given
  /// -ENOENT the parameter \a id is unknown
  /// -ENOTSUP when there are no parameters
  /// implemented on \a node
  /// an async return value when the result event will be
  /// emitted later.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Pointer<spa_pod>)>> enum_params;

  /// Set the configurable parameter in \a node.
  ///
  /// Usually, \a param will be obtained from enum_params and then
  /// modified but it is also possible to set another spa_pod
  /// as long as its keys and types match a supported object.
  ///
  /// Objects with property keys that are not known are ignored.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param node a \ref spa_node
  /// \param id the parameter id to configure
  /// \param flags additional flags
  /// \param param the parameter to configure
  ///
  /// \return 0 on success
  /// -EINVAL when node is NULL
  /// -ENOTSUP when there are no parameters implemented on \a node
  /// -ENOENT the parameter is unknown
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<spa_pod>)>> set_param;

  /// Configure the given memory area with \a id on \a node. This
  /// structure is allocated by the host and is used to exchange
  /// data and parameters with the node.
  ///
  /// Setting an \a io of NULL will disable the node io.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param id the id of the io area, the available ids can be
  /// enumerated with the node parameters.
  /// \param data a io area memory
  /// \param size the size of \a data
  /// \return 0 on success
  /// -EINVAL when invalid input is given
  /// -ENOENT when \a id is unknown
  /// -ENOSPC when \a size is too small
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
              ffi.Pointer<ffi.Void>, ffi.Size)>> set_io;

  /// Send a command to a node.
  ///
  /// Upon completion, a command might change the state of a node.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param node a  spa_node
  /// \param command a spa_command
  /// \return 0 on success
  /// -EINVAL when node or command is NULL
  /// -ENOTSUP when this node can't process commands
  /// -EINVAL \a command is an invalid command
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<spa_command>)>> send_command;

  /// Make a new port with \a port_id. The caller should use the lowest unused
  /// port id for the given \a direction.
  ///
  /// Port ids should be between 0 and max_ports as obtained from the info
  /// event.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param node a  spa_node
  /// \param direction a enum \ref spa_direction
  /// \param port_id an unused port id
  /// \param props extra properties
  /// \return 0 on success
  /// -EINVAL when node is NULL
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint32,
              ffi.Pointer<spa_dict>)>> add_port;

  /// Remove a port with \a port_id.
  ///
  /// \param node a  spa_node
  /// \param direction a enum \ref spa_direction
  /// \param port_id a port id
  /// \return 0 on success
  /// -EINVAL when node is NULL or when port_id is unknown or
  /// when the port can't be removed.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint32)>>
      remove_port;

  /// Enumerate all possible parameters of \a id on \a port_id of \a node
  /// that are compatible with \a filter.
  ///
  /// The result parameters can be queried and modified and ultimately be used
  /// to call port_set_param.
  ///
  /// The function will emit the result event up to \a max times with
  /// the result value. The seq in the result event will either be the
  /// \a seq number when executed synchronously or the async return
  /// value of this function when executed asynchronously.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param node a spa_node
  /// \param seq a sequence number to pass to the result event when
  /// this method is executed synchronously.
  /// \param direction an spa_direction
  /// \param port_id the port to query
  /// \param id the parameter id to query
  /// \param start the first index to query, 0 to get the first item
  /// \param max the maximum number of params to query
  /// \param filter a parameter filter or NULL for no filter
  ///
  /// \return 0 when no more items can be iterated.
  /// -EINVAL when invalid parameters are given
  /// -ENOENT when \a id is unknown
  /// an async return value when the result event will be
  /// emitted later.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<spa_pod>)>> port_enum_params;

  /// Set a parameter on \a port_id of \a node.
  ///
  /// When \a param is NULL, the parameter will be unset.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param node a struct \ref spa_node
  /// \param direction a enum \ref spa_direction
  /// \param port_id the port to configure
  /// \param id the parameter id to set
  /// \param flags optional flags
  /// \param param a struct \ref spa_pod with the parameter to set
  /// \return 0 on success
  /// 1 on success, the value of \a param might have been
  /// changed depending on \a flags and the final value can be found by
  /// doing port_enum_params.
  /// -EINVAL when node is NULL or invalid arguments are given
  /// -ESRCH when one of the mandatory param
  /// properties is not specified and SPA_NODE_PARAM_FLAG_FIXATE was
  /// not set in \a flags.
  /// -ESRCH when the type or size of a property is not correct.
  /// -ENOENT when the param id is not found
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Pointer<spa_pod>)>> port_set_param;

  /// Tell the port to use the given buffers
  ///
  /// When \a flags contains SPA_NODE_BUFFERS_FLAG_ALLOC, the data
  /// in the buffers should point to an array of at least 1 data entry
  /// with the desired supported type that will be filled by this function.
  ///
  /// The port should also have a spa_io_buffers io area configured to exchange
  /// the buffers with the port.
  ///
  /// For an input port, all the buffers will remain dequeued.
  /// Once a buffer has been queued on a port in the spa_io_buffers,
  /// it should not be reused until the reuse_buffer callback is notified
  /// or when the buffer has been returned in the spa_io_buffers of
  /// the port.
  ///
  /// For output ports, all buffers will be queued in the port. When process
  /// returns SPA_STATUS_HAVE_DATA, buffers are available in one or more
  /// of the spa_io_buffers areas.
  ///
  /// When a buffer can be reused, port_reuse_buffer() should be called or the
  /// buffer_id should be placed in the spa_io_buffers area before calling
  /// process.
  ///
  /// Passing NULL as \a buffers will remove the reference that the port has
  /// on the buffers.
  ///
  /// When this function returns async, use the spa_node_sync operation to
  /// wait for completion.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param object an object implementing the interface
  /// \param direction a port direction
  /// \param port_id a port id
  /// \param flags extra flags
  /// \param buffers an array of buffer pointers
  /// \param n_buffers number of elements in \a buffers
  /// \return 0 on success
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Pointer<spa_buffer>>,
              ffi.Uint32)>> port_use_buffers;

  /// Configure the given memory area with \a id on \a port_id. This
  /// structure is allocated by the host and is used to exchange
  /// data and parameters with the port.
  ///
  /// Setting an \a io of NULL will disable the port io.
  ///
  /// This function must be called from the main thread.
  ///
  /// \param direction a spa_direction
  /// \param port_id a port id
  /// \param id the id of the io area, the available ids can be
  /// enumerated with the port parameters.
  /// \param data a io area memory
  /// \param size the size of \a data
  /// \return 0 on success
  /// -EINVAL when invalid input is given
  /// -ENOENT when \a id is unknown
  /// -ENOSPC when \a size is too small
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint32,
              ffi.Uint32, ffi.Pointer<ffi.Void>, ffi.Size)>> port_set_io;

  /// Tell an output port to reuse a buffer.
  ///
  /// This function must be called from the data thread.
  ///
  /// \param node a spa_node
  /// \param port_id a port id
  /// \param buffer_id a buffer id to reuse
  /// \return 0 on success
  /// -EINVAL when node is NULL
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32)>>
      port_reuse_buffer;

  /// Process the node
  ///
  /// This function must be called from the data thread.
  ///
  /// Output io areas with SPA_STATUS_NEED_DATA will recycle the
  /// buffers if any.
  ///
  /// Input areas with SPA_STATUS_HAVE_DATA are consumed if possible
  /// and the status is set to SPA_STATUS_NEED_DATA or SPA_STATUS_OK.
  ///
  /// When the node has new output buffers, the SPA_STATUS_HAVE_DATA
  /// bit will be set.
  ///
  /// When the node can accept new input in the next cycle, the
  /// SPA_STATUS_NEED_DATA bit will be set.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      process;
}

/// Flags passed to \ref pw_mempool_alloc()
abstract class pw_memblock_flags {
  static const int PW_MEMBLOCK_FLAG_NONE = 0;

  /// < memory is readable
  static const int PW_MEMBLOCK_FLAG_READABLE = 1;

  /// < memory is writable
  static const int PW_MEMBLOCK_FLAG_WRITABLE = 2;

  /// < seal the fd
  static const int PW_MEMBLOCK_FLAG_SEAL = 4;

  /// < mmap the fd
  static const int PW_MEMBLOCK_FLAG_MAP = 8;

  /// < don't close fd
  static const int PW_MEMBLOCK_FLAG_DONT_CLOSE = 16;

  /// < don't notify events
  static const int PW_MEMBLOCK_FLAG_DONT_NOTIFY = 32;
  static const int PW_MEMBLOCK_FLAG_READWRITE = 3;
}

abstract class pw_memmap_flags {
  static const int PW_MEMMAP_FLAG_NONE = 0;

  /// < map in read mode
  static const int PW_MEMMAP_FLAG_READ = 1;

  /// < map in write mode
  static const int PW_MEMMAP_FLAG_WRITE = 2;

  /// < map the same area twice after each other,
  /// creating a circular ringbuffer
  static const int PW_MEMMAP_FLAG_TWICE = 4;

  /// < writes will be private
  static const int PW_MEMMAP_FLAG_PRIVATE = 8;

  /// < lock the memory into RAM
  static const int PW_MEMMAP_FLAG_LOCKED = 16;
  static const int PW_MEMMAP_FLAG_READWRITE = 3;
}

class pw_memchunk extends ffi.Opaque {}

/// Memory block structure
class pw_memblock extends ffi.Struct {
  /// < owner pool
  external ffi.Pointer<pw_mempool> pool;

  /// < unique id
  @ffi.Uint32()
  external int id;

  /// < refcount
  @ffi.Int()
  external int ref;

  /// < flags for the memory block on of enum pw_memblock_flags
  @ffi.Uint32()
  external int flags;

  /// < type of the fd, one of enum spa_data_type
  @ffi.Uint32()
  external int type;

  /// < fd
  @ffi.Int()
  external int fd;

  /// < size of memory
  @ffi.Uint32()
  external int size;

  /// < optional map when PW_MEMBLOCK_FLAG_MAP was given
  external ffi.Pointer<pw_memmap> map;
}

/// a mapped region of a pw_memblock
class pw_memmap extends ffi.Struct {
  /// < owner memblock
  external ffi.Pointer<pw_memblock> block;

  /// < mapped pointer
  external ffi.Pointer<ffi.Void> ptr;

  /// < flags for the mapping on of enum pw_memmap_flags
  @ffi.Uint32()
  external int flags;

  /// < offset in memblock
  @ffi.Uint32()
  external int offset;

  /// < size in memblock
  @ffi.Uint32()
  external int size;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> tag;
}

class pw_mempool_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// the pool is destroyed
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;

  /// a new memory block is added to the pool
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_memblock>)>> added;

  /// a memory block is removed from the pool
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_memblock>)>> removed;
}

/// parameters to map a memory range
class pw_map_range extends ffi.Struct {
  @ffi.Uint32()
  external int start;

  /// offset in first page with start of data
  @ffi.Uint32()
  external int offset;

  /// page aligned offset to map
  @ffi.Uint32()
  external int size;
}

class pw_buffers extends ffi.Struct {
  /// < allocated buffer memory
  external ffi.Pointer<pw_memblock> mem;

  /// < port buffers
  external ffi.Pointer<ffi.Pointer<spa_buffer>> buffers;

  /// < number of port buffers
  @ffi.Uint32()
  external int n_buffers;

  /// < flags
  @ffi.Uint32()
  external int flags;
}

class pw_factory extends ffi.Opaque {}

/// The factory information. Extra information can be added in later versions
class pw_factory_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < name the factory
  external ffi.Pointer<ffi.Char> name;

  /// < type of the objects created by this factory
  external ffi.Pointer<ffi.Char> type;

  /// < version of the objects
  @ffi.Uint32()
  external int version;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < the properties of the factory
  external ffi.Pointer<spa_dict> props;
}

/// Factory events
class pw_factory_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify factory info
  ///
  /// \param info info about the factory
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_factory_info>)>> info;
}

/// Factory methods
class pw_factory_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_factory_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;
}

abstract class spa_log_level {
  static const int SPA_LOG_LEVEL_NONE = 0;
  static const int SPA_LOG_LEVEL_ERROR = 1;
  static const int SPA_LOG_LEVEL_WARN = 2;
  static const int SPA_LOG_LEVEL_INFO = 3;
  static const int SPA_LOG_LEVEL_DEBUG = 4;
  static const int SPA_LOG_LEVEL_TRACE = 5;
}

class spa_log extends ffi.Struct {
  external spa_interface iface;

  /// Logging level, everything above this level is not logged
  @ffi.Int32()
  external int level;
}

/// \struct spa_log_topic
///
/// Identifier for a topic. Topics are string-based filters that logically
/// group messages together. An implementation may decide to filter different
/// topics on different levels, for example the "protocol" topic may require
/// debug level TRACE while the "core" topic defaults to debug level INFO.
///
/// spa_log_topics require a spa_log_methods version of 1 or higher.
class spa_log_topic extends ffi.Struct {
  /// the version of this topic. This can be used to expand this
  /// structure in the future
  @ffi.Uint32()
  external int version;

  /// The string identifier for the topic
  external ffi.Pointer<ffi.Char> topic;

  /// Logging level set for this topic
  @ffi.Int32()
  external int level;

  /// False if this topic follows the \ref spa_log level
  @ffi.Bool()
  external bool has_custom_level;
}

class spa_log_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Log a message with the given log level.
  ///
  /// \note If compiled with this header, this function is only called
  /// for implementations of version 0. For versions 1 and above, see
  /// logt() instead.
  ///
  /// \param log a spa_log
  /// \param level a spa_log_level
  /// \param file the file name
  /// \param line the line number
  /// \param func the function name
  /// \param fmt printf style format
  /// \param ... format arguments
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>> log;

  /// Log a message with the given log level.
  ///
  /// \note If compiled with this header, this function is only called
  /// for implementations of version 0. For versions 1 and above, see
  /// logtv() instead.
  ///
  /// \param log a spa_log
  /// \param level a spa_log_level
  /// \param file the file name
  /// \param line the line number
  /// \param func the function name
  /// \param fmt printf style format
  /// \param args format arguments
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>> logv;

  /// Log a message with the given log level for the given topic.
  ///
  /// \note Callers that do not use topic-based logging (version 0), the \a
  /// topic is NULL
  ///
  /// \param log a spa_log
  /// \param level a spa_log_level
  /// \param topic the topic for this message, may be NULL
  /// \param file the file name
  /// \param line the line number
  /// \param func the function name
  /// \param fmt printf style format
  /// \param ... format arguments
  ///
  /// \since 1
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int32,
              ffi.Pointer<spa_log_topic>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>> logt;

  /// Log a message with the given log level for the given topic.
  ///
  /// \note For callers that do not use topic-based logging (version 0),
  /// the \a topic is NULL
  ///
  /// \param log a spa_log
  /// \param level a spa_log_level
  /// \param topic the topic for this message, may be NULL
  /// \param file the file name
  /// \param line the line number
  /// \param func the function name
  /// \param fmt printf style format
  /// \param args format arguments
  ///
  /// \since 1
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int32,
              ffi.Pointer<spa_log_topic>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>> logtv;

  /// Initializes a \ref spa_log_topic to the correct logging level.
  ///
  /// \since 1
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<spa_log_topic>)>> topic_init;
}

class pw_link extends ffi.Opaque {}

/// \enum pw_link_state The different link states
abstract class pw_link_state {
  /// < the link is in error
  static const int PW_LINK_STATE_ERROR = -2;

  /// < the link is unlinked
  static const int PW_LINK_STATE_UNLINKED = -1;

  /// < the link is initialized
  static const int PW_LINK_STATE_INIT = 0;

  /// < the link is negotiating formats
  static const int PW_LINK_STATE_NEGOTIATING = 1;

  /// < the link is allocating buffers
  static const int PW_LINK_STATE_ALLOCATING = 2;

  /// < the link is paused
  static const int PW_LINK_STATE_PAUSED = 3;

  /// < the link is active
  static const int PW_LINK_STATE_ACTIVE = 4;
}

/// The link information. Extra information can be added in later versions
class pw_link_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < server side output node id
  @ffi.Uint32()
  external int output_node_id;

  /// < output port id
  @ffi.Uint32()
  external int output_port_id;

  /// < server side input node id
  @ffi.Uint32()
  external int input_node_id;

  /// < input port id
  @ffi.Uint32()
  external int input_port_id;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < the current state of the link
  @ffi.Int32()
  external int state;

  /// < an error reason if \a state is error
  external ffi.Pointer<ffi.Char> error;

  /// < format over link
  external ffi.Pointer<spa_pod> format;

  /// < the properties of the link
  external ffi.Pointer<spa_dict> props;
}

/// Link events
class pw_link_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify link info
  ///
  /// \param info info about the link
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_link_info>)>> info;
}

/// Link methods
class pw_link_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_link_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;
}

/// A main loop object
class pw_main_loop extends ffi.Opaque {}

/// Events of the main loop
class pw_main_loop_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Emitted when the main loop is destroyed
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;
}

/// \private
/// An entry in the map. This is used internally only. Each element in the
/// backing pw_array is a union pw_map_item. For real items, the data pointer
/// points to the item. If an element has been removed, pw_map->free_list
/// is the index of the most recently removed item. That item contains
/// the index of the next removed item until item->next is SPA_ID_INVALID.
///
/// The free list is prepended only, the last item to be removed will be the
/// first item to get re-used on the next insert.
class pw_map_item extends ffi.Union {
  /// next free index
  @uintptr_t()
  external int next;

  /// data of this item, must be an even address
  external ffi.Pointer<ffi.Void> data;
}

typedef uintptr_t = ffi.UnsignedLong;

/// A map. This struct should be treated as opaque by the caller.
class pw_map extends ffi.Struct {
  /// an array with the map items
  external pw_array items;

  /// first free index
  @ffi.Uint32()
  external int free_list;
}

class pw_module extends ffi.Opaque {}

/// The module information. Extra information can be added in later versions
class pw_module_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < name of the module
  external ffi.Pointer<ffi.Char> name;

  /// < filename of the module
  external ffi.Pointer<ffi.Char> filename;

  /// < arguments passed to the module
  external ffi.Pointer<ffi.Char> args;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < extra properties
  external ffi.Pointer<spa_dict> props;
}

/// Module events
class pw_module_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify module info
  ///
  /// \param info info about the module
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_module_info>)>> info;
}

/// Module methods
class pw_module_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_module_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;
}

class pw_node extends ffi.Opaque {}

/// \enum pw_node_state The different node states
abstract class pw_node_state {
  /// < error state
  static const int PW_NODE_STATE_ERROR = -1;

  /// < the node is being created
  static const int PW_NODE_STATE_CREATING = 0;

  /// < the node is suspended, the device might
  /// be closed
  static const int PW_NODE_STATE_SUSPENDED = 1;

  /// < the node is running but there is no active
  /// port
  static const int PW_NODE_STATE_IDLE = 2;

  /// < the node is running
  static const int PW_NODE_STATE_RUNNING = 3;
}

/// The node information. Extra information can be added in later versions
class pw_node_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < maximum number of inputs
  @ffi.Uint32()
  external int max_input_ports;

  /// < maximum number of outputs
  @ffi.Uint32()
  external int max_output_ports;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < number of inputs
  @ffi.Uint32()
  external int n_input_ports;

  /// < number of outputs
  @ffi.Uint32()
  external int n_output_ports;

  /// < the current state of the node
  @ffi.Int32()
  external int state;

  /// < an error reason if \a state is error
  external ffi.Pointer<ffi.Char> error;

  /// < the properties of the node
  external ffi.Pointer<spa_dict> props;

  /// < parameters
  external ffi.Pointer<spa_param_info> params;

  /// < number of items in \a params
  @ffi.Uint32()
  external int n_params;
}

/// Node events
class pw_node_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify node info
  ///
  /// \param info info about the node
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_node_info>)>> info;

  /// Notify a node param
  ///
  /// Event emitted as a result of the enum_params method.
  ///
  /// \param seq the sequence number of the request
  /// \param id the param id
  /// \param index the param index
  /// \param next the param index of the next param
  /// \param param the parameter
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Pointer<spa_pod>)>> param;
}

/// Node methods
class pw_node_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_node_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;

  /// Subscribe to parameter changes
  ///
  /// Automatically emit param events for the given ids when
  /// they are changed.
  ///
  /// \param ids an array of param ids
  /// \param n_ids the number of ids in \a ids
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Uint32>, ffi.Uint32)>>
      subscribe_params;

  /// Enumerate node parameters
  ///
  /// Start enumeration of node parameters. For each param, a
  /// param event will be emitted.
  ///
  /// \param seq a sequence number to place in the reply
  /// \param id the parameter id to enum or PW_ID_ANY for all
  /// \param start the start index or 0 for the first param
  /// \param num the maximum number of params to retrieve
  /// \param filter a param filter or NULL
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Pointer<spa_pod>)>> enum_params;

  /// Set a parameter on the node
  ///
  /// \param id the parameter id to set
  /// \param flags extra parameter flags
  /// \param param the parameter to set
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<spa_pod>)>> set_param;

  /// Send a command to the node
  ///
  /// \param command the command to send
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<spa_command>)>> send_command;
}

class pw_port extends ffi.Opaque {}

class pw_port_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < port direction
  @ffi.Int32()
  external int direction;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < the properties of the port
  external ffi.Pointer<spa_dict> props;

  /// < parameters
  external ffi.Pointer<spa_param_info> params;

  /// < number of items in \a params
  @ffi.Uint32()
  external int n_params;
}

/// Port events
class pw_port_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify port info
  ///
  /// \param info info about the port
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<pw_port_info>)>> info;

  /// Notify a port param
  ///
  /// Event emitted as a result of the enum_params method.
  ///
  /// \param seq the sequence number of the request
  /// \param id the param id
  /// \param index the param index
  /// \param next the param index of the next param
  /// \param param the parameter
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Pointer<spa_pod>)>> param;
}

/// Port methods
class pw_port_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_port_events>,
              ffi.Pointer<ffi.Void>)>> add_listener;

  /// Subscribe to parameter changes
  ///
  /// Automatically emit param events for the given ids when
  /// they are changed.
  ///
  /// \param ids an array of param ids
  /// \param n_ids the number of ids in \a ids
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Uint32>, ffi.Uint32)>>
      subscribe_params;

  /// Enumerate port parameters
  ///
  /// Start enumeration of port parameters. For each param, a
  /// param event will be emitted.
  ///
  /// \param seq a sequence number returned in the reply
  /// \param id the parameter id to enumerate
  /// \param start the start index or 0 for the first param
  /// \param num the maximum number of params to retrieve
  /// \param filter a param filter or NULL
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Pointer<spa_pod>)>> enum_params;
}

/// \addtogroup pw_stream
/// \{
class pw_stream extends ffi.Opaque {}

/// \enum pw_stream_state The state of a stream
abstract class pw_stream_state {
  /// < the stream is in error
  static const int PW_STREAM_STATE_ERROR = -1;

  /// < unconnected
  static const int PW_STREAM_STATE_UNCONNECTED = 0;

  /// < connection is in progress
  static const int PW_STREAM_STATE_CONNECTING = 1;

  /// < paused
  static const int PW_STREAM_STATE_PAUSED = 2;

  /// < streaming
  static const int PW_STREAM_STATE_STREAMING = 3;
}

class pw_buffer extends ffi.Struct {
  /// < the spa buffer
  external ffi.Pointer<spa_buffer> buffer;

  /// < user data attached to the buffer
  external ffi.Pointer<ffi.Void> user_data;

  /// < This field is set by the user and the sum of
  /// all queued buffer is returned in the time info
  @ffi.Uint64()
  external int size;
}

class pw_stream_control extends ffi.Struct {
  /// < name of the control
  external ffi.Pointer<ffi.Char> name;

  /// < extra flags (unused)
  @ffi.Uint32()
  external int flags;

  /// < default value
  @ffi.Float()
  external double def;

  /// < min value
  @ffi.Float()
  external double min;

  /// < max value
  @ffi.Float()
  external double max;

  /// < array of values
  external ffi.Pointer<ffi.Float> values;

  /// < number of values in array
  @ffi.Uint32()
  external int n_values;

  /// < max values that can be set on this control
  @ffi.Uint32()
  external int max_values;
}

/// A time structure
class pw_time extends ffi.Struct {
  /// < the monotonic time in nanoseconds
  @ffi.Int64()
  external int now;

  /// < the rate of \a ticks and delay
  external spa_fraction rate;

  /// < the ticks at \a now. This is the current time that
  /// the remote end is reading/writing.
  @ffi.Uint64()
  external int ticks;

  /// < delay to device, add to ticks to get the time of the
  /// device. Positive for INPUT streams and
  /// negative for OUTPUT streams.
  @ffi.Int64()
  external int delay;

  /// < data queued in the stream, this is the sum
  /// of the size fields in the pw_buffer that are
  /// currently queued
  @ffi.Uint64()
  external int queued;
}

/// Events for a stream. These events are always called from the mainloop
/// unless explicitly documented otherwise.
class pw_stream_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;

  /// when the stream state changes
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
              ffi.Pointer<ffi.Char>)>> state_changed;

  /// Notify information about a control.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
              ffi.Pointer<pw_stream_control>)>> control_info;

  /// when io changed on the stream.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
              ffi.Pointer<ffi.Void>, ffi.Uint32)>> io_changed;

  /// when a parameter changed
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint32, ffi.Pointer<spa_pod>)>>
      param_changed;

  /// when a new buffer was created for this stream
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<pw_buffer>)>>
      add_buffer;

  /// when a buffer was destroyed for this stream
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<pw_buffer>)>>
      remove_buffer;

  /// when a buffer can be queued (for playback streams) or
  /// dequeued (for capture streams). This is normally called from the
  /// mainloop but can also be called directly from the realtime data
  /// thread if the user is prepared to deal with this.
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      process;

  /// The stream is drained
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      drained;

  /// A command notify, Since 0.3.39:1
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<spa_command>)>> command;

  /// a trigger_process completed. Since version 0.3.40:2
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      trigger_done;
}

/// \enum pw_stream_flags Extra flags that can be used in \ref pw_stream_connect()
abstract class pw_stream_flags {
  /// < no flags
  static const int PW_STREAM_FLAG_NONE = 0;

  /// < try to automatically connect
  /// this stream
  static const int PW_STREAM_FLAG_AUTOCONNECT = 1;

  /// < start the stream inactive,
  /// pw_stream_set_active() needs to be
  /// called explicitly
  static const int PW_STREAM_FLAG_INACTIVE = 2;

  /// < mmap the buffers except DmaBuf
  static const int PW_STREAM_FLAG_MAP_BUFFERS = 4;

  /// < be a driver
  static const int PW_STREAM_FLAG_DRIVER = 8;

  /// < call process from the realtime
  /// thread. You MUST use RT safe functions
  /// in the process callback.
  static const int PW_STREAM_FLAG_RT_PROCESS = 16;

  /// < don't convert format
  static const int PW_STREAM_FLAG_NO_CONVERT = 32;

  /// < require exclusive access to the
  /// device
  static const int PW_STREAM_FLAG_EXCLUSIVE = 64;

  /// < don't try to reconnect this stream
  /// when the sink/source is removed
  static const int PW_STREAM_FLAG_DONT_RECONNECT = 128;

  /// < the application will allocate buffer
  /// memory. In the add_buffer event, the
  /// data of the buffer should be set
  static const int PW_STREAM_FLAG_ALLOC_BUFFERS = 256;

  /// < the output stream will not be scheduled
  /// automatically but _trigger_process()
  /// needs to be called. This can be used
  /// when the output of the stream depends
  /// on input from other streams.
  static const int PW_STREAM_FLAG_TRIGGER = 512;
}

/// \addtogroup pw_filter
/// \{
class pw_filter extends ffi.Opaque {}

/// Different IO area types
abstract class spa_io_type {
  static const int SPA_IO_Invalid = 0;

  /// < area to exchange buffers, struct spa_io_buffers
  static const int SPA_IO_Buffers = 1;

  /// < expected byte range, struct spa_io_range
  static const int SPA_IO_Range = 2;

  /// < area to update clock information, struct spa_io_clock
  static const int SPA_IO_Clock = 3;

  /// < latency reporting, struct spa_io_latency
  static const int SPA_IO_Latency = 4;

  /// < area for control messages, struct spa_io_sequence
  static const int SPA_IO_Control = 5;

  /// < area for notify messages, struct spa_io_sequence
  static const int SPA_IO_Notify = 6;

  /// < position information in the graph, struct spa_io_position
  static const int SPA_IO_Position = 7;

  /// < rate matching between nodes, struct spa_io_rate_match
  static const int SPA_IO_RateMatch = 8;

  /// < memory pointer, struct spa_io_memory
  static const int SPA_IO_Memory = 9;
}

/// IO area to exchange buffers.
///
/// A set of buffers should first be configured on the node/port.
/// Further references to those buffers will be made by using the
/// id of the buffer.
///
/// If status is SPA_STATUS_OK, the host should ignore
/// the io area.
///
/// If status is SPA_STATUS_NEED_DATA, the host should:
/// 1) recycle the buffer in buffer_id, if possible
/// 2) prepare a new buffer and place the id in buffer_id.
///
/// If status is SPA_STATUS_HAVE_DATA, the host should consume
/// the buffer in buffer_id and set the state to
/// SPA_STATUS_NEED_DATA when new data is requested.
///
/// If status is SPA_STATUS_STOPPED, some error occurred on the
/// port.
///
/// If status is SPA_STATUS_DRAINED, data from the io area was
/// used to drain.
///
/// Status can also be a negative errno value to indicate errors.
/// such as:
/// -EINVAL: buffer_id is invalid
/// -EPIPE: no more buffers available
class spa_io_buffers extends ffi.Struct {
  /// < the status code
  @ffi.Int32()
  external int status;

  /// < a buffer id
  @ffi.Uint32()
  external int buffer_id;
}

/// IO area to exchange a memory region
class spa_io_memory extends ffi.Struct {
  /// < the status code
  @ffi.Int32()
  external int status;

  /// < the size of \a data
  @ffi.Uint32()
  external int size;

  /// < a memory pointer
  external ffi.Pointer<ffi.Void> data;
}

/// A range, suitable for input ports that can suggest a range to output ports
class spa_io_range extends ffi.Struct {
  /// < offset in range
  @ffi.Uint64()
  external int offset;

  /// < minimum size of data
  @ffi.Uint32()
  external int min_size;

  /// < maximum size of data
  @ffi.Uint32()
  external int max_size;
}

/// Absolute time reporting.
///
/// Nodes that can report clocking information will receive this io block.
/// The application sets the id. This is usually set as part of the
/// position information but can also be set separately.
///
/// The clock counts the elapsed time according to the clock provider
/// since the provider was last started.
class spa_io_clock extends ffi.Struct {
  /// < clock flags
  @ffi.Uint32()
  external int flags;

  /// < unique clock id, set by application
  @ffi.Uint32()
  external int id;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> name;

  /// < time in nanoseconds against monotonic clock
  @ffi.Uint64()
  external int nsec;

  /// < rate for position/duration/delay
  external spa_fraction rate;

  /// < current position
  @ffi.Uint64()
  external int position;

  /// < duration of current cycle
  @ffi.Uint64()
  external int duration;

  /// < delay between position and hardware,
  /// positive for capture, negative for playback
  @ffi.Int64()
  external int delay;

  /// < rate difference between clock and monotonic time
  @ffi.Double()
  external double rate_diff;

  /// < estimated next wakeup time in nanoseconds
  @ffi.Uint64()
  external int next_nsec;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint32> padding;
}

/// the size of the video in this cycle
class spa_io_video_size extends ffi.Struct {
  /// < optional flags
  @ffi.Uint32()
  external int flags;

  /// < video stride in bytes
  @ffi.Uint32()
  external int stride;

  /// < the video size
  external spa_rectangle size;

  /// < the minimum framerate, the cycle duration is
  /// always smaller to ensure there is only one
  /// video frame per cycle.
  external spa_fraction framerate;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> padding;
}

/// latency reporting
class spa_io_latency extends ffi.Struct {
  /// < rate for min/max
  external spa_fraction rate;

  /// < min latency
  @ffi.Uint64()
  external int min;

  /// < max latency
  @ffi.Uint64()
  external int max;
}

/// control stream, io area for SPA_IO_Control and SPA_IO_Notify
class spa_io_sequence extends ffi.Struct {
  /// < sequence of timed events
  external spa_pod_sequence sequence;
}

/// bar and beat segment
class spa_io_segment_bar extends ffi.Struct {
  /// < extra flags
  @ffi.Uint32()
  external int flags;

  /// < offset in segment of this beat
  @ffi.Uint32()
  external int offset;

  /// < time signature numerator
  @ffi.Float()
  external double signature_num;

  /// < time signature denominator
  @ffi.Float()
  external double signature_denom;

  /// < beats per minute
  @ffi.Double()
  external double bpm;

  /// < current beat in segment
  @ffi.Double()
  external double beat;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint32> padding;
}

/// video frame segment
class spa_io_segment_video extends ffi.Struct {
  /// < flags
  @ffi.Uint32()
  external int flags;

  /// < offset in segment
  @ffi.Uint32()
  external int offset;

  external spa_fraction framerate;

  @ffi.Uint32()
  external int hours;

  @ffi.Uint32()
  external int minutes;

  @ffi.Uint32()
  external int seconds;

  @ffi.Uint32()
  external int frames;

  /// < 0 for progressive, 1 and 2 for interlaced
  @ffi.Uint32()
  external int field_count;

  @ffi.Array.multi([11])
  external ffi.Array<ffi.Uint32> padding;
}

/// A segment converts a running time to a segment (stream) position.
///
/// The segment position is valid when the current running time is between
/// start and start + duration. The position is then
/// calculated as:
///
/// (running time - start) * rate + position;
///
/// Support for looping is done by specifying the LOOPING flags with a
/// non-zero duration. When the running time reaches start + duration,
/// duration is added to start and the loop repeats.
///
/// Care has to be taken when the running time + clock.duration extends
/// past the start + duration from the segment; the user should correctly
/// wrap around and partially repeat the loop in the current cycle.
///
/// Extra information can be placed in the segment by setting the valid flags
/// and filling up the corresponding structures.
class spa_io_segment extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// < extra flags
  @ffi.Uint32()
  external int flags;

  /// < value of running time when this
  /// info is active. Can be in the future for
  /// pending changes. It does not have to be in
  /// exact multiples of the clock duration.
  @ffi.Uint64()
  external int start;

  /// < duration when this info becomes invalid expressed
  /// in running time. If the duration is 0, this
  /// segment extends to the next segment. If the
  /// segment becomes invalid and the looping flag is
  /// set, the segment repeats.
  @ffi.Uint64()
  external int duration;

  /// < overall rate of the segment, can be negative for
  /// backwards time reporting.
  @ffi.Double()
  external double rate;

  /// < The position when the running time == start.
  /// can be invalid when the owner of the extra segment
  /// information has not yet made the mapping.
  @ffi.Uint64()
  external int position;

  external spa_io_segment_bar bar;

  external spa_io_segment_video video;
}

abstract class spa_io_position_state {
  static const int SPA_IO_POSITION_STATE_STOPPED = 0;
  static const int SPA_IO_POSITION_STATE_STARTING = 1;
  static const int SPA_IO_POSITION_STATE_RUNNING = 2;
}

/// The position information adds extra meaning to the raw clock times.
///
/// It is set on all nodes and the clock id will contain the clock of the
/// driving node in the graph.
///
/// The position information contains 1 or more segments that convert the
/// raw clock times to a stream time. They are sorted based on their
/// start times, and thus the order in which they will activate in
/// the future. This makes it possible to look ahead in the scheduled
/// segments and anticipate the changes in the timeline.
class spa_io_position extends ffi.Struct {
  /// < clock position of driver, always valid and
  /// read only
  external spa_io_clock clock;

  /// < size of the video in the current cycle
  external spa_io_video_size video;

  /// < an offset to subtract from the clock position
  /// to get a running time. This is the time that
  /// the state has been in the RUNNING state and the
  /// time that should be used to compare the segment
  /// start values against.
  @ffi.Int64()
  external int offset;

  /// < one of enum spa_io_position_state
  @ffi.Uint32()
  external int state;

  /// < number of segments
  @ffi.Uint32()
  external int n_segments;

  @ffi.Array.multi([8])
  external ffi.Array<spa_io_segment> segments;
}

/// rate matching
class spa_io_rate_match extends ffi.Struct {
  /// < extra delay in samples for resampler
  @ffi.Uint32()
  external int delay;

  /// < requested input size for resampler
  @ffi.Uint32()
  external int size;

  /// < rate for resampler
  @ffi.Double()
  external double rate;

  /// < extra flags
  @ffi.Uint32()
  external int flags;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.Uint32> padding;
}

/// \enum pw_filter_state The state of a filter
abstract class pw_filter_state {
  /// < the stream is in error
  static const int PW_FILTER_STATE_ERROR = -1;

  /// < unconnected
  static const int PW_FILTER_STATE_UNCONNECTED = 0;

  /// < connection is in progress
  static const int PW_FILTER_STATE_CONNECTING = 1;

  /// < filter is connected and paused
  static const int PW_FILTER_STATE_PAUSED = 2;

  /// < filter is streaming
  static const int PW_FILTER_STATE_STREAMING = 3;
}

/// Events for a filter. These events are always called from the mainloop
/// unless explicitly documented otherwise.
class pw_filter_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;

  /// when the filter state changes
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
              ffi.Pointer<ffi.Char>)>> state_changed;

  /// when io changed on a port of the filter (when port_data is NULL).
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<ffi.Void>, ffi.Uint32)>> io_changed;

  /// when a parameter changed on a port of the filter (when port_data is NULL).
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Uint32, ffi.Pointer<spa_pod>)>> param_changed;

  /// when a new buffer was created for a port
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<pw_buffer>)>> add_buffer;

  /// when a buffer was destroyed for a port
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<pw_buffer>)>> remove_buffer;

  /// do processing. This is normally called from the
  /// mainloop but can also be called directly from the realtime data
  /// thread if the user is prepared to deal with this.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<spa_io_position>)>> process;

  /// The filter is drained
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      drained;

  /// A command notify, Since 0.3.39:1
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<spa_command>)>> command;
}

/// \enum pw_filter_flags Extra flags that can be used in \ref pw_filter_connect()
abstract class pw_filter_flags {
  /// < no flags
  static const int PW_FILTER_FLAG_NONE = 0;

  /// < start the filter inactive,
  /// pw_filter_set_active() needs to be
  /// called explicitly
  static const int PW_FILTER_FLAG_INACTIVE = 1;

  /// < be a driver
  static const int PW_FILTER_FLAG_DRIVER = 2;

  /// < call process from the realtime
  /// thread
  static const int PW_FILTER_FLAG_RT_PROCESS = 4;

  /// < don't call the default latency algorithm
  /// but emit the param_changed event for the
  /// ports when Latency params are received.
  static const int PW_FILTER_FLAG_CUSTOM_LATENCY = 8;
}

abstract class pw_filter_port_flags {
  /// < no flags
  static const int PW_FILTER_PORT_FLAG_NONE = 0;

  /// < mmap the buffers except DmaBuf
  static const int PW_FILTER_PORT_FLAG_MAP_BUFFERS = 1;

  /// < the application will allocate buffer
  /// memory. In the add_buffer event, the
  /// data of the buffer should be set
  static const int PW_FILTER_PORT_FLAG_ALLOC_BUFFERS = 2;
}

/// \addtogroup pw_thread_loop
/// \{
class pw_thread_loop extends ffi.Opaque {}

/// Thread loop events
class pw_thread_loop_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// the loop is destroyed
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;
}

/// \addtogroup pw_data_loop
/// \{
class pw_data_loop extends ffi.Opaque {}

/// Loop events, use \ref pw_data_loop_add_listener to add a listener
class pw_data_loop_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The loop is destroyed
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      destroy;
}

class spa_thread extends ffi.Opaque {}

const int SI_ASYNCNL = -60;

const int SI_DETHREAD = -7;

const int SI_TKILL = -6;

const int SI_SIGIO = -5;

const int SI_ASYNCIO = -4;

const int SI_MESGQ = -3;

const int SI_TIMER = -2;

const int SI_QUEUE = -1;

const int SI_USER = 0;

const int SI_KERNEL = 128;

const int ILL_ILLOPC = 1;

const int ILL_ILLOPN = 2;

const int ILL_ILLADR = 3;

const int ILL_ILLTRP = 4;

const int ILL_PRVOPC = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int ILL_BADIADDR = 9;

const int FPE_INTDIV = 1;

const int FPE_INTOVF = 2;

const int FPE_FLTDIV = 3;

const int FPE_FLTOVF = 4;

const int FPE_FLTUND = 5;

const int FPE_FLTRES = 6;

const int FPE_FLTINV = 7;

const int FPE_FLTSUB = 8;

const int FPE_FLTUNK = 14;

const int FPE_CONDTRAP = 15;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int SEGV_BNDERR = 3;

const int SEGV_PKUERR = 4;

const int SEGV_ACCADI = 5;

const int SEGV_ADIDERR = 6;

const int SEGV_ADIPERR = 7;

const int SEGV_MTEAERR = 8;

const int SEGV_MTESERR = 9;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int BUS_MCEERR_AR = 4;

const int BUS_MCEERR_AO = 5;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SIGEV_SIGNAL = 0;

const int SIGEV_NONE = 1;

const int SIGEV_THREAD = 2;

const int SIGEV_THREAD_ID = 4;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 2;

const int SPA_TYPE_START = 0;

const int SPA_TYPE_None = 1;

const int SPA_TYPE_Bool = 2;

const int SPA_TYPE_Id = 3;

const int SPA_TYPE_Int = 4;

const int SPA_TYPE_Long = 5;

const int SPA_TYPE_Float = 6;

const int SPA_TYPE_Double = 7;

const int SPA_TYPE_String = 8;

const int SPA_TYPE_Bytes = 9;

const int SPA_TYPE_Rectangle = 10;

const int SPA_TYPE_Fraction = 11;

const int SPA_TYPE_Bitmap = 12;

const int SPA_TYPE_Array = 13;

const int SPA_TYPE_Struct = 14;

const int SPA_TYPE_Object = 15;

const int SPA_TYPE_Sequence = 16;

const int SPA_TYPE_Pointer = 17;

const int SPA_TYPE_Fd = 18;

const int SPA_TYPE_Choice = 19;

const int SPA_TYPE_Pod = 20;

const int SPA_TYPE_POINTER_START = 65536;

const int SPA_TYPE_POINTER_Buffer = 65537;

const int SPA_TYPE_POINTER_Meta = 65538;

const int SPA_TYPE_POINTER_Dict = 65539;

const int SPA_TYPE_EVENT_START = 131072;

const int SPA_TYPE_EVENT_Device = 131073;

const int SPA_TYPE_EVENT_Node = 131074;

const int SPA_TYPE_COMMAND_START = 196608;

const int SPA_TYPE_COMMAND_Device = 196609;

const int SPA_TYPE_COMMAND_Node = 196610;

const int SPA_TYPE_OBJECT_START = 262144;

const int SPA_TYPE_OBJECT_PropInfo = 262145;

const int SPA_TYPE_OBJECT_Props = 262146;

const int SPA_TYPE_OBJECT_Format = 262147;

const int SPA_TYPE_OBJECT_ParamBuffers = 262148;

const int SPA_TYPE_OBJECT_ParamMeta = 262149;

const int SPA_TYPE_OBJECT_ParamIO = 262150;

const int SPA_TYPE_OBJECT_ParamProfile = 262151;

const int SPA_TYPE_OBJECT_ParamPortConfig = 262152;

const int SPA_TYPE_OBJECT_ParamRoute = 262153;

const int SPA_TYPE_OBJECT_Profiler = 262154;

const int SPA_TYPE_OBJECT_ParamLatency = 262155;

const int SPA_TYPE_OBJECT_ParamProcessLatency = 262156;

const int SPA_TYPE_VENDOR_PipeWire = 33554432;

const int SPA_TYPE_VENDOR_Other = 2130706432;

const int PW_TYPE_FIRST = 33554432;

const int true1 = 1;

const int false1 = 0;

const int __bool_true_false_are_defined = 1;

const int _INTTYPES_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 31;

const int _SYS_CDEFS_H = 1;

const int __glibc_c99_flexarr_available = 1;

const int __HAVE_GENERIC_SELECTION = 0;

const int _STDINT_H = 1;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_INTN_H = 1;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int ____gwchar_t_defined = 1;

const String __PRI64_PREFIX = 'l';

const String __PRIPTR_PREFIX = 'l';

const String PRId8 = 'd';

const String PRId16 = 'd';

const String PRId32 = 'd';

const String PRId64 = 'ld';

const String PRIdLEAST8 = 'd';

const String PRIdLEAST16 = 'd';

const String PRIdLEAST32 = 'd';

const String PRIdLEAST64 = 'ld';

const String PRIdFAST8 = 'd';

const String PRIdFAST16 = 'ld';

const String PRIdFAST32 = 'ld';

const String PRIdFAST64 = 'ld';

const String PRIi8 = 'i';

const String PRIi16 = 'i';

const String PRIi32 = 'i';

const String PRIi64 = 'li';

const String PRIiLEAST8 = 'i';

const String PRIiLEAST16 = 'i';

const String PRIiLEAST32 = 'i';

const String PRIiLEAST64 = 'li';

const String PRIiFAST8 = 'i';

const String PRIiFAST16 = 'li';

const String PRIiFAST32 = 'li';

const String PRIiFAST64 = 'li';

const String PRIo8 = 'o';

const String PRIo16 = 'o';

const String PRIo32 = 'o';

const String PRIo64 = 'lo';

const String PRIoLEAST8 = 'o';

const String PRIoLEAST16 = 'o';

const String PRIoLEAST32 = 'o';

const String PRIoLEAST64 = 'lo';

const String PRIoFAST8 = 'o';

const String PRIoFAST16 = 'lo';

const String PRIoFAST32 = 'lo';

const String PRIoFAST64 = 'lo';

const String PRIu8 = 'u';

const String PRIu16 = 'u';

const String PRIu32 = 'u';

const String PRIu64 = 'lu';

const String PRIuLEAST8 = 'u';

const String PRIuLEAST16 = 'u';

const String PRIuLEAST32 = 'u';

const String PRIuLEAST64 = 'lu';

const String PRIuFAST8 = 'u';

const String PRIuFAST16 = 'lu';

const String PRIuFAST32 = 'lu';

const String PRIuFAST64 = 'lu';

const String PRIx8 = 'x';

const String PRIx16 = 'x';

const String PRIx32 = 'x';

const String PRIx64 = 'lx';

const String PRIxLEAST8 = 'x';

const String PRIxLEAST16 = 'x';

const String PRIxLEAST32 = 'x';

const String PRIxLEAST64 = 'lx';

const String PRIxFAST8 = 'x';

const String PRIxFAST16 = 'lx';

const String PRIxFAST32 = 'lx';

const String PRIxFAST64 = 'lx';

const String PRIX8 = 'X';

const String PRIX16 = 'X';

const String PRIX32 = 'X';

const String PRIX64 = 'lX';

const String PRIXLEAST8 = 'X';

const String PRIXLEAST16 = 'X';

const String PRIXLEAST32 = 'X';

const String PRIXLEAST64 = 'lX';

const String PRIXFAST8 = 'X';

const String PRIXFAST16 = 'lX';

const String PRIXFAST32 = 'lX';

const String PRIXFAST64 = 'lX';

const String PRIdMAX = 'ld';

const String PRIiMAX = 'li';

const String PRIoMAX = 'lo';

const String PRIuMAX = 'lu';

const String PRIxMAX = 'lx';

const String PRIXMAX = 'lX';

const String PRIdPTR = 'ld';

const String PRIiPTR = 'li';

const String PRIoPTR = 'lo';

const String PRIuPTR = 'lu';

const String PRIxPTR = 'lx';

const String PRIXPTR = 'lX';

const String SCNd8 = 'hhd';

const String SCNd16 = 'hd';

const String SCNd32 = 'd';

const String SCNd64 = 'ld';

const String SCNdLEAST8 = 'hhd';

const String SCNdLEAST16 = 'hd';

const String SCNdLEAST32 = 'd';

const String SCNdLEAST64 = 'ld';

const String SCNdFAST8 = 'hhd';

const String SCNdFAST16 = 'ld';

const String SCNdFAST32 = 'ld';

const String SCNdFAST64 = 'ld';

const String SCNi8 = 'hhi';

const String SCNi16 = 'hi';

const String SCNi32 = 'i';

const String SCNi64 = 'li';

const String SCNiLEAST8 = 'hhi';

const String SCNiLEAST16 = 'hi';

const String SCNiLEAST32 = 'i';

const String SCNiLEAST64 = 'li';

const String SCNiFAST8 = 'hhi';

const String SCNiFAST16 = 'li';

const String SCNiFAST32 = 'li';

const String SCNiFAST64 = 'li';

const String SCNu8 = 'hhu';

const String SCNu16 = 'hu';

const String SCNu32 = 'u';

const String SCNu64 = 'lu';

const String SCNuLEAST8 = 'hhu';

const String SCNuLEAST16 = 'hu';

const String SCNuLEAST32 = 'u';

const String SCNuLEAST64 = 'lu';

const String SCNuFAST8 = 'hhu';

const String SCNuFAST16 = 'lu';

const String SCNuFAST32 = 'lu';

const String SCNuFAST64 = 'lu';

const String SCNo8 = 'hho';

const String SCNo16 = 'ho';

const String SCNo32 = 'o';

const String SCNo64 = 'lo';

const String SCNoLEAST8 = 'hho';

const String SCNoLEAST16 = 'ho';

const String SCNoLEAST32 = 'o';

const String SCNoLEAST64 = 'lo';

const String SCNoFAST8 = 'hho';

const String SCNoFAST16 = 'lo';

const String SCNoFAST32 = 'lo';

const String SCNoFAST64 = 'lo';

const String SCNx8 = 'hhx';

const String SCNx16 = 'hx';

const String SCNx32 = 'x';

const String SCNx64 = 'lx';

const String SCNxLEAST8 = 'hhx';

const String SCNxLEAST16 = 'hx';

const String SCNxLEAST32 = 'x';

const String SCNxLEAST64 = 'lx';

const String SCNxFAST8 = 'hhx';

const String SCNxFAST16 = 'lx';

const String SCNxFAST32 = 'lx';

const String SCNxFAST64 = 'lx';

const String SCNdMAX = 'ld';

const String SCNiMAX = 'li';

const String SCNoMAX = 'lo';

const String SCNuMAX = 'lu';

const String SCNxMAX = 'lx';

const String SCNdPTR = 'ld';

const String SCNiPTR = 'li';

const String SCNoPTR = 'lo';

const String SCNuPTR = 'lu';

const String SCNxPTR = 'lx';

const int _BITS_SIGNUM_GENERIC_H = 1;

const int SIGINT = 2;

const int SIGILL = 4;

const int SIGABRT = 6;

const int SIGFPE = 8;

const int SIGSEGV = 11;

const int SIGTERM = 15;

const int SIGHUP = 1;

const int SIGQUIT = 3;

const int SIGTRAP = 5;

const int SIGKILL = 9;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGIO = 29;

const int SIGIOT = 6;

const int SIGCLD = 17;

const int SIGSTKFLT = 16;

const int SIGPWR = 30;

const int SIGBUS = 7;

const int SIGSYS = 31;

const int SIGURG = 23;

const int SIGSTOP = 19;

const int SIGTSTP = 20;

const int SIGCONT = 18;

const int SIGCHLD = 17;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGPOLL = 29;

const int SIGXFSZ = 25;

const int SIGXCPU = 24;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGUSR1 = 10;

const int SIGUSR2 = 12;

const int SIGWINCH = 28;

const int __SIGRTMIN = 32;

const int __SIGRTMAX = 64;

const int _NSIG = 65;

const int __sig_atomic_t_defined = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int _STRUCT_TIMESPEC = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int __time_t_defined = 1;

const int __siginfo_t_defined = 1;

const int __SI_MAX_SIZE = 128;

const int __SI_PAD_SIZE = 28;

const int _BITS_SIGINFO_ARCH_H = 1;

const int __SI_ERRNO_THEN_CODE = 1;

const int __SI_HAVE_SIGSYS = 1;

const int _BITS_SIGINFO_CONSTS_H = 1;

const int __SI_ASYNCIO_AFTER_SIGIO = 1;

const int SI_ASYNCNL1 = -60;

const int SI_DETHREAD1 = -7;

const int SI_TKILL1 = -6;

const int SI_SIGIO1 = -5;

const int SI_ASYNCIO1 = -4;

const int SI_MESGQ1 = -3;

const int SI_TIMER1 = -2;

const int SI_QUEUE1 = -1;

const int SI_USER1 = 0;

const int SI_KERNEL1 = 128;

const int ILL_ILLOPC1 = 1;

const int ILL_ILLOPN1 = 2;

const int ILL_ILLADR1 = 3;

const int ILL_ILLTRP1 = 4;

const int ILL_PRVOPC1 = 5;

const int ILL_PRVREG1 = 6;

const int ILL_COPROC1 = 7;

const int ILL_BADSTK1 = 8;

const int ILL_BADIADDR1 = 9;

const int FPE_INTDIV1 = 1;

const int FPE_INTOVF1 = 2;

const int FPE_FLTDIV1 = 3;

const int FPE_FLTOVF1 = 4;

const int FPE_FLTUND1 = 5;

const int FPE_FLTRES1 = 6;

const int FPE_FLTINV1 = 7;

const int FPE_FLTSUB1 = 8;

const int FPE_FLTUNK1 = 14;

const int FPE_CONDTRAP1 = 15;

const int SEGV_MAPERR1 = 1;

const int SEGV_ACCERR1 = 2;

const int SEGV_BNDERR1 = 3;

const int SEGV_PKUERR1 = 4;

const int SEGV_ACCADI1 = 5;

const int SEGV_ADIDERR1 = 6;

const int SEGV_ADIPERR1 = 7;

const int BUS_ADRALN1 = 1;

const int BUS_ADRERR1 = 2;

const int BUS_OBJERR1 = 3;

const int BUS_MCEERR_AR1 = 4;

const int BUS_MCEERR_AO1 = 5;

const int CLD_EXITED1 = 1;

const int CLD_KILLED1 = 2;

const int CLD_DUMPED1 = 3;

const int CLD_TRAPPED1 = 4;

const int CLD_STOPPED1 = 5;

const int CLD_CONTINUED1 = 6;

const int POLL_IN1 = 1;

const int POLL_OUT1 = 2;

const int POLL_MSG1 = 3;

const int POLL_ERR1 = 4;

const int POLL_PRI1 = 5;

const int POLL_HUP1 = 6;

const int __sigevent_t_defined = 1;

const int __SIGEV_MAX_SIZE = 64;

const int __SIGEV_PAD_SIZE = 12;

const int __have_pthread_attr_t = 1;

const int _BITS_SIGEVENT_CONSTS_H = 1;

const int SIGEV_SIGNAL1 = 0;

const int SIGEV_NONE1 = 1;

const int SIGEV_THREAD1 = 2;

const int SIGEV_THREAD_ID1 = 4;

const int NSIG = 65;

const int _BITS_SIGACTION_H = 1;

const int SA_NOCLDSTOP = 1;

const int SA_NOCLDWAIT = 2;

const int SA_SIGINFO = 4;

const int SA_ONSTACK = 134217728;

const int SA_RESTART = 268435456;

const int SA_NODEFER = 1073741824;

const int SA_RESETHAND = 2147483648;

const int SA_INTERRUPT = 536870912;

const int SA_NOMASK = 1073741824;

const int SA_ONESHOT = 2147483648;

const int SA_STACK = 134217728;

const int SIG_BLOCK = 0;

const int SIG_UNBLOCK = 1;

const int SIG_SETMASK = 2;

const int _BITS_SIGCONTEXT_H = 1;

const int FP_XSTATE_MAGIC1 = 1179670611;

const int FP_XSTATE_MAGIC2 = 1179670597;

const int FP_XSTATE_MAGIC2_SIZE = 4;

const int __stack_t_defined = 1;

const int _SYS_UCONTEXT_H = 1;

const int __NGREG = 23;

const int NGREG = 23;

const int _BITS_SIGSTACK_H = 1;

const int MINSIGSTKSZ = 2048;

const int SIGSTKSZ = 8192;

const int _BITS_SS_FLAGS_H = 1;

const int SS_ONSTACK1 = 1;

const int SS_DISABLE1 = 2;

const int __sigstack_defined = 1;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int _BITS_SIGTHREAD_H = 1;

const int NULL = 0;

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int __clock_t_defined = 1;

const int __clockid_t_defined = 1;

const int __timer_t_defined = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __timeval_defined = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _ALLOCA_H = 1;

const int _STRING_H = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int _STRINGS_H = 1;

const int _STDIO_H = 1;

const int __GNUC_VA_LIST = 1;

const int _____fpos_t_defined = 1;

const int ____mbstate_t_defined = 1;

const int _____fpos64_t_defined = 1;

const int ____FILE_defined = 1;

const int __FILE_defined = 1;

const int __struct_FILE_defined = 1;

const int _IO_EOF_SEEN = 16;

const int _IO_ERR_SEEN = 32;

const int _IO_USER_LOCK = 32768;

const int _IOFBF = 0;

const int _IOLBF = 1;

const int _IONBF = 2;

const int BUFSIZ = 8192;

const int EOF = -1;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const String P_tmpdir = '/tmp';

const int _BITS_STDIO_LIM_H = 1;

const int L_tmpnam = 20;

const int TMP_MAX = 238328;

const int FILENAME_MAX = 4096;

const int L_ctermid = 9;

const int FOPEN_MAX = 16;

const int SPA_TIME_INVALID = -9223372036854775808;

const int SPA_IDX_INVALID = 4294967295;

const int SPA_ID_INVALID = 4294967295;

const int SPA_NSEC_PER_SEC = 1000000000;

const int SPA_NSEC_PER_MSEC = 1000000;

const int SPA_NSEC_PER_USEC = 1000;

const int SPA_USEC_PER_SEC = 1000000;

const int SPA_USEC_PER_MSEC = 1000;

const int SPA_MSEC_PER_SEC = 1000;

const int SPA_DICT_FLAG_SORTED = 1;

const int SPA_VERSION_HANDLE = 0;

const int SPA_VERSION_HANDLE_FACTORY = 1;

const String SPA_HANDLE_FACTORY_ENUM_FUNC_NAME = 'spa_handle_factory_enum';

const String SPA_KEY_FACTORY_NAME = 'factory.name';

const String SPA_KEY_FACTORY_AUTHOR = 'factory.author';

const String SPA_KEY_FACTORY_DESCRIPTION = 'factory.description';

const String SPA_KEY_FACTORY_USAGE = 'factory.usage';

const String SPA_KEY_LIBRARY_NAME = 'library.name';

const int _ERRNO_H = 1;

const int _BITS_ERRNO_H = 1;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int ENOTBLK = 15;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int EINVAL = 22;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int ETXTBSY = 26;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int ERANGE = 34;

const int EDEADLK = 35;

const int ENAMETOOLONG = 36;

const int ENOLCK = 37;

const int ENOSYS = 38;

const int ENOTEMPTY = 39;

const int ELOOP = 40;

const int EWOULDBLOCK = 11;

const int ENOMSG = 42;

const int EIDRM = 43;

const int ECHRNG = 44;

const int EL2NSYNC = 45;

const int EL3HLT = 46;

const int EL3RST = 47;

const int ELNRNG = 48;

const int EUNATCH = 49;

const int ENOCSI = 50;

const int EL2HLT = 51;

const int EBADE = 52;

const int EBADR = 53;

const int EXFULL = 54;

const int ENOANO = 55;

const int EBADRQC = 56;

const int EBADSLT = 57;

const int EDEADLOCK = 35;

const int EBFONT = 59;

const int ENOSTR = 60;

const int ENODATA = 61;

const int ETIME = 62;

const int ENOSR = 63;

const int ENONET = 64;

const int ENOPKG = 65;

const int EREMOTE = 66;

const int ENOLINK = 67;

const int EADV = 68;

const int ESRMNT = 69;

const int ECOMM = 70;

const int EPROTO = 71;

const int EMULTIHOP = 72;

const int EDOTDOT = 73;

const int EBADMSG = 74;

const int EOVERFLOW = 75;

const int ENOTUNIQ = 76;

const int EBADFD = 77;

const int EREMCHG = 78;

const int ELIBACC = 79;

const int ELIBBAD = 80;

const int ELIBSCN = 81;

const int ELIBMAX = 82;

const int ELIBEXEC = 83;

const int EILSEQ = 84;

const int ERESTART = 85;

const int ESTRPIPE = 86;

const int EUSERS = 87;

const int ENOTSOCK = 88;

const int EDESTADDRREQ = 89;

const int EMSGSIZE = 90;

const int EPROTOTYPE = 91;

const int ENOPROTOOPT = 92;

const int EPROTONOSUPPORT = 93;

const int ESOCKTNOSUPPORT = 94;

const int EOPNOTSUPP = 95;

const int EPFNOSUPPORT = 96;

const int EAFNOSUPPORT = 97;

const int EADDRINUSE = 98;

const int EADDRNOTAVAIL = 99;

const int ENETDOWN = 100;

const int ENETUNREACH = 101;

const int ENETRESET = 102;

const int ECONNABORTED = 103;

const int ECONNRESET = 104;

const int ENOBUFS = 105;

const int EISCONN = 106;

const int ENOTCONN = 107;

const int ESHUTDOWN = 108;

const int ETOOMANYREFS = 109;

const int ETIMEDOUT = 110;

const int ECONNREFUSED = 111;

const int EHOSTDOWN = 112;

const int EHOSTUNREACH = 113;

const int EALREADY = 114;

const int EINPROGRESS = 115;

const int ESTALE = 116;

const int EUCLEAN = 117;

const int ENOTNAM = 118;

const int ENAVAIL = 119;

const int EISNAM = 120;

const int EREMOTEIO = 121;

const int EDQUOT = 122;

const int ENOMEDIUM = 123;

const int EMEDIUMTYPE = 124;

const int ECANCELED = 125;

const int ENOKEY = 126;

const int EKEYEXPIRED = 127;

const int EKEYREVOKED = 128;

const int EKEYREJECTED = 129;

const int EOWNERDEAD = 130;

const int ENOTRECOVERABLE = 131;

const int ERFKILL = 132;

const int EHWPOISON = 133;

const int ENOTSUP = 95;

const int SPA_PARAM_INFO_SERIAL = 1;

const int SPA_PARAM_INFO_READ = 2;

const int SPA_PARAM_INFO_WRITE = 4;

const int SPA_PARAM_INFO_READWRITE = 6;

const String PW_TYPE_INTERFACE_Core = 'PipeWire:Interface:Core';

const String PW_TYPE_INTERFACE_Registry = 'PipeWire:Interface:Registry';

const int PW_VERSION_CORE = 3;

const int PW_VERSION_REGISTRY = 3;

const String PW_DEFAULT_REMOTE = 'pipewire-0';

const int PW_ID_CORE = 0;

const int PW_ID_ANY = 4294967295;

const int PW_CORE_CHANGE_MASK_PROPS = 1;

const int PW_CORE_CHANGE_MASK_ALL = 1;

const int PW_PROPERTIES_FLAG_NL = 1;

const int PW_CORE_EVENT_INFO = 0;

const int PW_CORE_EVENT_DONE = 1;

const int PW_CORE_EVENT_PING = 2;

const int PW_CORE_EVENT_ERROR = 3;

const int PW_CORE_EVENT_REMOVE_ID = 4;

const int PW_CORE_EVENT_BOUND_ID = 5;

const int PW_CORE_EVENT_ADD_MEM = 6;

const int PW_CORE_EVENT_REMOVE_MEM = 7;

const int PW_CORE_EVENT_NUM = 8;

const int PW_VERSION_CORE_EVENTS = 0;

const int PW_CORE_METHOD_ADD_LISTENER = 0;

const int PW_CORE_METHOD_HELLO = 1;

const int PW_CORE_METHOD_SYNC = 2;

const int PW_CORE_METHOD_PONG = 3;

const int PW_CORE_METHOD_ERROR = 4;

const int PW_CORE_METHOD_GET_REGISTRY = 5;

const int PW_CORE_METHOD_CREATE_OBJECT = 6;

const int PW_CORE_METHOD_DESTROY = 7;

const int PW_CORE_METHOD_NUM = 8;

const int PW_VERSION_CORE_METHODS = 0;

const int PW_REGISTRY_EVENT_GLOBAL = 0;

const int PW_REGISTRY_EVENT_GLOBAL_REMOVE = 1;

const int PW_REGISTRY_EVENT_NUM = 2;

const int PW_VERSION_REGISTRY_EVENTS = 0;

const int PW_REGISTRY_METHOD_ADD_LISTENER = 0;

const int PW_REGISTRY_METHOD_BIND = 1;

const int PW_REGISTRY_METHOD_DESTROY = 2;

const int PW_REGISTRY_METHOD_NUM = 3;

const int PW_VERSION_REGISTRY_METHODS = 0;

const int _TIME_H = 1;

const int _BITS_TIME_H = 1;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 1;

const int CLOCK_PROCESS_CPUTIME_ID = 2;

const int CLOCK_THREAD_CPUTIME_ID = 3;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_REALTIME_COARSE = 5;

const int CLOCK_MONOTONIC_COARSE = 6;

const int CLOCK_BOOTTIME = 7;

const int CLOCK_REALTIME_ALARM = 8;

const int CLOCK_BOOTTIME_ALARM = 9;

const int CLOCK_TAI = 11;

const int TIMER_ABSTIME = 1;

const int __struct_tm_defined = 1;

const int __itimerspec_defined = 1;

const int TIME_UTC = 1;

const String SPA_TYPE_INTERFACE_System = 'Spa:Pointer:Interface:System';

const String SPA_TYPE_INTERFACE_DataSystem = 'Spa:Pointer:Interface:DataSystem';

const int SPA_VERSION_SYSTEM = 0;

const int SPA_IO_IN = 1;

const int SPA_IO_OUT = 4;

const int SPA_IO_ERR = 8;

const int SPA_IO_HUP = 16;

const int SPA_FD_CLOEXEC = 1;

const int SPA_FD_NONBLOCK = 2;

const int SPA_FD_EVENT_SEMAPHORE = 4;

const int SPA_FD_TIMER_ABSTIME = 8;

const int SPA_FD_TIMER_CANCEL_ON_SET = 16;

const int SPA_VERSION_SYSTEM_METHODS = 0;

const String SPA_TYPE_INTERFACE_Loop = 'Spa:Pointer:Interface:Loop';

const String SPA_TYPE_INTERFACE_DataLoop = 'Spa:Pointer:Interface:DataLoop';

const int SPA_VERSION_LOOP = 0;

const String SPA_TYPE_INTERFACE_LoopControl =
    'Spa:Pointer:Interface:LoopControl';

const int SPA_VERSION_LOOP_CONTROL = 0;

const String SPA_TYPE_INTERFACE_LoopUtils = 'Spa:Pointer:Interface:LoopUtils';

const int SPA_VERSION_LOOP_UTILS = 0;

const int SPA_VERSION_LOOP_METHODS = 0;

const int SPA_VERSION_LOOP_CONTROL_HOOKS = 0;

const int SPA_VERSION_LOOP_CONTROL_METHODS = 0;

const int SPA_VERSION_LOOP_UTILS_METHODS = 0;

const int PW_VERSION_CONTEXT_EVENTS = 0;

const int _SYS_UN_H = 1;

const int _BITS_SOCKADDR_H = 1;

const int __SOCKADDR_COMMON_SIZE = 2;

const int _SS_SIZE = 128;

const String SPA_TYPE_INFO_BASE = 'Spa:';

const String SPA_TYPE_INFO_Flags = 'Spa:Flags';

const String SPA_TYPE_INFO_FLAGS_BASE = 'Spa:Flags:';

const String SPA_TYPE_INFO_Enum = 'Spa:Enum';

const String SPA_TYPE_INFO_ENUM_BASE = 'Spa:Enum:';

const String SPA_TYPE_INFO_Pod = 'Spa:Pod';

const String SPA_TYPE_INFO_POD_BASE = 'Spa:Pod:';

const String SPA_TYPE_INFO_Struct = 'Spa:Pod:Struct';

const String SPA_TYPE_INFO_STRUCT_BASE = 'Spa:Pod:Struct:';

const String SPA_TYPE_INFO_Object = 'Spa:Pod:Object';

const String SPA_TYPE_INFO_OBJECT_BASE = 'Spa:Pod:Object:';

const String SPA_TYPE_INFO_Pointer = 'Spa:Pointer';

const String SPA_TYPE_INFO_POINTER_BASE = 'Spa:Pointer:';

const String SPA_TYPE_INFO_Interface = 'Spa:Pointer:Interface';

const String SPA_TYPE_INFO_INTERFACE_BASE = 'Spa:Pointer:Interface:';

const String SPA_TYPE_INFO_Event = 'Spa:Pod:Object:Event';

const String SPA_TYPE_INFO_EVENT_BASE = 'Spa:Pod:Object:Event:';

const String SPA_TYPE_INFO_Command = 'Spa:Pod:Object:Command';

const String SPA_TYPE_INFO_COMMAND_BASE = 'Spa:Pod:Object:Command:';

const int SPA_POD_PROP_FLAG_READONLY = 1;

const int SPA_POD_PROP_FLAG_HARDWARE = 2;

const int SPA_POD_PROP_FLAG_HINT_DICT = 4;

const int SPA_POD_PROP_FLAG_MANDATORY = 8;

const int SPA_POD_PROP_FLAG_DONT_FIXATE = 16;

const String PW_TYPE_INFO_Protocol = 'PipeWire:Protocol';

const String PW_TYPE_INFO_PROTOCOL_BASE = 'PipeWire:Protocol:';

const int PW_PROTOCOL_MARSHAL_FLAG_IMPL = 1;

const int PW_VERSION_PROTOCOL_IMPLEMENTATION = 0;

const int PW_VERSION_PROTOCOL_EVENTS = 0;

const int PW_VERSION_PROXY_EVENTS = 0;

const int PW_PERM_R = 256;

const int PW_PERM_W = 128;

const int PW_PERM_X = 64;

const int PW_PERM_M = 8;

const int PW_PERM_RWX = 448;

const int PW_PERM_RWXM = 456;

const int PW_PERM_ALL = 456;

const int PW_PERM_INVALID = 4294967295;

const String PW_PERMISSION_FORMAT = '%c%c%c%c';

const String PW_TYPE_INTERFACE_Client = 'PipeWire:Interface:Client';

const int PW_VERSION_CLIENT = 3;

const int PW_ID_CLIENT = 1;

const int PW_CLIENT_CHANGE_MASK_PROPS = 1;

const int PW_CLIENT_CHANGE_MASK_ALL = 1;

const int PW_CLIENT_EVENT_INFO = 0;

const int PW_CLIENT_EVENT_PERMISSIONS = 1;

const int PW_CLIENT_EVENT_NUM = 2;

const int PW_VERSION_CLIENT_EVENTS = 0;

const int PW_CLIENT_METHOD_ADD_LISTENER = 0;

const int PW_CLIENT_METHOD_ERROR = 1;

const int PW_CLIENT_METHOD_UPDATE_PROPERTIES = 2;

const int PW_CLIENT_METHOD_GET_PERMISSIONS = 3;

const int PW_CLIENT_METHOD_UPDATE_PERMISSIONS = 4;

const int PW_CLIENT_METHOD_NUM = 5;

const int PW_VERSION_CLIENT_METHODS = 0;

const String PW_TYPE_INTERFACE_Device = 'PipeWire:Interface:Device';

const int PW_VERSION_DEVICE = 3;

const int PW_DEVICE_CHANGE_MASK_PROPS = 1;

const int PW_DEVICE_CHANGE_MASK_PARAMS = 2;

const int PW_DEVICE_CHANGE_MASK_ALL = 3;

const int PW_DEVICE_EVENT_INFO = 0;

const int PW_DEVICE_EVENT_PARAM = 1;

const int PW_DEVICE_EVENT_NUM = 2;

const int PW_VERSION_DEVICE_EVENTS = 0;

const int PW_DEVICE_METHOD_ADD_LISTENER = 0;

const int PW_DEVICE_METHOD_SUBSCRIBE_PARAMS = 1;

const int PW_DEVICE_METHOD_ENUM_PARAMS = 2;

const int PW_DEVICE_METHOD_SET_PARAM = 3;

const int PW_DEVICE_METHOD_NUM = 4;

const int PW_VERSION_DEVICE_METHODS = 0;

const int SPA_META_HEADER_FLAG_DISCONT = 1;

const int SPA_META_HEADER_FLAG_CORRUPTED = 2;

const int SPA_META_HEADER_FLAG_MARKER = 4;

const int SPA_META_HEADER_FLAG_HEADER = 8;

const int SPA_META_HEADER_FLAG_GAP = 16;

const int SPA_META_HEADER_FLAG_DELTA_UNIT = 32;

const int SPA_CHUNK_FLAG_NONE = 0;

const int SPA_CHUNK_FLAG_CORRUPTED = 1;

const int SPA_DATA_FLAG_NONE = 0;

const int SPA_DATA_FLAG_READABLE = 1;

const int SPA_DATA_FLAG_WRITABLE = 2;

const int SPA_DATA_FLAG_DYNAMIC = 4;

const int SPA_DATA_FLAG_READWRITE = 3;

const String SPA_TYPE_INTERFACE_Node = 'Spa:Pointer:Interface:Node';

const int SPA_VERSION_NODE = 0;

const int SPA_NODE_CHANGE_MASK_FLAGS = 1;

const int SPA_NODE_CHANGE_MASK_PROPS = 2;

const int SPA_NODE_CHANGE_MASK_PARAMS = 4;

const int SPA_NODE_FLAG_RT = 1;

const int SPA_NODE_FLAG_IN_DYNAMIC_PORTS = 2;

const int SPA_NODE_FLAG_OUT_DYNAMIC_PORTS = 4;

const int SPA_NODE_FLAG_IN_PORT_CONFIG = 8;

const int SPA_NODE_FLAG_OUT_PORT_CONFIG = 16;

const int SPA_NODE_FLAG_NEED_CONFIGURE = 32;

const int SPA_NODE_FLAG_ASYNC = 64;

const int SPA_PORT_CHANGE_MASK_FLAGS = 1;

const int SPA_PORT_CHANGE_MASK_RATE = 2;

const int SPA_PORT_CHANGE_MASK_PROPS = 4;

const int SPA_PORT_CHANGE_MASK_PARAMS = 8;

const int SPA_PORT_FLAG_REMOVABLE = 1;

const int SPA_PORT_FLAG_OPTIONAL = 2;

const int SPA_PORT_FLAG_CAN_ALLOC_BUFFERS = 4;

const int SPA_PORT_FLAG_IN_PLACE = 8;

const int SPA_PORT_FLAG_NO_REF = 16;

const int SPA_PORT_FLAG_LIVE = 32;

const int SPA_PORT_FLAG_PHYSICAL = 64;

const int SPA_PORT_FLAG_TERMINAL = 128;

const int SPA_PORT_FLAG_DYNAMIC_DATA = 256;

const int SPA_RESULT_TYPE_NODE_ERROR = 1;

const int SPA_RESULT_TYPE_NODE_PARAMS = 2;

const int SPA_NODE_EVENT_INFO = 0;

const int SPA_NODE_EVENT_PORT_INFO = 1;

const int SPA_NODE_EVENT_RESULT = 2;

const int SPA_NODE_EVENT_EVENT = 3;

const int SPA_NODE_EVENT_NUM = 4;

const int SPA_VERSION_NODE_EVENTS = 0;

const int SPA_NODE_CALLBACK_READY = 0;

const int SPA_NODE_CALLBACK_REUSE_BUFFER = 1;

const int SPA_NODE_CALLBACK_XRUN = 2;

const int SPA_NODE_CALLBACK_NUM = 3;

const int SPA_VERSION_NODE_CALLBACKS = 0;

const int SPA_NODE_PARAM_FLAG_TEST_ONLY = 1;

const int SPA_NODE_PARAM_FLAG_FIXATE = 2;

const int SPA_NODE_PARAM_FLAG_NEAREST = 4;

const int SPA_NODE_BUFFERS_FLAG_ALLOC = 1;

const int SPA_NODE_METHOD_ADD_LISTENER = 0;

const int SPA_NODE_METHOD_SET_CALLBACKS = 1;

const int SPA_NODE_METHOD_SYNC = 2;

const int SPA_NODE_METHOD_ENUM_PARAMS = 3;

const int SPA_NODE_METHOD_SET_PARAM = 4;

const int SPA_NODE_METHOD_SET_IO = 5;

const int SPA_NODE_METHOD_SEND_COMMAND = 6;

const int SPA_NODE_METHOD_ADD_PORT = 7;

const int SPA_NODE_METHOD_REMOVE_PORT = 8;

const int SPA_NODE_METHOD_PORT_ENUM_PARAMS = 9;

const int SPA_NODE_METHOD_PORT_SET_PARAM = 10;

const int SPA_NODE_METHOD_PORT_USE_BUFFERS = 11;

const int SPA_NODE_METHOD_PORT_SET_IO = 12;

const int SPA_NODE_METHOD_PORT_REUSE_BUFFER = 13;

const int SPA_NODE_METHOD_PROCESS = 14;

const int SPA_NODE_METHOD_NUM = 15;

const int SPA_VERSION_NODE_METHODS = 0;

const int PW_VERSION_MEMPOOL_EVENTS = 0;

const int PW_BUFFERS_FLAG_NONE = 0;

const int PW_BUFFERS_FLAG_NO_MEM = 1;

const int PW_BUFFERS_FLAG_SHARED = 2;

const int PW_BUFFERS_FLAG_DYNAMIC = 4;

const int PW_BUFFERS_FLAG_SHARED_MEM = 8;

const String PW_TYPE_INTERFACE_Factory = 'PipeWire:Interface:Factory';

const int PW_VERSION_FACTORY = 3;

const int PW_FACTORY_CHANGE_MASK_PROPS = 1;

const int PW_FACTORY_CHANGE_MASK_ALL = 1;

const int PW_FACTORY_EVENT_INFO = 0;

const int PW_FACTORY_EVENT_NUM = 1;

const int PW_VERSION_FACTORY_EVENTS = 0;

const int PW_FACTORY_METHOD_ADD_LISTENER = 0;

const int PW_FACTORY_METHOD_NUM = 1;

const int PW_VERSION_FACTORY_METHODS = 0;

const String PW_KEY_PROTOCOL = 'pipewire.protocol';

const String PW_KEY_ACCESS = 'pipewire.access';

const String PW_KEY_CLIENT_ACCESS = 'pipewire.client.access';

const String PW_KEY_SEC_PID = 'pipewire.sec.pid';

const String PW_KEY_SEC_UID = 'pipewire.sec.uid';

const String PW_KEY_SEC_GID = 'pipewire.sec.gid';

const String PW_KEY_SEC_LABEL = 'pipewire.sec.label';

const String PW_KEY_LIBRARY_NAME_SYSTEM = 'library.name.system';

const String PW_KEY_LIBRARY_NAME_LOOP = 'library.name.loop';

const String PW_KEY_LIBRARY_NAME_DBUS = 'library.name.dbus';

const String PW_KEY_OBJECT_PATH = 'object.path';

const String PW_KEY_OBJECT_ID = 'object.id';

const String PW_KEY_OBJECT_SERIAL = 'object.serial';

const String PW_KEY_OBJECT_LINGER = 'object.linger';

const String PW_KEY_OBJECT_REGISTER = 'object.register';

const String PW_KEY_CONFIG_PREFIX = 'config.prefix';

const String PW_KEY_CONFIG_NAME = 'config.name';

const String PW_KEY_CONTEXT_PROFILE_MODULES = 'context.profile.modules';

const String PW_KEY_USER_NAME = 'context.user-name';

const String PW_KEY_HOST_NAME = 'context.host-name';

const String PW_KEY_CORE_NAME = 'core.name';

const String PW_KEY_CORE_VERSION = 'core.version';

const String PW_KEY_CORE_DAEMON = 'core.daemon';

const String PW_KEY_CORE_ID = 'core.id';

const String PW_KEY_CORE_MONITORS = 'core.monitors';

const String PW_KEY_CPU_MAX_ALIGN = 'cpu.max-align';

const String PW_KEY_CPU_CORES = 'cpu.cores';

const String PW_KEY_PRIORITY_SESSION = 'priority.session';

const String PW_KEY_PRIORITY_DRIVER = 'priority.driver';

const String PW_KEY_REMOTE_NAME = 'remote.name';

const String PW_KEY_REMOTE_INTENTION = 'remote.intention';

const String PW_KEY_APP_NAME = 'application.name';

const String PW_KEY_APP_ID = 'application.id';

const String PW_KEY_APP_VERSION = 'application.version';

const String PW_KEY_APP_ICON = 'application.icon';

const String PW_KEY_APP_ICON_NAME = 'application.icon-name';

const String PW_KEY_APP_LANGUAGE = 'application.language';

const String PW_KEY_APP_PROCESS_ID = 'application.process.id';

const String PW_KEY_APP_PROCESS_BINARY = 'application.process.binary';

const String PW_KEY_APP_PROCESS_USER = 'application.process.user';

const String PW_KEY_APP_PROCESS_HOST = 'application.process.host';

const String PW_KEY_APP_PROCESS_MACHINE_ID = 'application.process.machine-id';

const String PW_KEY_APP_PROCESS_SESSION_ID = 'application.process.session-id';

const String PW_KEY_WINDOW_X11_DISPLAY = 'window.x11.display';

const String PW_KEY_CLIENT_ID = 'client.id';

const String PW_KEY_CLIENT_NAME = 'client.name';

const String PW_KEY_CLIENT_API = 'client.api';

const String PW_KEY_NODE_ID = 'node.id';

const String PW_KEY_NODE_NAME = 'node.name';

const String PW_KEY_NODE_NICK = 'node.nick';

const String PW_KEY_NODE_DESCRIPTION = 'node.description';

const String PW_KEY_NODE_PLUGGED = 'node.plugged';

const String PW_KEY_NODE_SESSION = 'node.session';

const String PW_KEY_NODE_GROUP = 'node.group';

const String PW_KEY_NODE_EXCLUSIVE = 'node.exclusive';

const String PW_KEY_NODE_AUTOCONNECT = 'node.autoconnect';

const String PW_KEY_NODE_TARGET = 'node.target';

const String PW_KEY_NODE_LATENCY = 'node.latency';

const String PW_KEY_NODE_MAX_LATENCY = 'node.max-latency';

const String PW_KEY_NODE_LOCK_QUANTUM = 'node.lock-quantum';

const String PW_KEY_NODE_FORCE_QUANTUM = 'node.force-quantum';

const String PW_KEY_NODE_RATE = 'node.rate';

const String PW_KEY_NODE_LOCK_RATE = 'node.lock-rate';

const String PW_KEY_NODE_FORCE_RATE = 'node.force-rate';

const String PW_KEY_NODE_DONT_RECONNECT = 'node.dont-reconnect';

const String PW_KEY_NODE_ALWAYS_PROCESS = 'node.always-process';

const String PW_KEY_NODE_WANT_DRIVER = 'node.want-driver';

const String PW_KEY_NODE_PAUSE_ON_IDLE = 'node.pause-on-idle';

const String PW_KEY_NODE_SUSPEND_ON_IDLE = 'node.suspend-on-idle';

const String PW_KEY_NODE_CACHE_PARAMS = 'node.cache-params';

const String PW_KEY_NODE_TRANSPORT_SYNC = 'node.transport.sync';

const String PW_KEY_NODE_DRIVER = 'node.driver';

const String PW_KEY_NODE_STREAM = 'node.stream';

const String PW_KEY_NODE_VIRTUAL = 'node.virtual';

const String PW_KEY_NODE_PASSIVE = 'node.passive';

const String PW_KEY_NODE_LINK_GROUP = 'node.link-group';

const String PW_KEY_NODE_NETWORK = 'node.network';

const String PW_KEY_NODE_TRIGGER = 'node.trigger';

const String PW_KEY_PORT_ID = 'port.id';

const String PW_KEY_PORT_NAME = 'port.name';

const String PW_KEY_PORT_DIRECTION = 'port.direction';

const String PW_KEY_PORT_ALIAS = 'port.alias';

const String PW_KEY_PORT_PHYSICAL = 'port.physical';

const String PW_KEY_PORT_TERMINAL = 'port.terminal';

const String PW_KEY_PORT_CONTROL = 'port.control';

const String PW_KEY_PORT_MONITOR = 'port.monitor';

const String PW_KEY_PORT_CACHE_PARAMS = 'port.cache-params';

const String PW_KEY_PORT_EXTRA = 'port.extra';

const String PW_KEY_LINK_ID = 'link.id';

const String PW_KEY_LINK_INPUT_NODE = 'link.input.node';

const String PW_KEY_LINK_INPUT_PORT = 'link.input.port';

const String PW_KEY_LINK_OUTPUT_NODE = 'link.output.node';

const String PW_KEY_LINK_OUTPUT_PORT = 'link.output.port';

const String PW_KEY_LINK_PASSIVE = 'link.passive';

const String PW_KEY_LINK_FEEDBACK = 'link.feedback';

const String PW_KEY_DEVICE_ID = 'device.id';

const String PW_KEY_DEVICE_NAME = 'device.name';

const String PW_KEY_DEVICE_PLUGGED = 'device.plugged';

const String PW_KEY_DEVICE_NICK = 'device.nick';

const String PW_KEY_DEVICE_STRING = 'device.string';

const String PW_KEY_DEVICE_API = 'device.api';

const String PW_KEY_DEVICE_DESCRIPTION = 'device.description';

const String PW_KEY_DEVICE_BUS_PATH = 'device.bus-path';

const String PW_KEY_DEVICE_SERIAL = 'device.serial';

const String PW_KEY_DEVICE_VENDOR_ID = 'device.vendor.id';

const String PW_KEY_DEVICE_VENDOR_NAME = 'device.vendor.name';

const String PW_KEY_DEVICE_PRODUCT_ID = 'device.product.id';

const String PW_KEY_DEVICE_PRODUCT_NAME = 'device.product.name';

const String PW_KEY_DEVICE_CLASS = 'device.class';

const String PW_KEY_DEVICE_FORM_FACTOR = 'device.form-factor';

const String PW_KEY_DEVICE_BUS = 'device.bus';

const String PW_KEY_DEVICE_SUBSYSTEM = 'device.subsystem';

const String PW_KEY_DEVICE_ICON = 'device.icon';

const String PW_KEY_DEVICE_ICON_NAME = 'device.icon-name';

const String PW_KEY_DEVICE_INTENDED_ROLES = 'device.intended-roles';

const String PW_KEY_DEVICE_CACHE_PARAMS = 'device.cache-params';

const String PW_KEY_MODULE_ID = 'module.id';

const String PW_KEY_MODULE_NAME = 'module.name';

const String PW_KEY_MODULE_AUTHOR = 'module.author';

const String PW_KEY_MODULE_DESCRIPTION = 'module.description';

const String PW_KEY_MODULE_USAGE = 'module.usage';

const String PW_KEY_MODULE_VERSION = 'module.version';

const String PW_KEY_FACTORY_ID = 'factory.id';

const String PW_KEY_FACTORY_NAME = 'factory.name';

const String PW_KEY_FACTORY_USAGE = 'factory.usage';

const String PW_KEY_FACTORY_TYPE_NAME = 'factory.type.name';

const String PW_KEY_FACTORY_TYPE_VERSION = 'factory.type.version';

const String PW_KEY_STREAM_IS_LIVE = 'stream.is-live';

const String PW_KEY_STREAM_LATENCY_MIN = 'stream.latency.min';

const String PW_KEY_STREAM_LATENCY_MAX = 'stream.latency.max';

const String PW_KEY_STREAM_MONITOR = 'stream.monitor';

const String PW_KEY_STREAM_DONT_REMIX = 'stream.dont-remix';

const String PW_KEY_STREAM_CAPTURE_SINK = 'stream.capture.sink';

const String PW_KEY_MEDIA_TYPE = 'media.type';

const String PW_KEY_MEDIA_CATEGORY = 'media.category';

const String PW_KEY_MEDIA_ROLE = 'media.role';

const String PW_KEY_MEDIA_CLASS = 'media.class';

const String PW_KEY_MEDIA_NAME = 'media.name';

const String PW_KEY_MEDIA_TITLE = 'media.title';

const String PW_KEY_MEDIA_ARTIST = 'media.artist';

const String PW_KEY_MEDIA_COPYRIGHT = 'media.copyright';

const String PW_KEY_MEDIA_SOFTWARE = 'media.software';

const String PW_KEY_MEDIA_LANGUAGE = 'media.language';

const String PW_KEY_MEDIA_FILENAME = 'media.filename';

const String PW_KEY_MEDIA_ICON = 'media.icon';

const String PW_KEY_MEDIA_ICON_NAME = 'media.icon-name';

const String PW_KEY_MEDIA_COMMENT = 'media.comment';

const String PW_KEY_MEDIA_DATE = 'media.date';

const String PW_KEY_MEDIA_FORMAT = 'media.format';

const String PW_KEY_FORMAT_DSP = 'format.dsp';

const String PW_KEY_AUDIO_CHANNEL = 'audio.channel';

const String PW_KEY_AUDIO_RATE = 'audio.rate';

const String PW_KEY_AUDIO_CHANNELS = 'audio.channels';

const String PW_KEY_AUDIO_FORMAT = 'audio.format';

const String PW_KEY_AUDIO_ALLOWED_RATES = 'audio.allowed-rates';

const String PW_KEY_VIDEO_RATE = 'video.framerate';

const String PW_KEY_VIDEO_FORMAT = 'video.format';

const String PW_KEY_VIDEO_SIZE = 'video.size';

const String PW_KEY_TARGET_OBJECT = 'target.object';

const int SPA_LOG_TOPIC_DEFAULT = 0;

const String SPA_TYPE_INTERFACE_Log = 'Spa:Pointer:Interface:Log';

const int SPA_VERSION_LOG = 0;

const int SPA_VERSION_LOG_TOPIC = 0;

const int SPA_VERSION_LOG_METHODS = 1;

const String SPA_KEY_LOG_LEVEL = 'log.level';

const String SPA_KEY_LOG_COLORS = 'log.colors';

const String SPA_KEY_LOG_FILE = 'log.file';

const String SPA_KEY_LOG_TIMESTAMP = 'log.timestamp';

const String SPA_KEY_LOG_LINE = 'log.line';

const String SPA_KEY_LOG_PATTERNS = 'log.patterns';

const String PW_TYPE_INTERFACE_Link = 'PipeWire:Interface:Link';

const int PW_VERSION_LINK = 3;

const int PW_LINK_CHANGE_MASK_STATE = 1;

const int PW_LINK_CHANGE_MASK_FORMAT = 2;

const int PW_LINK_CHANGE_MASK_PROPS = 4;

const int PW_LINK_CHANGE_MASK_ALL = 7;

const int PW_LINK_EVENT_INFO = 0;

const int PW_LINK_EVENT_NUM = 1;

const int PW_VERSION_LINK_EVENTS = 0;

const int PW_LINK_METHOD_ADD_LISTENER = 0;

const int PW_LINK_METHOD_NUM = 1;

const int PW_VERSION_LINK_METHODS = 0;

const int PW_VERSION_MAIN_LOOP_EVENTS = 0;

const String PW_TYPE_INTERFACE_Module = 'PipeWire:Interface:Module';

const int PW_VERSION_MODULE = 3;

const int PW_MODULE_CHANGE_MASK_PROPS = 1;

const int PW_MODULE_CHANGE_MASK_ALL = 1;

const int PW_MODULE_EVENT_INFO = 0;

const int PW_MODULE_EVENT_NUM = 1;

const int PW_VERSION_MODULE_EVENTS = 0;

const int PW_MODULE_METHOD_ADD_LISTENER = 0;

const int PW_MODULE_METHOD_NUM = 1;

const int PW_VERSION_MODULE_METHODS = 0;

const String PW_TYPE_INTERFACE_Node = 'PipeWire:Interface:Node';

const int PW_VERSION_NODE = 3;

const int PW_NODE_CHANGE_MASK_INPUT_PORTS = 1;

const int PW_NODE_CHANGE_MASK_OUTPUT_PORTS = 2;

const int PW_NODE_CHANGE_MASK_STATE = 4;

const int PW_NODE_CHANGE_MASK_PROPS = 8;

const int PW_NODE_CHANGE_MASK_PARAMS = 16;

const int PW_NODE_CHANGE_MASK_ALL = 31;

const int PW_NODE_EVENT_INFO = 0;

const int PW_NODE_EVENT_PARAM = 1;

const int PW_NODE_EVENT_NUM = 2;

const int PW_VERSION_NODE_EVENTS = 0;

const int PW_NODE_METHOD_ADD_LISTENER = 0;

const int PW_NODE_METHOD_SUBSCRIBE_PARAMS = 1;

const int PW_NODE_METHOD_ENUM_PARAMS = 2;

const int PW_NODE_METHOD_SET_PARAM = 3;

const int PW_NODE_METHOD_SEND_COMMAND = 4;

const int PW_NODE_METHOD_NUM = 5;

const int PW_VERSION_NODE_METHODS = 0;

const String PW_TYPE_INTERFACE_Port = 'PipeWire:Interface:Port';

const int PW_VERSION_PORT = 3;

const int PW_DIRECTION_INPUT = 0;

const int PW_DIRECTION_OUTPUT = 1;

const int PW_PORT_CHANGE_MASK_PROPS = 1;

const int PW_PORT_CHANGE_MASK_PARAMS = 2;

const int PW_PORT_CHANGE_MASK_ALL = 3;

const int PW_PORT_EVENT_INFO = 0;

const int PW_PORT_EVENT_PARAM = 1;

const int PW_PORT_EVENT_NUM = 2;

const int PW_VERSION_PORT_EVENTS = 0;

const int PW_PORT_METHOD_ADD_LISTENER = 0;

const int PW_PORT_METHOD_SUBSCRIBE_PARAMS = 1;

const int PW_PORT_METHOD_ENUM_PARAMS = 2;

const int PW_PORT_METHOD_NUM = 3;

const int PW_VERSION_PORT_METHODS = 0;

const int PW_VERSION_STREAM_EVENTS = 2;

const int SPA_STATUS_OK = 0;

const int SPA_STATUS_NEED_DATA = 1;

const int SPA_STATUS_HAVE_DATA = 2;

const int SPA_STATUS_STOPPED = 4;

const int SPA_STATUS_DRAINED = 8;

const int SPA_IO_CLOCK_FLAG_FREEWHEEL = 1;

const int SPA_IO_VIDEO_SIZE_VALID = 1;

const int SPA_IO_SEGMENT_BAR_FLAG_VALID = 1;

const int SPA_IO_SEGMENT_VIDEO_FLAG_VALID = 1;

const int SPA_IO_SEGMENT_VIDEO_FLAG_DROP_FRAME = 2;

const int SPA_IO_SEGMENT_VIDEO_FLAG_PULL_DOWN = 4;

const int SPA_IO_SEGMENT_VIDEO_FLAG_INTERLACED = 8;

const int SPA_IO_SEGMENT_FLAG_LOOPING = 1;

const int SPA_IO_SEGMENT_FLAG_NO_POSITION = 2;

const int SPA_IO_POSITION_MAX_SEGMENTS = 8;

const int SPA_IO_RATE_MATCH_FLAG_ACTIVE = 1;

const int PW_VERSION_FILTER_EVENTS = 1;

const int PW_VERSION_THREAD_LOOP_EVENTS = 0;

const int PW_VERSION_DATA_LOOP_EVENTS = 0;

const String PW_TYPE_INFO_BASE = 'PipeWire:';

const String PW_TYPE_INFO_Object = 'PipeWire:Object';

const String PW_TYPE_INFO_OBJECT_BASE = 'PipeWire:Object:';

const String PW_TYPE_INFO_Interface = 'PipeWire:Interface';

const String PW_TYPE_INFO_INTERFACE_BASE = 'PipeWire:Interface:';

const String PW_API_VERSION = '0.3';

const int PW_MAJOR = 0;

const int PW_MINOR = 3;

const int PW_MICRO = 48;
