// ignore_for_file: camel_case_types, non_constant_identifier_names
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to Pipewire
class Pipewire {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Pipewire(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Pipewire.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// \addtogroup pw_pipewire
  /// \{
  void pw_init(
    ffi.Pointer<ffi.Int> argc,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> argv,
  ) {
    return _pw_init(
      argc,
      argv,
    );
  }

  late final _pw_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>>('pw_init');
  late final _pw_init = _pw_initPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>();

  void pw_deinit() {
    return _pw_deinit();
  }

  late final _pw_deinitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('pw_deinit');
  late final _pw_deinit = _pw_deinitPtr.asFunction<void Function()>();

  bool pw_debug_is_category_enabled(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _pw_debug_is_category_enabled(
      name,
    );
  }

  late final _pw_debug_is_category_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'pw_debug_is_category_enabled');
  late final _pw_debug_is_category_enabled = _pw_debug_is_category_enabledPtr
      .asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> pw_get_application_name() {
    return _pw_get_application_name();
  }

  late final _pw_get_application_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_application_name');
  late final _pw_get_application_name = _pw_get_application_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_prgname() {
    return _pw_get_prgname();
  }

  late final _pw_get_prgnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_prgname');
  late final _pw_get_prgname =
      _pw_get_prgnamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_user_name() {
    return _pw_get_user_name();
  }

  late final _pw_get_user_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_user_name');
  late final _pw_get_user_name =
      _pw_get_user_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_host_name() {
    return _pw_get_host_name();
  }

  late final _pw_get_host_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_host_name');
  late final _pw_get_host_name =
      _pw_get_host_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_client_name() {
    return _pw_get_client_name();
  }

  late final _pw_get_client_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_client_name');
  late final _pw_get_client_name =
      _pw_get_client_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  bool pw_in_valgrind() {
    return _pw_in_valgrind();
  }

  late final _pw_in_valgrindPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('pw_in_valgrind');
  late final _pw_in_valgrind = _pw_in_valgrindPtr.asFunction<bool Function()>();

  bool pw_check_option(
    ffi.Pointer<ffi.Char> option,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pw_check_option(
      option,
      value,
    );
  }

  late final _pw_check_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pw_check_option');
  late final _pw_check_option = _pw_check_optionPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int pw_direction_reverse(
    int direction,
  ) {
    return _pw_direction_reverse(
      direction,
    );
  }

  late final _pw_direction_reversePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'pw_direction_reverse');
  late final _pw_direction_reverse =
      _pw_direction_reversePtr.asFunction<int Function(int)>();

  int pw_set_domain(
    ffi.Pointer<ffi.Char> domain,
  ) {
    return _pw_set_domain(
      domain,
    );
  }

  late final _pw_set_domainPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'pw_set_domain');
  late final _pw_set_domain =
      _pw_set_domainPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> pw_get_domain() {
    return _pw_get_domain();
  }

  late final _pw_get_domainPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_domain');
  late final _pw_get_domain =
      _pw_get_domainPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int pw_get_support(
    ffi.Pointer<spa_support> support,
    int max_support,
  ) {
    return _pw_get_support(
      support,
      max_support,
    );
  }

  late final _pw_get_supportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<spa_support>, ffi.Uint32)>>('pw_get_support');
  late final _pw_get_support = _pw_get_supportPtr
      .asFunction<int Function(ffi.Pointer<spa_support>, int)>();

  ffi.Pointer<spa_handle> pw_load_spa_handle(
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> factory_name,
    ffi.Pointer<spa_dict> info,
    int n_support,
    ffi.Pointer<spa_support> support,
  ) {
    return _pw_load_spa_handle(
      lib,
      factory_name,
      info,
      n_support,
      support,
    );
  }

  late final _pw_load_spa_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_handle> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Uint32,
              ffi.Pointer<spa_support>)>>('pw_load_spa_handle');
  late final _pw_load_spa_handle = _pw_load_spa_handlePtr.asFunction<
      ffi.Pointer<spa_handle> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<spa_dict>,
          int,
          ffi.Pointer<spa_support>)>();

  int pw_unload_spa_handle(
    ffi.Pointer<spa_handle> handle,
  ) {
    return _pw_unload_spa_handle(
      handle,
    );
  }

  late final _pw_unload_spa_handlePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<spa_handle>)>>(
          'pw_unload_spa_handle');
  late final _pw_unload_spa_handle = _pw_unload_spa_handlePtr
      .asFunction<int Function(ffi.Pointer<spa_handle>)>();
}

/// \addtogroup pw_array
/// \{
class pw_array extends ffi.Struct {
  /// < pointer to array data
  external ffi.Pointer<ffi.Void> data;

  /// < length of array in bytes
  @ffi.Size()
  external int size;

  /// < number of allocated memory in \a data
  @ffi.Size()
  external int alloc;

  /// < number of bytes to extend with
  @ffi.Size()
  external int extend;
}

abstract class spa_direction {
  static const int SPA_DIRECTION_INPUT = 0;
  static const int SPA_DIRECTION_OUTPUT = 1;
}

/// Extra supporting infrastructure passed to the init() function of
/// a factory. It can be extra information or interfaces such as logging.
class spa_support extends ffi.Struct {
  /// < the type of the support item
  external ffi.Pointer<ffi.Char> type;

  /// < specific data for the item
  external ffi.Pointer<ffi.Void> data;
}

/// \addtogroup spa_handle
/// \{
class spa_handle extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Get the interface provided by \a handle with \a type.
  ///
  /// \a interface is always a struct spa_interface but depending on
  /// \a type, the struct might contain other information.
  ///
  /// \param handle a spa_handle
  /// \param type the interface type
  /// \param interface result to hold the interface.
  /// \return 0 on success
  /// -ENOTSUP when there are no interfaces
  /// -EINVAL when handle or info is NULL
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<spa_handle>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>> get_interface;

  /// Clean up the memory of \a handle. After this, \a handle should not be used
  /// anymore.
  ///
  /// \param handle a pointer to memory
  /// \return 0 on success
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int Function(ffi.Pointer<spa_handle>)>> clear;
}

class spa_dict extends ffi.Struct {
  @ffi.Uint32()
  external int flags;

  @ffi.Uint32()
  external int n_items;

  external ffi.Pointer<spa_dict_item> items;
}

/// \addtogroup spa_dict
/// \{
class spa_dict_item extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;
}
